class e{constructor(t,a=[],s="",r=""){this.data=t,this.grad=0,this._backward=()=>{},this._prev=a,this._op=s,this._name=r}add(t){t=t instanceof e?t:new e(t);let a=new e(this.data+t.data,[this,t],"+"),s=()=>{this.grad+=a.grad,t.grad+=a.grad};return a._backward=s,a}mul(t){t=t instanceof e?t:new e(t);let a=new e(this.data*t.data,[this,t],"*"),s=()=>{this.grad+=t.data*a.grad,t.grad+=this.data*a.grad};return a._backward=s,a}neg(){return this.mul(-1)}sub(t){t=t instanceof e?t:new e(t);let a=new e(this.data-t.data,[this,t],"-"),s=()=>{this.grad+=a.grad,t.grad+=-a.grad};return a._backward=s,a}div(t){return t=t instanceof e?t:new e(t),this.mul(t.pow(-1))}pow(t){if(!t instanceof Number)throw"A Value object can be only taken to a power of a Number";let a=new e(this.data**t,[this],`**${t}`),s=()=>{this.grad+=t*this.data**(t-1)*a.grad};return a._backward=s,a}sigmoid(){let t=new e(1/(1+Math.exp(-this.data)),[this],"sigmoid"),a=()=>{this.grad+=t.data*(1-t.data)*t.grad};return t._backward=a,t}relu(){let t=new e(this.data<0?0:this.data,[this],"ReLU"),a=()=>{this.grad+=(this.data>0)*t.grad};return t._backward=a,t}log(){let t=new e(Math.log(this.data),[this],"log"),a=()=>{this.grad+=1/this.data*t.grad};return t._backward=a,t}backward(){const t=[];let a=new Set;function s(r){a.has(r)||(a.add(r),r._prev.forEach(i=>{s(i)}),t.push(r))}s(this),this.grad=1,t.reverse(),t.forEach(r=>{r._backward()})}}class h{zeroGrad(){this.parameters().forEach(t=>{t.grad=0})}parameters(){return[]}}class o extends h{constructor(t,a="sigmoid"){super();let s=1,r=-1;const i=()=>Math.random()*(s-r)+r;this.w=[],this.b=new e(i()),this.b._name="bias",this.activation=a;for(let n=0;n<t;n++){let l=new e(i());l._name=`w_${n}`,this.w.push(l)}}forward(t){if(t.length!==this.w.length)throw"Input length does not correspond to weight length";let s=this.w.map((r,i)=>r.mul(t[i])).reduce((r,i)=>r.add(i),this.b);if(this.activation==="sigmoid")return s.sigmoid();if(this.activation==="relu")return s.relu()}parameters(){return[this.b,...this.w]}}class c extends h{constructor(t,a,s="sigmoid"){super(),this.neurons=[];for(let r=0;r<a;r++)this.neurons.push(new o(t,s))}forward(t){let a=this.neurons.map(s=>s.forward(t));return a.length===1?a[0]:a}parameters(){return this.neurons.map(t=>t.parameters()).flat()}}class w extends h{constructor(t,a){super();const s=[t,...a];this.layers=[];for(let r=0;r<s.length-1;r++){let i=new c(s[r],s[r+1],"sigmoid");this.layers.push(i)}}forward(t){let a=t;for(let s=0;s<this.layers.length;s++)a=this.layers[s].forward(a);return a}parameters(){return this.layers.map(t=>t.parameters()).flat()}}export{c as L,w as M,o as N,e as V};
