import{S as ze,i as Oe,s as Re,k as W,a as _,q as x,y as v,W as Ye,l as C,h as p,c as w,m as B,r as E,z as b,n as me,N as P,b as c,A as y,g as h,d,B as k,C as ce,e as ue,v as Pe,f as xe,P as Ee}from"../chunks/index.4d92b023.js";import{C as Fe}from"../chunks/Container.b0705c7b.js";import{B as Ae}from"../chunks/ButtonContainer.e9aac418.js";import{P as Ve}from"../chunks/PlayButton.85103c5a.js";import{H as Je}from"../chunks/Highlight.b7c1de53.js";import{P as Ke}from"../chunks/PythonCode.212ba7a6.js";import{P as De,T as Se}from"../chunks/Ticks.45eca5c5.js";import{P as X}from"../chunks/Path.7e6df014.js";import{C as Le}from"../chunks/Circle.f281e92b.js";import{T as Qe,a as Ue,b as Xe,R as je,H as Ze,D as et}from"../chunks/HeaderEntry.2b6e8f51.js";function qe(m,l,o){const e=m.slice();return e[6]=l[o],e}function He(m,l,o){const e=m.slice();return e[9]=l[o],e}function Ne(m,l,o){const e=m.slice();return e[12]=l[o],e}function tt(m){let l;return{c(){l=x("gradient clipping")},l(o){l=E(o,"gradient clipping")},m(o,e){c(o,l,e)},d(o){o&&p(l)}}}function lt(m){let l=m[12]+"",o;return{c(){o=x(l)},l(e){o=E(e,l)},m(e,t){c(e,o,t)},p:ce,d(e){e&&p(o)}}}function Ge(m){let l,o;return l=new Ze({props:{$$slots:{default:[lt]},$$scope:{ctx:m}}}),{c(){v(l.$$.fragment)},l(e){b(l.$$.fragment,e)},m(e,t){y(l,e,t),o=!0},p(e,t){const f={};t&32768&&(f.$$scope={dirty:t,ctx:e}),l.$set(f)},i(e){o||(h(l.$$.fragment,e),o=!0)},o(e){d(l.$$.fragment,e),o=!1},d(e){k(l,e)}}}function nt(m){let l,o,e=m[2],t=[];for(let r=0;r<e.length;r+=1)t[r]=Ge(Ne(m,e,r));const f=r=>d(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();l=ue()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);l=ue()},m(r,s){for(let i=0;i<t.length;i+=1)t[i]&&t[i].m(r,s);c(r,l,s),o=!0},p(r,s){if(s&4){e=r[2];let i;for(i=0;i<e.length;i+=1){const a=Ne(r,e,i);t[i]?(t[i].p(a,s),h(t[i],1)):(t[i]=Ge(a),t[i].c(),h(t[i],1),t[i].m(l.parentNode,l))}for(Pe(),i=e.length;i<t.length;i+=1)f(i);xe()}},i(r){if(!o){for(let s=0;s<e.length;s+=1)h(t[s]);o=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)d(t[s]);o=!1},d(r){Ee(t,r),r&&p(l)}}}function rt(m){let l,o;return l=new je({props:{$$slots:{default:[nt]},$$scope:{ctx:m}}}),{c(){v(l.$$.fragment)},l(e){b(l.$$.fragment,e)},m(e,t){y(l,e,t),o=!0},p(e,t){const f={};t&32768&&(f.$$scope={dirty:t,ctx:e}),l.$set(f)},i(e){o||(h(l.$$.fragment,e),o=!0)},o(e){d(l.$$.fragment,e),o=!1},d(e){k(l,e)}}}function at(m){let l=m[9]+"",o;return{c(){o=x(l)},l(e){o=E(e,l)},m(e,t){c(e,o,t)},p:ce,d(e){e&&p(o)}}}function Me(m){let l,o;return l=new et({props:{$$slots:{default:[at]},$$scope:{ctx:m}}}),{c(){v(l.$$.fragment)},l(e){b(l.$$.fragment,e)},m(e,t){y(l,e,t),o=!0},p(e,t){const f={};t&32768&&(f.$$scope={dirty:t,ctx:e}),l.$set(f)},i(e){o||(h(l.$$.fragment,e),o=!0)},o(e){d(l.$$.fragment,e),o=!1},d(e){k(l,e)}}}function ot(m){let l,o,e=m[6],t=[];for(let r=0;r<e.length;r+=1)t[r]=Me(He(m,e,r));const f=r=>d(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();l=_()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);l=w(r)},m(r,s){for(let i=0;i<t.length;i+=1)t[i]&&t[i].m(r,s);c(r,l,s),o=!0},p(r,s){if(s&8){e=r[6];let i;for(i=0;i<e.length;i+=1){const a=He(r,e,i);t[i]?(t[i].p(a,s),h(t[i],1)):(t[i]=Me(a),t[i].c(),h(t[i],1),t[i].m(l.parentNode,l))}for(Pe(),i=e.length;i<t.length;i+=1)f(i);xe()}},i(r){if(!o){for(let s=0;s<e.length;s+=1)h(t[s]);o=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)d(t[s]);o=!1},d(r){Ee(t,r),r&&p(l)}}}function Ie(m){let l,o;return l=new je({props:{$$slots:{default:[ot]},$$scope:{ctx:m}}}),{c(){v(l.$$.fragment)},l(e){b(l.$$.fragment,e)},m(e,t){y(l,e,t),o=!0},p(e,t){const f={};t&32768&&(f.$$scope={dirty:t,ctx:e}),l.$set(f)},i(e){o||(h(l.$$.fragment,e),o=!0)},o(e){d(l.$$.fragment,e),o=!1},d(e){k(l,e)}}}function it(m){let l,o,e=m[3],t=[];for(let r=0;r<e.length;r+=1)t[r]=Ie(qe(m,e,r));const f=r=>d(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();l=ue()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);l=ue()},m(r,s){for(let i=0;i<t.length;i+=1)t[i]&&t[i].m(r,s);c(r,l,s),o=!0},p(r,s){if(s&8){e=r[3];let i;for(i=0;i<e.length;i+=1){const a=qe(r,e,i);t[i]?(t[i].p(a,s),h(t[i],1)):(t[i]=Ie(a),t[i].c(),h(t[i],1),t[i].m(l.parentNode,l))}for(Pe(),i=e.length;i<t.length;i+=1)f(i);xe()}},i(r){if(!o){for(let s=0;s<e.length;s+=1)h(t[s]);o=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)d(t[s]);o=!1},d(r){Ee(t,r),r&&p(l)}}}function st(m){let l,o,e,t;return l=new Ue({props:{$$slots:{default:[rt]},$$scope:{ctx:m}}}),e=new Xe({props:{$$slots:{default:[it]},$$scope:{ctx:m}}}),{c(){v(l.$$.fragment),o=_(),v(e.$$.fragment)},l(f){b(l.$$.fragment,f),o=w(f),b(e.$$.fragment,f)},m(f,r){y(l,f,r),c(f,o,r),y(e,f,r),t=!0},p(f,r){const s={};r&32768&&(s.$$scope={dirty:r,ctx:f}),l.$set(s);const i={};r&32768&&(i.$$scope={dirty:r,ctx:f}),e.$set(i)},i(f){t||(h(l.$$.fragment,f),h(e.$$.fragment,f),t=!0)},o(f){d(l.$$.fragment,f),d(e.$$.fragment,f),t=!1},d(f){k(l,f),f&&p(o),k(e,f)}}}function ft(m){let l,o;return l=new Ve({props:{f:m[4],delta:800}}),{c(){v(l.$$.fragment)},l(e){b(l.$$.fragment,e)},m(e,t){y(l,e,t),o=!0},p:ce,i(e){o||(h(l.$$.fragment,e),o=!0)},o(e){d(l.$$.fragment,e),o=!1},d(e){k(l,e)}}}function $t(m){let l,o,e,t,f,r,s,i;return l=new Se({props:{xTicks:[-3,-2,-1,0,1,2,3],yTicks:[-3,-2,-1,0,1,2,3]}}),e=new X({props:{data:[{x:1,y:1},{x:-1,y:1},{x:-1,y:-1},{x:1,y:-1},{x:1,y:1}],color:"var(--main-color-1)"}}),f=new X({props:{data:m[0][1],color:"var(--main-color-1)"}}),s=new X({props:{data:m[0][0],strokeDashArray:[4,4]}}),{c(){v(l.$$.fragment),o=_(),v(e.$$.fragment),t=_(),v(f.$$.fragment),r=_(),v(s.$$.fragment)},l(a){b(l.$$.fragment,a),o=w(a),b(e.$$.fragment,a),t=w(a),b(f.$$.fragment,a),r=w(a),b(s.$$.fragment,a)},m(a,$){y(l,a,$),c(a,o,$),y(e,a,$),c(a,t,$),y(f,a,$),c(a,r,$),y(s,a,$),i=!0},p(a,$){const g={};$&1&&(g.data=a[0][1]),f.$set(g);const T={};$&1&&(T.data=a[0][0]),s.$set(T)},i(a){i||(h(l.$$.fragment,a),h(e.$$.fragment,a),h(f.$$.fragment,a),h(s.$$.fragment,a),i=!0)},o(a){d(l.$$.fragment,a),d(e.$$.fragment,a),d(f.$$.fragment,a),d(s.$$.fragment,a),i=!1},d(a){k(l,a),a&&p(o),k(e,a),a&&p(t),k(f,a),a&&p(r),k(s,a)}}}function pt(m){let l,o;return l=new Ve({props:{f:m[5],delta:800}}),{c(){v(l.$$.fragment)},l(e){b(l.$$.fragment,e)},m(e,t){y(l,e,t),o=!0},p:ce,i(e){o||(h(l.$$.fragment,e),o=!0)},o(e){d(l.$$.fragment,e),o=!1},d(e){k(l,e)}}}function mt(m){let l,o,e,t,f,r,s,i;return l=new Se({props:{xTicks:[-3,-2,-1,0,1,2,3],yTicks:[-3,-2,-1,0,1,2,3]}}),e=new Le({props:{data:[{x:0,y:0}],color:"none",radius:"70"}}),f=new X({props:{data:m[1][0],strokeDashArray:[4,4]}}),s=new X({props:{data:m[1][1],color:"var(--main-color-1)"}}),{c(){v(l.$$.fragment),o=_(),v(e.$$.fragment),t=_(),v(f.$$.fragment),r=_(),v(s.$$.fragment)},l(a){b(l.$$.fragment,a),o=w(a),b(e.$$.fragment,a),t=w(a),b(f.$$.fragment,a),r=w(a),b(s.$$.fragment,a)},m(a,$){y(l,a,$),c(a,o,$),y(e,a,$),c(a,t,$),y(f,a,$),c(a,r,$),y(s,a,$),i=!0},p(a,$){const g={};$&2&&(g.data=a[1][0]),f.$set(g);const T={};$&2&&(T.data=a[1][1]),s.$set(T)},i(a){i||(h(l.$$.fragment,a),h(e.$$.fragment,a),h(f.$$.fragment,a),h(s.$$.fragment,a),i=!0)},o(a){d(l.$$.fragment,a),d(e.$$.fragment,a),d(f.$$.fragment,a),d(s.$$.fragment,a),i=!1},d(a){k(l,a),a&&p(o),k(e,a),a&&p(t),k(f,a),a&&p(r),k(s,a)}}}function ut(m){let l,o,e,t,f,r,s,i,a,$,g,T,Z,I,he,ee,D,te,q,le,V,de,ne,S,ge,re,H,ae,N,oe,j,_e,ie,A,we,Y,ve,be,F,ye,ke,se,G,fe,z,Te,$e,O,pe;return r=new Je({props:{$$slots:{default:[tt]},$$scope:{ctx:m}}}),T=new Qe({props:{$$slots:{default:[st]},$$scope:{ctx:m}}}),D=new Ae({props:{$$slots:{default:[ft]},$$scope:{ctx:m}}}),q=new De({props:{width:500,height:500,maxWidth:500,domain:[-3,3],range:[-3,3],$$slots:{default:[$t]},$$scope:{ctx:m}}}),H=new Ae({props:{$$slots:{default:[pt]},$$scope:{ctx:m}}}),N=new De({props:{width:500,height:500,maxWidth:500,domain:[-3,3],range:[-3,3],$$slots:{default:[mt]},$$scope:{ctx:m}}}),G=new Ke({props:{code:"nn.utils.clip_grad_norm_(model.parameters(), max_norm=1)"}}),{c(){l=W("p"),o=x(`The exploding gradients problem arises when the gradients get larger and
    larger, until they get larger than the maximum permitted value for the
    tensor datatype.`),e=_(),t=W("p"),f=x(`We could remedy the problem with a simple solution. We could determine the
    maximum allowed gradient and if the gradient value moves beyond that
    threshold we cut the gradient to the allowed value. The technique we just
    described is called `),v(r.$$.fragment),s=x(`, value clipping
    to be exact.`),i=_(),a=W("p"),$=x(`The below table demonstrates how value clipping works in theory. We set the
    threshold value to 1 and if the absolute value of the gradient moves beyond
    the threshold, we clip it to the max value.`),g=_(),v(T.$$.fragment),Z=_(),I=W("p"),he=x(`Value clipping is problematic, because it basically changes the direction of
    gradient descent. Below is a simulation to demonstrate the problem. When you
    start the simulation, the gradient vector (dashed line) will start to move
    randomly in the 2d coordinate system. If one of of the two gradients is
    larger than one, we will clip that gradient to 1 and thus create a new
    gradient vector (red line). So if one gradient is 3 and the other is 1.5, we
    clip both to 1, thereby disregarding the relative magnitude of the vector
    components and changing the direction of the vector. This is not what we
    actually desire.`),ee=_(),v(D.$$.fragment),te=_(),v(q.$$.fragment),le=_(),V=W("p"),de=x(`A better solution is to use norm clipping. When we clip the norm of the
    gradient vector, we clip all the gradients proportionally, such that the
    direction remains the same.`),ne=_(),S=W("p"),ge=x(`Below is a simulation of norm clipping. When the magnitude of the gradient
    vector is reduced to the threshold value, the direction remains unchanged.`),re=_(),v(H.$$.fragment),ae=_(),v(N.$$.fragment),oe=_(),j=W("p"),_e=x(`Norm clipping often feels like a hack, but it is actually quite practical.
    You might not be able to solve all your problems with gradient clipping, but
    it should be part of your toolbox.`),ie=_(),A=W("p"),we=x(`The implementation of gradient clipping is PyTorch is astonishingly simple.
    All we have to do is to add the following line of code after we call `),Y=W("code"),ve=x("loss.backward()"),be=x(`
    but before we call `),F=W("code"),ye=x("optimizer.step()"),ke=x("."),se=_(),v(G.$$.fragment),fe=_(),z=W("p"),Te=x(`The above line concatenates all parameter gradients into a single vector,
    calculates the norm for that vector and eventually clips the gradients
    in-place, if the norm is above 1.`),$e=_(),O=W("div"),this.h()},l(n){l=C(n,"P",{});var u=B(l);o=E(u,`The exploding gradients problem arises when the gradients get larger and
    larger, until they get larger than the maximum permitted value for the
    tensor datatype.`),u.forEach(p),e=w(n),t=C(n,"P",{});var M=B(t);f=E(M,`We could remedy the problem with a simple solution. We could determine the
    maximum allowed gradient and if the gradient value moves beyond that
    threshold we cut the gradient to the allowed value. The technique we just
    described is called `),b(r.$$.fragment,M),s=E(M,`, value clipping
    to be exact.`),M.forEach(p),i=w(n),a=C(n,"P",{});var J=B(a);$=E(J,`The below table demonstrates how value clipping works in theory. We set the
    threshold value to 1 and if the absolute value of the gradient moves beyond
    the threshold, we clip it to the max value.`),J.forEach(p),g=w(n),b(T.$$.fragment,n),Z=w(n),I=C(n,"P",{});var K=B(I);he=E(K,`Value clipping is problematic, because it basically changes the direction of
    gradient descent. Below is a simulation to demonstrate the problem. When you
    start the simulation, the gradient vector (dashed line) will start to move
    randomly in the 2d coordinate system. If one of of the two gradients is
    larger than one, we will clip that gradient to 1 and thus create a new
    gradient vector (red line). So if one gradient is 3 and the other is 1.5, we
    clip both to 1, thereby disregarding the relative magnitude of the vector
    components and changing the direction of the vector. This is not what we
    actually desire.`),K.forEach(p),ee=w(n),b(D.$$.fragment,n),te=w(n),b(q.$$.fragment,n),le=w(n),V=C(n,"P",{});var L=B(V);de=E(L,`A better solution is to use norm clipping. When we clip the norm of the
    gradient vector, we clip all the gradients proportionally, such that the
    direction remains the same.`),L.forEach(p),ne=w(n),S=C(n,"P",{});var Q=B(S);ge=E(Q,`Below is a simulation of norm clipping. When the magnitude of the gradient
    vector is reduced to the threshold value, the direction remains unchanged.`),Q.forEach(p),re=w(n),b(H.$$.fragment,n),ae=w(n),b(N.$$.fragment,n),oe=w(n),j=C(n,"P",{});var U=B(j);_e=E(U,`Norm clipping often feels like a hack, but it is actually quite practical.
    You might not be able to solve all your problems with gradient clipping, but
    it should be part of your toolbox.`),U.forEach(p),ie=w(n),A=C(n,"P",{});var R=B(A);we=E(R,`The implementation of gradient clipping is PyTorch is astonishingly simple.
    All we have to do is to add the following line of code after we call `),Y=C(R,"CODE",{});var We=B(Y);ve=E(We,"loss.backward()"),We.forEach(p),be=E(R,`
    but before we call `),F=C(R,"CODE",{});var Ce=B(F);ye=E(Ce,"optimizer.step()"),Ce.forEach(p),ke=E(R,"."),R.forEach(p),se=w(n),b(G.$$.fragment,n),fe=w(n),z=C(n,"P",{});var Be=B(z);Te=E(Be,`The above line concatenates all parameter gradients into a single vector,
    calculates the norm for that vector and eventually clips the gradients
    in-place, if the norm is above 1.`),Be.forEach(p),$e=w(n),O=C(n,"DIV",{class:!0}),B(O).forEach(p),this.h()},h(){me(O,"class","separator")},m(n,u){c(n,l,u),P(l,o),c(n,e,u),c(n,t,u),P(t,f),y(r,t,null),P(t,s),c(n,i,u),c(n,a,u),P(a,$),c(n,g,u),y(T,n,u),c(n,Z,u),c(n,I,u),P(I,he),c(n,ee,u),y(D,n,u),c(n,te,u),y(q,n,u),c(n,le,u),c(n,V,u),P(V,de),c(n,ne,u),c(n,S,u),P(S,ge),c(n,re,u),y(H,n,u),c(n,ae,u),y(N,n,u),c(n,oe,u),c(n,j,u),P(j,_e),c(n,ie,u),c(n,A,u),P(A,we),P(A,Y),P(Y,ve),P(A,be),P(A,F),P(F,ye),P(A,ke),c(n,se,u),y(G,n,u),c(n,fe,u),c(n,z,u),P(z,Te),c(n,$e,u),c(n,O,u),pe=!0},p(n,u){const M={};u&32768&&(M.$$scope={dirty:u,ctx:n}),r.$set(M);const J={};u&32768&&(J.$$scope={dirty:u,ctx:n}),T.$set(J);const K={};u&32768&&(K.$$scope={dirty:u,ctx:n}),D.$set(K);const L={};u&32769&&(L.$$scope={dirty:u,ctx:n}),q.$set(L);const Q={};u&32768&&(Q.$$scope={dirty:u,ctx:n}),H.$set(Q);const U={};u&32770&&(U.$$scope={dirty:u,ctx:n}),N.$set(U)},i(n){pe||(h(r.$$.fragment,n),h(T.$$.fragment,n),h(D.$$.fragment,n),h(q.$$.fragment,n),h(H.$$.fragment,n),h(N.$$.fragment,n),h(G.$$.fragment,n),pe=!0)},o(n){d(r.$$.fragment,n),d(T.$$.fragment,n),d(D.$$.fragment,n),d(q.$$.fragment,n),d(H.$$.fragment,n),d(N.$$.fragment,n),d(G.$$.fragment,n),pe=!1},d(n){n&&p(l),n&&p(e),n&&p(t),k(r),n&&p(i),n&&p(a),n&&p(g),k(T,n),n&&p(Z),n&&p(I),n&&p(ee),k(D,n),n&&p(te),k(q,n),n&&p(le),n&&p(V),n&&p(ne),n&&p(S),n&&p(re),k(H,n),n&&p(ae),k(N,n),n&&p(oe),n&&p(j),n&&p(ie),n&&p(A),n&&p(se),k(G,n),n&&p(fe),n&&p(z),n&&p($e),n&&p(O)}}}function ct(m){let l,o,e,t,f,r,s,i,a;return i=new Fe({props:{$$slots:{default:[ut]},$$scope:{ctx:m}}}),{c(){l=W("meta"),o=_(),e=W("h1"),t=x("Gradient Clipping"),f=_(),r=W("div"),s=_(),v(i.$$.fragment),this.h()},l($){const g=Ye("svelte-acjc2c",document.head);l=C(g,"META",{name:!0,content:!0}),g.forEach(p),o=w($),e=C($,"H1",{});var T=B(e);t=E(T,"Gradient Clipping"),T.forEach(p),f=w($),r=C($,"DIV",{class:!0}),B(r).forEach(p),s=w($),b(i.$$.fragment,$),this.h()},h(){document.title="Gradient Clipping - World4AI",me(l,"name","description"),me(l,"content","Gradient clipping clips either individual gradient values or the norm of the gradient vector at a predetermined threshold, thereby reducing the likelihood of exploding gradients."),me(r,"class","separator")},m($,g){P(document.head,l),c($,o,g),c($,e,g),P(e,t),c($,f,g),c($,r,g),c($,s,g),y(i,$,g),a=!0},p($,[g]){const T={};g&32771&&(T.$$scope={dirty:g,ctx:$}),i.$set(T)},i($){a||(h(i.$$.fragment,$),a=!0)},o($){d(i.$$.fragment,$),a=!1},d($){p(l),$&&p(o),$&&p(e),$&&p(f),$&&p(r),$&&p(s),k(i,$)}}}function ht(m,l,o){const e=["Original Gradient","Clipped Gradient"],t=[[1,1],[.5,.5],[2,1],[-3,-1]];let f=[];function r(){o(0,f=[]);let a=Math.random()*6-3,$=Math.random()*6-3;f.push([{x:0,y:0},{x:a,y:$}]),a>=1?a=1:a<-1&&(a=-1),$>=1?$=1:$<-1&&($=-1),f.push([{x:0,y:0},{x:a,y:$}])}r();let s=[];function i(){o(1,s=[]);let a=Math.random()*6-3,$=Math.random()*6-3;s.push([{x:0,y:0},{x:a,y:$}]);let g=Math.sqrt(a**2+$**2);g>1&&(a=a/g,$=$/g),s.push([{x:0,y:0},{x:a,y:$}])}return i(),[f,s,e,t,r,i]}class xt extends ze{constructor(l){super(),Oe(this,l,ht,ct,Re,{})}}export{xt as default};
