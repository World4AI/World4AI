import{S as dt,i as ct,s as wt,k as X,a as B,q as c,y as f,W as vt,l as L,h as a,c as I,m as P,r as w,z as l,n as re,N as y,b as $,A as m,g as p,d as u,B as g,C as j,Q as De,R as We}from"../chunks/index.4d92b023.js";import{C as _t}from"../chunks/Container.b0705c7b.js";import{L as N}from"../chunks/Latex.e0b308c0.js";import{F as xt,I as bt}from"../chunks/InternalLink.7deb899c.js";import{S as ht}from"../chunks/SvgContainer.f70b5745.js";import{B as F}from"../chunks/Block.059eddcd.js";import{A as G}from"../chunks/Arrow.ae91874c.js";import{B as Me}from"../chunks/Border.97f6e782.js";function yt(v){let r=String.raw`\mathbf{z}`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function kt(v){let r,n,t,i,D,E,W,z,S,T,A,s,b,k,q,C,H;return n=new G({props:{data:[{x:x+12.5+5,y:90-75},{x:x+80*2-12.5-10,y:90-20}],dashed:!0,strokeDashArray:"4 4",strokeWidth:1.5,moving:!0,speed:50}}),t=new G({props:{data:[{x:x+12.5+5,y:90+75},{x:x+80*2-12.5-10,y:90+20}],dashed:!0,strokeDashArray:"4 4",strokeWidth:1.5,moving:!0,speed:50}}),i=new G({props:{data:[{x:x+80*2+12.5+5,y:90-20},{x:x+80*4-12.5-10,y:90-75}],dashed:!0,strokeDashArray:"4 4",strokeWidth:1.5,moving:!0,speed:50}}),D=new G({props:{data:[{x:x+80*2+12.5+5,y:90+20},{x:x+80*4-12.5-10,y:90+75}],dashed:!0,strokeDashArray:"4 4",strokeWidth:1.5,moving:!0,speed:50}}),E=new F({props:{x:x+0,y:90,width:25,height:150,text:"X",type:"latex",fontSize:"20",color:"var(--main-color-3)"}}),W=new F({props:{x:x+80,y:90,width:25,height:100,color:"var(--main-color-2)"}}),z=new F({props:{x:x+80*2,y:90,width:25,height:40,text:String.raw`\mathbf{z}`,type:"latex",fontSize:"20",color:"var(--main-color-1)"}}),S=new F({props:{x:x+80*3,y:90,width:25,height:100,color:"var(--main-color-2)"}}),T=new F({props:{x:x+80*4,y:90,width:25,height:150,text:"X'",type:"latex",fontSize:"20",color:"var(--main-color-3)"}}),A=new Me({props:{x:10,y:5,width:140,height:180}}),s=new Me({props:{x:250,y:5,width:140,height:180}}),b=new F({props:{x:50,y:230,width:80,height:25,text:"Encoder",fontSize:"15"}}),k=new F({props:{x:200,y:40,width:80,height:20,text:"Bottleneck",fontSize:"12"}}),q=new F({props:{x:350,y:230,width:80,height:25,text:"Decoder",fontSize:"15"}}),{c(){r=De("svg"),f(n.$$.fragment),f(t.$$.fragment),f(i.$$.fragment),f(D.$$.fragment),f(E.$$.fragment),f(W.$$.fragment),f(z.$$.fragment),f(S.$$.fragment),f(T.$$.fragment),f(A.$$.fragment),f(s.$$.fragment),f(b.$$.fragment),f(k.$$.fragment),f(q.$$.fragment),C=De("svg"),this.h()},l(d){r=We(d,"svg",{viewBox:!0});var _=P(r);l(n.$$.fragment,_),l(t.$$.fragment,_),l(i.$$.fragment,_),l(D.$$.fragment,_),l(E.$$.fragment,_),l(W.$$.fragment,_),l(z.$$.fragment,_),l(S.$$.fragment,_),l(T.$$.fragment,_),l(A.$$.fragment,_),l(s.$$.fragment,_),l(b.$$.fragment,_),l(k.$$.fragment,_),l(q.$$.fragment,_),C=We(_,"svg",{});var K=P(C);K.forEach(a),_.forEach(a),this.h()},h(){re(r,"viewBox","0 0 400 250")},m(d,_){$(d,r,_),m(n,r,null),m(t,r,null),m(i,r,null),m(D,r,null),m(E,r,null),m(W,r,null),m(z,r,null),m(S,r,null),m(T,r,null),m(A,r,null),m(s,r,null),m(b,r,null),m(k,r,null),m(q,r,null),y(r,C),H=!0},p:j,i(d){H||(p(n.$$.fragment,d),p(t.$$.fragment,d),p(i.$$.fragment,d),p(D.$$.fragment,d),p(E.$$.fragment,d),p(W.$$.fragment,d),p(z.$$.fragment,d),p(S.$$.fragment,d),p(T.$$.fragment,d),p(A.$$.fragment,d),p(s.$$.fragment,d),p(b.$$.fragment,d),p(k.$$.fragment,d),p(q.$$.fragment,d),H=!0)},o(d){u(n.$$.fragment,d),u(t.$$.fragment,d),u(i.$$.fragment,d),u(D.$$.fragment,d),u(E.$$.fragment,d),u(W.$$.fragment,d),u(z.$$.fragment,d),u(S.$$.fragment,d),u(T.$$.fragment,d),u(A.$$.fragment,d),u(s.$$.fragment,d),u(b.$$.fragment,d),u(k.$$.fragment,d),u(q.$$.fragment,d),H=!1},d(d){d&&a(r),g(n),g(t),g(i),g(D),g(E),g(W),g(z),g(S),g(T),g(A),g(s),g(b),g(k),g(q)}}}function Et(v){let r=String.raw`\mathbf{z}`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function zt(v){let r=String.raw`X`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function St(v){let r,n,t,i,D,E,W,z,S,T,A,s,b,k,q,C,H,d,_,K,R,ne,Q;return n=new G({props:{data:[{x:x+12.5+5,y:90-75},{x:x+80*2-12.5-10,y:90-20}],dashed:!0,strokeDashArray:"4 4",strokeWidth:1.5,moving:!0,speed:50}}),t=new G({props:{data:[{x:x+12.5+5,y:90+75},{x:x+80*2-12.5-10,y:90+20}],dashed:!0,strokeDashArray:"4 4",strokeWidth:1.5,moving:!0,speed:50}}),i=new G({props:{data:[{x:x+80*2+12.5,y:60},{x:x+80*2+60,y:80}],dashed:!0,strokeDashArray:"4 4",strokeWidth:1.5,moving:!0,speed:50}}),D=new G({props:{data:[{x:x+80*2+12.5,y:120},{x:x+80*2+60,y:100}],dashed:!0,strokeDashArray:"4 4",strokeWidth:1.5,moving:!0,speed:50}}),E=new G({props:{data:[{x:x+80*2+12.5,y:225},{x:x+80*2+80,y:225},{x:x+80*2+80,y:115}],dashed:!0,strokeDashArray:"4 4",strokeWidth:1.5,moving:!0,speed:50}}),W=new F({props:{x:x+0,y:90,width:25,height:150,text:"X",type:"latex",fontSize:"20",color:"var(--main-color-3)"}}),z=new F({props:{x:x+80,y:90,width:25,height:100,color:"var(--main-color-2)"}}),S=new F({props:{x:x+80*2,y:60,width:25,height:30,text:"\\boldsymbol \\mu",type:"latex",fontSize:"20",color:"var(--main-color-1)"}}),T=new F({props:{x:x+80*2,y:120,width:25,height:30,text:"\\boldsymbol \\sigma",type:"latex",fontSize:"20",color:"var(--main-color-1)"}}),A=new F({props:{x:x+80*2,y:225,width:25,height:30,text:"\\boldsymbol \\epsilon",type:"latex",fontSize:"20",color:"var(--main-color-1)"}}),b=new G({props:{data:[{x:x+80*2+12.5+5,y:90-20},{x:x+80*4-12.5-10,y:90-75}],dashed:!0,strokeDashArray:"4 4",strokeWidth:1.5,moving:!0,speed:50}}),k=new G({props:{data:[{x:x+80*2+12.5+5,y:90+20},{x:x+80*4-12.5-10,y:90+75}],dashed:!0,strokeDashArray:"4 4",strokeWidth:1.5,moving:!0,speed:50}}),q=new F({props:{x:x+80*2,y:90,width:25,height:30,text:String.raw`\mathbf{z}`,type:"latex",fontSize:"20",color:"var(--main-color-1)"}}),C=new F({props:{x:x+80*3,y:90,width:25,height:100,color:"var(--main-color-2)"}}),H=new F({props:{x:x+80*4,y:90,width:25,height:150,text:"X'",type:"latex",fontSize:"20",color:"var(--main-color-3)"}}),d=new Me({props:{x:10,y:5,width:140,height:180}}),_=new Me({props:{x:300,y:5,width:160,height:180}}),K=new F({props:{x:50,y:230,width:80,height:25,text:"Encoder",fontSize:"15"}}),R=new F({props:{x:420,y:230,width:80,height:25,text:"Decoder",fontSize:"15"}}),{c(){r=De("svg"),f(n.$$.fragment),f(t.$$.fragment),f(i.$$.fragment),f(D.$$.fragment),f(E.$$.fragment),f(W.$$.fragment),f(z.$$.fragment),f(S.$$.fragment),f(T.$$.fragment),f(A.$$.fragment),s=De("g"),f(b.$$.fragment),f(k.$$.fragment),f(q.$$.fragment),f(C.$$.fragment),f(H.$$.fragment),f(d.$$.fragment),f(_.$$.fragment),f(K.$$.fragment),f(R.$$.fragment),ne=De("svg"),this.h()},l(h){r=We(h,"svg",{viewBox:!0});var V=P(r);l(n.$$.fragment,V),l(t.$$.fragment,V),l(i.$$.fragment,V),l(D.$$.fragment,V),l(E.$$.fragment,V),l(W.$$.fragment,V),l(z.$$.fragment,V),l(S.$$.fragment,V),l(T.$$.fragment,V),l(A.$$.fragment,V),s=We(V,"g",{transform:!0});var J=P(s);l(b.$$.fragment,J),l(k.$$.fragment,J),l(q.$$.fragment,J),l(C.$$.fragment,J),l(H.$$.fragment,J),J.forEach(a),l(d.$$.fragment,V),l(_.$$.fragment,V),l(K.$$.fragment,V),l(R.$$.fragment,V),ne=We(V,"svg",{});var _e=P(ne);_e.forEach(a),V.forEach(a),this.h()},h(){re(s,"transform","translate(80, 0)"),re(r,"viewBox","0 0 470 250")},m(h,V){$(h,r,V),m(n,r,null),m(t,r,null),m(i,r,null),m(D,r,null),m(E,r,null),m(W,r,null),m(z,r,null),m(S,r,null),m(T,r,null),m(A,r,null),y(r,s),m(b,s,null),m(k,s,null),m(q,s,null),m(C,s,null),m(H,s,null),m(d,r,null),m(_,r,null),m(K,r,null),m(R,r,null),y(r,ne),Q=!0},p:j,i(h){Q||(p(n.$$.fragment,h),p(t.$$.fragment,h),p(i.$$.fragment,h),p(D.$$.fragment,h),p(E.$$.fragment,h),p(W.$$.fragment,h),p(z.$$.fragment,h),p(S.$$.fragment,h),p(T.$$.fragment,h),p(A.$$.fragment,h),p(b.$$.fragment,h),p(k.$$.fragment,h),p(q.$$.fragment,h),p(C.$$.fragment,h),p(H.$$.fragment,h),p(d.$$.fragment,h),p(_.$$.fragment,h),p(K.$$.fragment,h),p(R.$$.fragment,h),Q=!0)},o(h){u(n.$$.fragment,h),u(t.$$.fragment,h),u(i.$$.fragment,h),u(D.$$.fragment,h),u(E.$$.fragment,h),u(W.$$.fragment,h),u(z.$$.fragment,h),u(S.$$.fragment,h),u(T.$$.fragment,h),u(A.$$.fragment,h),u(b.$$.fragment,h),u(k.$$.fragment,h),u(q.$$.fragment,h),u(C.$$.fragment,h),u(H.$$.fragment,h),u(d.$$.fragment,h),u(_.$$.fragment,h),u(K.$$.fragment,h),u(R.$$.fragment,h),Q=!1},d(h){h&&a(r),g(n),g(t),g(i),g(D),g(E),g(W),g(z),g(S),g(T),g(A),g(b),g(k),g(q),g(C),g(H),g(d),g(_),g(K),g(R)}}}function At(v){let r=String.raw`\mathbf{x}`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function Vt(v){let r=String.raw`\boldsymbol \mu`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function Tt(v){let r=String.raw`\boldsymbol \sigma`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function Dt(v){let r=String.raw`\epsilon`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function Wt(v){let r=String.raw`\epsilon_i \sim \mathcal{N}(0, 1)`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function Bt(v){let r=String.raw`\mathbf{z}`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function It(v){let r=String.raw`\mathbf{z} = \boldsymbol \mu + \boldsymbol \sigma \odot \boldsymbol \epsilon \text{, where } \odot \text{ is elementwise multiplication}`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function Pt(v){let r=String.raw`\mathcal{L} = Reconstruction + Regularizer`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function qt(v){let r=String.raw`X`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function Ct(v){let r=String.raw`X'`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function Xt(v){let r=String.raw`\mathbf{z}`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function Lt(v){let r=String.raw`- \dfrac{1}{2} \sum^n_i (1 + \log \sigma_i^2 - \mu_i^2 - \sigma_i^2)`+"",n;return{c(){n=c(r)},l(t){n=w(t,r)},m(t,i){$(t,n,i)},p:j,d(t){t&&a(n)}}}function Ft(v){let r,n,t,i,D,E,W,z,S,T,A,s,b,k,q,C,H,d,_,K,R,ne,Q,h,V,J,_e,ae,Be,O,Ne,oe,Ke,se,Qe,ie,Ue,$e,Ge,fe,Je,Ie,le,Ye,me,Ze,Pe,pe,qe,xe,et,Ce,ue,Xe,Y,tt,ge,rt,he,nt,Le,Z,at,de,ot,ce,st,Fe,be,je,ye,it,He,ke,$t,Oe,Ee,Re;return A=new N({props:{$$slots:{default:[yt]},$$scope:{ctx:v}}}),k=new ht({props:{maxWidth:"600px",$$slots:{default:[kt]},$$scope:{ctx:v}}}),R=new bt({props:{id:1,type:"reference"}}),Q=new N({props:{$$slots:{default:[Et]},$$scope:{ctx:v}}}),V=new N({props:{$$slots:{default:[zt]},$$scope:{ctx:v}}}),ae=new ht({props:{maxWidth:"700px",$$slots:{default:[St]},$$scope:{ctx:v}}}),oe=new N({props:{$$slots:{default:[At]},$$scope:{ctx:v}}}),se=new N({props:{$$slots:{default:[Vt]},$$scope:{ctx:v}}}),ie=new N({props:{$$slots:{default:[Tt]},$$scope:{ctx:v}}}),$e=new N({props:{$$slots:{default:[Dt]},$$scope:{ctx:v}}}),fe=new N({props:{$$slots:{default:[Wt]},$$scope:{ctx:v}}}),me=new N({props:{$$slots:{default:[Bt]},$$scope:{ctx:v}}}),pe=new N({props:{$$slots:{default:[It]},$$scope:{ctx:v}}}),ue=new N({props:{$$slots:{default:[Pt]},$$scope:{ctx:v}}}),ge=new N({props:{$$slots:{default:[qt]},$$scope:{ctx:v}}}),he=new N({props:{$$slots:{default:[Ct]},$$scope:{ctx:v}}}),de=new N({props:{$$slots:{default:[Xt]},$$scope:{ctx:v}}}),ce=new N({props:{$$slots:{default:[Lt]},$$scope:{ctx:v}}}),{c(){r=X("p"),n=c("Variational autoencoders (VAE) are a family of autoencoders that are based on variational Bayesian methods. The mathematical background knowledge that is required to fully understand all intricacies of VAEs is quite extensive and can be intimidating for beginners. Therefore we will introduce VAEs using an intuitive setting first. In a second step we will delve deeper into the theoretical justification of variational autoencoders and provide additional sources for you to study. Fortunately the intuitive introduction is sufficient to implement a VAE from scratch in PyTorch, so you might skip the theoretical part for now and return to it at a later point, once you gained a better mathematical foundation."),t=B(),i=X("div"),D=B(),E=X("h2"),W=c("VAE Intuition"),z=B(),S=X("p"),T=c("The autoencoder, that we have discussed in the previous section follow a very simple approach: map an image to a latent vector "),f(A.$$.fragment),s=c(" and reconstruct the original image from from the latent variable."),b=B(),f(k.$$.fragment),q=B(),C=X("p"),H=c("While this procedure might be good enough for simple compression tasks, when it comes to generating new images, this simple mapping approach might break down. The latent space that is learned might not be smooth or continuous, so when you sample a latent vector that deviates slightly from the samples that the decoder saw during training, you will end up with a nonsence image."),d=B(),_=X("p"),K=c("Variational autoencoders "),f(R.$$.fragment),ne=c(" on the other hand use a different approach. Instead of mapping the input image to a constant latent vector "),f(Q.$$.fragment),h=c(", they map the input "),f(V.$$.fragment),J=c(" to a probability distribution of the latent variable."),_e=B(),f(ae.$$.fragment),Be=B(),O=X("p"),Ne=c("Instead of producing the latent vector "),f(oe.$$.fragment),Ke=c(" directly, the encoder generates two vectors: one containing the mean vector "),f(se.$$.fragment),Qe=c(" and the other containing the standard deviation vector "),f(ie.$$.fragment),Ue=c(". The "),f($e.$$.fragment),Ge=c(" vector is drawn from a standard normal distribution "),f(fe.$$.fragment),Je=c(". The random vector is not part of the computational graph and is treated as a constant during the backpropagation step."),Ie=B(),le=X("p"),Ye=c("Once the encoder has produced the relevant mean and standard deviation vectors, we can create the latent vector "),f(me.$$.fragment),Ze=c("."),Pe=B(),f(pe.$$.fragment),qe=B(),xe=X("p"),et=c("The last remaining puzzle is the loss function that we use to train a VAE, which consists of two parts: the reconstruction loss and a regularizer term."),Ce=B(),f(ue.$$.fragment),Xe=B(),Y=X("p"),tt=c("The reconstruction loss we are going to use is the mean squared error between each pixel of the original image "),f(ge.$$.fragment),rt=c(" and the reconstructed image "),f(he.$$.fragment),nt=c("."),Le=B(),Z=X("p"),at=c("The regularizer on the other hand tries to make the distribution of the latent variables "),f(de.$$.fragment),ot=c(" close to a normal distribution, by minimizing the following expression: "),f(ce.$$.fragment),st=c(", where n is the size of the latent variable vector."),Fe=B(),be=X("div"),je=B(),ye=X("h2"),it=c("Theoretical Background"),He=B(),ke=X("p"),$t=c("Coming soon ..."),Oe=B(),Ee=X("div"),this.h()},l(e){r=L(e,"P",{});var o=P(r);n=w(o,"Variational autoencoders (VAE) are a family of autoencoders that are based on variational Bayesian methods. The mathematical background knowledge that is required to fully understand all intricacies of VAEs is quite extensive and can be intimidating for beginners. Therefore we will introduce VAEs using an intuitive setting first. In a second step we will delve deeper into the theoretical justification of variational autoencoders and provide additional sources for you to study. Fortunately the intuitive introduction is sufficient to implement a VAE from scratch in PyTorch, so you might skip the theoretical part for now and return to it at a later point, once you gained a better mathematical foundation."),o.forEach(a),t=I(e),i=L(e,"DIV",{class:!0}),P(i).forEach(a),D=I(e),E=L(e,"H2",{});var ze=P(E);W=w(ze,"VAE Intuition"),ze.forEach(a),z=I(e),S=L(e,"P",{});var we=P(S);T=w(we,"The autoencoder, that we have discussed in the previous section follow a very simple approach: map an image to a latent vector "),l(A.$$.fragment,we),s=w(we," and reconstruct the original image from from the latent variable."),we.forEach(a),b=I(e),l(k.$$.fragment,e),q=I(e),C=L(e,"P",{});var Se=P(C);H=w(Se,"While this procedure might be good enough for simple compression tasks, when it comes to generating new images, this simple mapping approach might break down. The latent space that is learned might not be smooth or continuous, so when you sample a latent vector that deviates slightly from the samples that the decoder saw during training, you will end up with a nonsence image."),Se.forEach(a),d=I(e),_=L(e,"P",{});var U=P(_);K=w(U,"Variational autoencoders "),l(R.$$.fragment,U),ne=w(U," on the other hand use a different approach. Instead of mapping the input image to a constant latent vector "),l(Q.$$.fragment,U),h=w(U,", they map the input "),l(V.$$.fragment,U),J=w(U," to a probability distribution of the latent variable."),U.forEach(a),_e=I(e),l(ae.$$.fragment,e),Be=I(e),O=L(e,"P",{});var M=P(O);Ne=w(M,"Instead of producing the latent vector "),l(oe.$$.fragment,M),Ke=w(M," directly, the encoder generates two vectors: one containing the mean vector "),l(se.$$.fragment,M),Qe=w(M," and the other containing the standard deviation vector "),l(ie.$$.fragment,M),Ue=w(M,". The "),l($e.$$.fragment,M),Ge=w(M," vector is drawn from a standard normal distribution "),l(fe.$$.fragment,M),Je=w(M,". The random vector is not part of the computational graph and is treated as a constant during the backpropagation step."),M.forEach(a),Ie=I(e),le=L(e,"P",{});var ve=P(le);Ye=w(ve,"Once the encoder has produced the relevant mean and standard deviation vectors, we can create the latent vector "),l(me.$$.fragment,ve),Ze=w(ve,"."),ve.forEach(a),Pe=I(e),l(pe.$$.fragment,e),qe=I(e),xe=L(e,"P",{});var Ae=P(xe);et=w(Ae,"The last remaining puzzle is the loss function that we use to train a VAE, which consists of two parts: the reconstruction loss and a regularizer term."),Ae.forEach(a),Ce=I(e),l(ue.$$.fragment,e),Xe=I(e),Y=L(e,"P",{});var ee=P(Y);tt=w(ee,"The reconstruction loss we are going to use is the mean squared error between each pixel of the original image "),l(ge.$$.fragment,ee),rt=w(ee," and the reconstructed image "),l(he.$$.fragment,ee),nt=w(ee,"."),ee.forEach(a),Le=I(e),Z=L(e,"P",{});var te=P(Z);at=w(te,"The regularizer on the other hand tries to make the distribution of the latent variables "),l(de.$$.fragment,te),ot=w(te," close to a normal distribution, by minimizing the following expression: "),l(ce.$$.fragment,te),st=w(te,", where n is the size of the latent variable vector."),te.forEach(a),Fe=I(e),be=L(e,"DIV",{class:!0}),P(be).forEach(a),je=I(e),ye=L(e,"H2",{});var Ve=P(ye);it=w(Ve,"Theoretical Background"),Ve.forEach(a),He=I(e),ke=L(e,"P",{});var Te=P(ke);$t=w(Te,"Coming soon ..."),Te.forEach(a),Oe=I(e),Ee=L(e,"DIV",{class:!0}),P(Ee).forEach(a),this.h()},h(){re(i,"class","separator"),re(be,"class","separator"),re(Ee,"class","separator")},m(e,o){$(e,r,o),y(r,n),$(e,t,o),$(e,i,o),$(e,D,o),$(e,E,o),y(E,W),$(e,z,o),$(e,S,o),y(S,T),m(A,S,null),y(S,s),$(e,b,o),m(k,e,o),$(e,q,o),$(e,C,o),y(C,H),$(e,d,o),$(e,_,o),y(_,K),m(R,_,null),y(_,ne),m(Q,_,null),y(_,h),m(V,_,null),y(_,J),$(e,_e,o),m(ae,e,o),$(e,Be,o),$(e,O,o),y(O,Ne),m(oe,O,null),y(O,Ke),m(se,O,null),y(O,Qe),m(ie,O,null),y(O,Ue),m($e,O,null),y(O,Ge),m(fe,O,null),y(O,Je),$(e,Ie,o),$(e,le,o),y(le,Ye),m(me,le,null),y(le,Ze),$(e,Pe,o),m(pe,e,o),$(e,qe,o),$(e,xe,o),y(xe,et),$(e,Ce,o),m(ue,e,o),$(e,Xe,o),$(e,Y,o),y(Y,tt),m(ge,Y,null),y(Y,rt),m(he,Y,null),y(Y,nt),$(e,Le,o),$(e,Z,o),y(Z,at),m(de,Z,null),y(Z,ot),m(ce,Z,null),y(Z,st),$(e,Fe,o),$(e,be,o),$(e,je,o),$(e,ye,o),y(ye,it),$(e,He,o),$(e,ke,o),y(ke,$t),$(e,Oe,o),$(e,Ee,o),Re=!0},p(e,o){const ze={};o&2&&(ze.$$scope={dirty:o,ctx:e}),A.$set(ze);const we={};o&2&&(we.$$scope={dirty:o,ctx:e}),k.$set(we);const Se={};o&2&&(Se.$$scope={dirty:o,ctx:e}),Q.$set(Se);const U={};o&2&&(U.$$scope={dirty:o,ctx:e}),V.$set(U);const M={};o&2&&(M.$$scope={dirty:o,ctx:e}),ae.$set(M);const ve={};o&2&&(ve.$$scope={dirty:o,ctx:e}),oe.$set(ve);const Ae={};o&2&&(Ae.$$scope={dirty:o,ctx:e}),se.$set(Ae);const ee={};o&2&&(ee.$$scope={dirty:o,ctx:e}),ie.$set(ee);const te={};o&2&&(te.$$scope={dirty:o,ctx:e}),$e.$set(te);const Ve={};o&2&&(Ve.$$scope={dirty:o,ctx:e}),fe.$set(Ve);const Te={};o&2&&(Te.$$scope={dirty:o,ctx:e}),me.$set(Te);const ft={};o&2&&(ft.$$scope={dirty:o,ctx:e}),pe.$set(ft);const lt={};o&2&&(lt.$$scope={dirty:o,ctx:e}),ue.$set(lt);const mt={};o&2&&(mt.$$scope={dirty:o,ctx:e}),ge.$set(mt);const pt={};o&2&&(pt.$$scope={dirty:o,ctx:e}),he.$set(pt);const ut={};o&2&&(ut.$$scope={dirty:o,ctx:e}),de.$set(ut);const gt={};o&2&&(gt.$$scope={dirty:o,ctx:e}),ce.$set(gt)},i(e){Re||(p(A.$$.fragment,e),p(k.$$.fragment,e),p(R.$$.fragment,e),p(Q.$$.fragment,e),p(V.$$.fragment,e),p(ae.$$.fragment,e),p(oe.$$.fragment,e),p(se.$$.fragment,e),p(ie.$$.fragment,e),p($e.$$.fragment,e),p(fe.$$.fragment,e),p(me.$$.fragment,e),p(pe.$$.fragment,e),p(ue.$$.fragment,e),p(ge.$$.fragment,e),p(he.$$.fragment,e),p(de.$$.fragment,e),p(ce.$$.fragment,e),Re=!0)},o(e){u(A.$$.fragment,e),u(k.$$.fragment,e),u(R.$$.fragment,e),u(Q.$$.fragment,e),u(V.$$.fragment,e),u(ae.$$.fragment,e),u(oe.$$.fragment,e),u(se.$$.fragment,e),u(ie.$$.fragment,e),u($e.$$.fragment,e),u(fe.$$.fragment,e),u(me.$$.fragment,e),u(pe.$$.fragment,e),u(ue.$$.fragment,e),u(ge.$$.fragment,e),u(he.$$.fragment,e),u(de.$$.fragment,e),u(ce.$$.fragment,e),Re=!1},d(e){e&&a(r),e&&a(t),e&&a(i),e&&a(D),e&&a(E),e&&a(z),e&&a(S),g(A),e&&a(b),g(k,e),e&&a(q),e&&a(C),e&&a(d),e&&a(_),g(R),g(Q),g(V),e&&a(_e),g(ae,e),e&&a(Be),e&&a(O),g(oe),g(se),g(ie),g($e),g(fe),e&&a(Ie),e&&a(le),g(me),e&&a(Pe),g(pe,e),e&&a(qe),e&&a(xe),e&&a(Ce),g(ue,e),e&&a(Xe),e&&a(Y),g(ge),g(he),e&&a(Le),e&&a(Z),g(de),g(ce),e&&a(Fe),e&&a(be),e&&a(je),e&&a(ye),e&&a(He),e&&a(ke),e&&a(Oe),e&&a(Ee)}}}function jt(v){let r,n,t,i,D,E,W,z,S,T,A;return z=new _t({props:{$$slots:{default:[Ft]},$$scope:{ctx:v}}}),T=new xt({props:{references:v[0]}}),{c(){r=X("meta"),n=B(),t=X("h1"),i=c("Variational Autoencoders"),D=B(),E=X("div"),W=B(),f(z.$$.fragment),S=B(),f(T.$$.fragment),this.h()},l(s){const b=vt("svelte-f8hj3n",document.head);r=L(b,"META",{name:!0,content:!0}),b.forEach(a),n=I(s),t=L(s,"H1",{});var k=P(t);i=w(k,"Variational Autoencoders"),k.forEach(a),D=I(s),E=L(s,"DIV",{class:!0}),P(E).forEach(a),W=I(s),l(z.$$.fragment,s),S=I(s),l(T.$$.fragment,s),this.h()},h(){document.title="World4AI | Deep Learning | Variational Autoencoder ",re(r,"name","description"),re(r,"content","Unlike a regular autoencoder, a variational autoencoder (VAE) maps an input image to a latent variable distribution. We can use that distribution to sample new images."),re(E,"class","separator")},m(s,b){y(document.head,r),$(s,n,b),$(s,t,b),y(t,i),$(s,D,b),$(s,E,b),$(s,W,b),m(z,s,b),$(s,S,b),m(T,s,b),A=!0},p(s,[b]){const k={};b&2&&(k.$$scope={dirty:b,ctx:s}),z.$set(k)},i(s){A||(p(z.$$.fragment,s),p(T.$$.fragment,s),A=!0)},o(s){u(z.$$.fragment,s),u(T.$$.fragment,s),A=!1},d(s){a(r),s&&a(n),s&&a(t),s&&a(D),s&&a(E),s&&a(W),g(z,s),s&&a(S),g(T,s)}}}const x=40;function Ht(v){return[[{author:"Diederik P. Kingma, Max Welling",title:"Auto-Encoding Variational Bayes",year:"2013"}]]}class Jt extends dt{constructor(r){super(),ct(this,r,Ht,jt,wt,{})}}export{Jt as default};
