import{S as be,i as ve,s as ye,k as z,a as y,y as _,W as xe,l as A,h as p,c as x,z as g,n as fe,N as F,b as u,A as w,g as h,d,B as b,q as P,m as H,r as C,C as G}from"../chunks/index.4d92b023.js";import{C as Ee}from"../chunks/Container.b0705c7b.js";import{L as I}from"../chunks/Latex.e0b308c0.js";import{P as ge,T as we}from"../chunks/Ticks.45eca5c5.js";import{X as he,Y as de}from"../chunks/YLabel.182e66a3.js";import{P as V}from"../chunks/Path.7e6df014.js";import{L as le}from"../chunks/Legend.de38c007.js";import{T as Te,a as qe,b as Se,R as Z,H as me,D as W}from"../chunks/HeaderEntry.2b6e8f51.js";function Pe(o){let t;return{c(){t=P("Loss Function")},l(r){t=C(r,"Loss Function")},m(r,e){u(r,t,e)},d(r){r&&p(t)}}}function Ce(o){let t;return{c(){t=P("True Label")},l(r){t=C(r,"True Label")},m(r,e){u(r,t,e)},d(r){r&&p(t)}}}function ke(o){let t;return{c(){t=P("Loss")},l(r){t=C(r,"Loss")},m(r,e){u(r,t,e)},d(r){r&&p(t)}}}function Le(o){let t,r,e,s,a,i;return t=new me({props:{$$slots:{default:[Pe]},$$scope:{ctx:o}}}),e=new me({props:{$$slots:{default:[Ce]},$$scope:{ctx:o}}}),a=new me({props:{$$slots:{default:[ke]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment),r=y(),_(e.$$.fragment),s=y(),_(a.$$.fragment)},l($){g(t.$$.fragment,$),r=x($),g(e.$$.fragment,$),s=x($),g(a.$$.fragment,$)},m($,l){w(t,$,l),u($,r,l),w(e,$,l),u($,s,l),w(a,$,l),i=!0},p($,l){const m={};l&1024&&(m.$$scope={dirty:l,ctx:$}),t.$set(m);const v={};l&1024&&(v.$$scope={dirty:l,ctx:$}),e.$set(v);const c={};l&1024&&(c.$$scope={dirty:l,ctx:$}),a.$set(c)},i($){i||(h(t.$$.fragment,$),h(e.$$.fragment,$),h(a.$$.fragment,$),i=!0)},o($){d(t.$$.fragment,$),d(e.$$.fragment,$),d(a.$$.fragment,$),i=!1},d($){b(t,$),$&&p(r),b(e,$),$&&p(s),b(a,$)}}}function Me(o){let t,r;return t=new Z({props:{$$slots:{default:[Le]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment)},l(e){g(t.$$.fragment,e)},m(e,s){w(t,e,s),r=!0},p(e,s){const a={};s&1024&&(a.$$scope={dirty:s,ctx:e}),t.$set(a)},i(e){r||(h(t.$$.fragment,e),r=!0)},o(e){d(t.$$.fragment,e),r=!1},d(e){b(t,e)}}}function De(o){let t=String.raw`(y-\hat{y})^2`+"",r;return{c(){r=P(t)},l(e){r=C(e,t)},m(e,s){u(e,r,s)},p:G,d(e){e&&p(r)}}}function Be(o){let t,r,e;return r=new I({props:{$$slots:{default:[De]},$$scope:{ctx:o}}}),{c(){t=P("MSE: "),_(r.$$.fragment)},l(s){t=C(s,"MSE: "),g(r.$$.fragment,s)},m(s,a){u(s,t,a),w(r,s,a),e=!0},p(s,a){const i={};a&1024&&(i.$$scope={dirty:a,ctx:s}),r.$set(i)},i(s){e||(h(r.$$.fragment,s),e=!0)},o(s){d(r.$$.fragment,s),e=!1},d(s){s&&p(t),b(r,s)}}}function Ie(o){let t;return{c(){t=P("0")},l(r){t=C(r,"0")},m(r,e){u(r,t,e)},d(r){r&&p(t)}}}function We(o){let t,r;return t=new I({props:{$$slots:{default:[Ie]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment)},l(e){g(t.$$.fragment,e)},m(e,s){w(t,e,s),r=!0},p(e,s){const a={};s&1024&&(a.$$scope={dirty:s,ctx:e}),t.$set(a)},i(e){r||(h(t.$$.fragment,e),r=!0)},o(e){d(t.$$.fragment,e),r=!1},d(e){b(t,e)}}}function ze(o){let t=String.raw`(0-\hat{y})^2`+"",r;return{c(){r=P(t)},l(e){r=C(e,t)},m(e,s){u(e,r,s)},p:G,d(e){e&&p(r)}}}function Ae(o){let t,r;return t=new I({props:{$$slots:{default:[ze]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment)},l(e){g(t.$$.fragment,e)},m(e,s){w(t,e,s),r=!0},p(e,s){const a={};s&1024&&(a.$$scope={dirty:s,ctx:e}),t.$set(a)},i(e){r||(h(t.$$.fragment,e),r=!0)},o(e){d(t.$$.fragment,e),r=!1},d(e){b(t,e)}}}function Ge(o){let t,r,e,s,a,i;return t=new W({props:{$$slots:{default:[Be]},$$scope:{ctx:o}}}),e=new W({props:{$$slots:{default:[We]},$$scope:{ctx:o}}}),a=new W({props:{$$slots:{default:[Ae]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment),r=y(),_(e.$$.fragment),s=y(),_(a.$$.fragment)},l($){g(t.$$.fragment,$),r=x($),g(e.$$.fragment,$),s=x($),g(a.$$.fragment,$)},m($,l){w(t,$,l),u($,r,l),w(e,$,l),u($,s,l),w(a,$,l),i=!0},p($,l){const m={};l&1024&&(m.$$scope={dirty:l,ctx:$}),t.$set(m);const v={};l&1024&&(v.$$scope={dirty:l,ctx:$}),e.$set(v);const c={};l&1024&&(c.$$scope={dirty:l,ctx:$}),a.$set(c)},i($){i||(h(t.$$.fragment,$),h(e.$$.fragment,$),h(a.$$.fragment,$),i=!0)},o($){d(t.$$.fragment,$),d(e.$$.fragment,$),d(a.$$.fragment,$),i=!1},d($){b(t,$),$&&p(r),b(e,$),$&&p(s),b(a,$)}}}function He(o){let t=String.raw`(y-\hat{y})^2`+"",r;return{c(){r=P(t)},l(e){r=C(e,t)},m(e,s){u(e,r,s)},p:G,d(e){e&&p(r)}}}function Fe(o){let t,r,e;return r=new I({props:{$$slots:{default:[He]},$$scope:{ctx:o}}}),{c(){t=P("MSE: "),_(r.$$.fragment)},l(s){t=C(s,"MSE: "),g(r.$$.fragment,s)},m(s,a){u(s,t,a),w(r,s,a),e=!0},p(s,a){const i={};a&1024&&(i.$$scope={dirty:a,ctx:s}),r.$set(i)},i(s){e||(h(r.$$.fragment,s),e=!0)},o(s){d(r.$$.fragment,s),e=!1},d(s){s&&p(t),b(r,s)}}}function Oe(o){let t;return{c(){t=P("1")},l(r){t=C(r,"1")},m(r,e){u(r,t,e)},d(r){r&&p(t)}}}function Re(o){let t,r;return t=new I({props:{$$slots:{default:[Oe]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment)},l(e){g(t.$$.fragment,e)},m(e,s){w(t,e,s),r=!0},p(e,s){const a={};s&1024&&(a.$$scope={dirty:s,ctx:e}),t.$set(a)},i(e){r||(h(t.$$.fragment,e),r=!0)},o(e){d(t.$$.fragment,e),r=!1},d(e){b(t,e)}}}function Ve(o){let t=String.raw`(1-\hat{y})^2`+"",r;return{c(){r=P(t)},l(e){r=C(e,t)},m(e,s){u(e,r,s)},p:G,d(e){e&&p(r)}}}function Xe(o){let t,r;return t=new I({props:{$$slots:{default:[Ve]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment)},l(e){g(t.$$.fragment,e)},m(e,s){w(t,e,s),r=!0},p(e,s){const a={};s&1024&&(a.$$scope={dirty:s,ctx:e}),t.$set(a)},i(e){r||(h(t.$$.fragment,e),r=!0)},o(e){d(t.$$.fragment,e),r=!1},d(e){b(t,e)}}}function Ye(o){let t,r,e,s,a,i;return t=new W({props:{$$slots:{default:[Fe]},$$scope:{ctx:o}}}),e=new W({props:{$$slots:{default:[Re]},$$scope:{ctx:o}}}),a=new W({props:{$$slots:{default:[Xe]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment),r=y(),_(e.$$.fragment),s=y(),_(a.$$.fragment)},l($){g(t.$$.fragment,$),r=x($),g(e.$$.fragment,$),s=x($),g(a.$$.fragment,$)},m($,l){w(t,$,l),u($,r,l),w(e,$,l),u($,s,l),w(a,$,l),i=!0},p($,l){const m={};l&1024&&(m.$$scope={dirty:l,ctx:$}),t.$set(m);const v={};l&1024&&(v.$$scope={dirty:l,ctx:$}),e.$set(v);const c={};l&1024&&(c.$$scope={dirty:l,ctx:$}),a.$set(c)},i($){i||(h(t.$$.fragment,$),h(e.$$.fragment,$),h(a.$$.fragment,$),i=!0)},o($){d(t.$$.fragment,$),d(e.$$.fragment,$),d(a.$$.fragment,$),i=!1},d($){b(t,$),$&&p(r),b(e,$),$&&p(s),b(a,$)}}}function Ne(o){let t=String.raw`-\Big[y \log (\hat{y}) + (1 - y) \log ( 1 - \hat{y})\Big]`+"",r;return{c(){r=P(t)},l(e){r=C(e,t)},m(e,s){u(e,r,s)},p:G,d(e){e&&p(r)}}}function je(o){let t,r,e;return r=new I({props:{$$slots:{default:[Ne]},$$scope:{ctx:o}}}),{c(){t=P("CE: "),_(r.$$.fragment)},l(s){t=C(s,"CE: "),g(r.$$.fragment,s)},m(s,a){u(s,t,a),w(r,s,a),e=!0},p(s,a){const i={};a&1024&&(i.$$scope={dirty:a,ctx:s}),r.$set(i)},i(s){e||(h(r.$$.fragment,s),e=!0)},o(s){d(r.$$.fragment,s),e=!1},d(s){s&&p(t),b(r,s)}}}function Je(o){let t;return{c(){t=P("0")},l(r){t=C(r,"0")},m(r,e){u(r,t,e)},d(r){r&&p(t)}}}function Ke(o){let t,r;return t=new I({props:{$$slots:{default:[Je]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment)},l(e){g(t.$$.fragment,e)},m(e,s){w(t,e,s),r=!0},p(e,s){const a={};s&1024&&(a.$$scope={dirty:s,ctx:e}),t.$set(a)},i(e){r||(h(t.$$.fragment,e),r=!0)},o(e){d(t.$$.fragment,e),r=!1},d(e){b(t,e)}}}function Qe(o){let t=String.raw`-\log ( 1 - \hat{y})`+"",r;return{c(){r=P(t)},l(e){r=C(e,t)},m(e,s){u(e,r,s)},p:G,d(e){e&&p(r)}}}function Ue(o){let t,r;return t=new I({props:{$$slots:{default:[Qe]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment)},l(e){g(t.$$.fragment,e)},m(e,s){w(t,e,s),r=!0},p(e,s){const a={};s&1024&&(a.$$scope={dirty:s,ctx:e}),t.$set(a)},i(e){r||(h(t.$$.fragment,e),r=!0)},o(e){d(t.$$.fragment,e),r=!1},d(e){b(t,e)}}}function Ze(o){let t,r,e,s,a,i;return t=new W({props:{$$slots:{default:[je]},$$scope:{ctx:o}}}),e=new W({props:{$$slots:{default:[Ke]},$$scope:{ctx:o}}}),a=new W({props:{$$slots:{default:[Ue]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment),r=y(),_(e.$$.fragment),s=y(),_(a.$$.fragment)},l($){g(t.$$.fragment,$),r=x($),g(e.$$.fragment,$),s=x($),g(a.$$.fragment,$)},m($,l){w(t,$,l),u($,r,l),w(e,$,l),u($,s,l),w(a,$,l),i=!0},p($,l){const m={};l&1024&&(m.$$scope={dirty:l,ctx:$}),t.$set(m);const v={};l&1024&&(v.$$scope={dirty:l,ctx:$}),e.$set(v);const c={};l&1024&&(c.$$scope={dirty:l,ctx:$}),a.$set(c)},i($){i||(h(t.$$.fragment,$),h(e.$$.fragment,$),h(a.$$.fragment,$),i=!0)},o($){d(t.$$.fragment,$),d(e.$$.fragment,$),d(a.$$.fragment,$),i=!1},d($){b(t,$),$&&p(r),b(e,$),$&&p(s),b(a,$)}}}function et(o){let t=String.raw`-\Big[y \log (\hat{y}) + (1 - y) \log ( 1 - \hat{y})\Big]`+"",r;return{c(){r=P(t)},l(e){r=C(e,t)},m(e,s){u(e,r,s)},p:G,d(e){e&&p(r)}}}function tt(o){let t,r,e;return r=new I({props:{$$slots:{default:[et]},$$scope:{ctx:o}}}),{c(){t=P("CE: "),_(r.$$.fragment)},l(s){t=C(s,"CE: "),g(r.$$.fragment,s)},m(s,a){u(s,t,a),w(r,s,a),e=!0},p(s,a){const i={};a&1024&&(i.$$scope={dirty:a,ctx:s}),r.$set(i)},i(s){e||(h(r.$$.fragment,s),e=!0)},o(s){d(r.$$.fragment,s),e=!1},d(s){s&&p(t),b(r,s)}}}function rt(o){let t;return{c(){t=P("1")},l(r){t=C(r,"1")},m(r,e){u(r,t,e)},d(r){r&&p(t)}}}function $t(o){let t,r;return t=new I({props:{$$slots:{default:[rt]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment)},l(e){g(t.$$.fragment,e)},m(e,s){w(t,e,s),r=!0},p(e,s){const a={};s&1024&&(a.$$scope={dirty:s,ctx:e}),t.$set(a)},i(e){r||(h(t.$$.fragment,e),r=!0)},o(e){d(t.$$.fragment,e),r=!1},d(e){b(t,e)}}}function st(o){let t=String.raw`-\log ( \hat{y})`+"",r;return{c(){r=P(t)},l(e){r=C(e,t)},m(e,s){u(e,r,s)},p:G,d(e){e&&p(r)}}}function at(o){let t,r;return t=new I({props:{$$slots:{default:[st]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment)},l(e){g(t.$$.fragment,e)},m(e,s){w(t,e,s),r=!0},p(e,s){const a={};s&1024&&(a.$$scope={dirty:s,ctx:e}),t.$set(a)},i(e){r||(h(t.$$.fragment,e),r=!0)},o(e){d(t.$$.fragment,e),r=!1},d(e){b(t,e)}}}function nt(o){let t,r,e,s,a,i;return t=new W({props:{$$slots:{default:[tt]},$$scope:{ctx:o}}}),e=new W({props:{$$slots:{default:[$t]},$$scope:{ctx:o}}}),a=new W({props:{$$slots:{default:[at]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment),r=y(),_(e.$$.fragment),s=y(),_(a.$$.fragment)},l($){g(t.$$.fragment,$),r=x($),g(e.$$.fragment,$),s=x($),g(a.$$.fragment,$)},m($,l){w(t,$,l),u($,r,l),w(e,$,l),u($,s,l),w(a,$,l),i=!0},p($,l){const m={};l&1024&&(m.$$scope={dirty:l,ctx:$}),t.$set(m);const v={};l&1024&&(v.$$scope={dirty:l,ctx:$}),e.$set(v);const c={};l&1024&&(c.$$scope={dirty:l,ctx:$}),a.$set(c)},i($){i||(h(t.$$.fragment,$),h(e.$$.fragment,$),h(a.$$.fragment,$),i=!0)},o($){d(t.$$.fragment,$),d(e.$$.fragment,$),d(a.$$.fragment,$),i=!1},d($){b(t,$),$&&p(r),b(e,$),$&&p(s),b(a,$)}}}function ft(o){let t,r,e,s,a,i,$,l;return t=new Z({props:{$$slots:{default:[Ge]},$$scope:{ctx:o}}}),e=new Z({props:{$$slots:{default:[Ye]},$$scope:{ctx:o}}}),a=new Z({props:{$$slots:{default:[Ze]},$$scope:{ctx:o}}}),$=new Z({props:{$$slots:{default:[nt]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment),r=y(),_(e.$$.fragment),s=y(),_(a.$$.fragment),i=y(),_($.$$.fragment)},l(m){g(t.$$.fragment,m),r=x(m),g(e.$$.fragment,m),s=x(m),g(a.$$.fragment,m),i=x(m),g($.$$.fragment,m)},m(m,v){w(t,m,v),u(m,r,v),w(e,m,v),u(m,s,v),w(a,m,v),u(m,i,v),w($,m,v),l=!0},p(m,v){const c={};v&1024&&(c.$$scope={dirty:v,ctx:m}),t.$set(c);const S={};v&1024&&(S.$$scope={dirty:v,ctx:m}),e.$set(S);const q={};v&1024&&(q.$$scope={dirty:v,ctx:m}),a.$set(q);const k={};v&1024&&(k.$$scope={dirty:v,ctx:m}),$.$set(k)},i(m){l||(h(t.$$.fragment,m),h(e.$$.fragment,m),h(a.$$.fragment,m),h($.$$.fragment,m),l=!0)},o(m){d(t.$$.fragment,m),d(e.$$.fragment,m),d(a.$$.fragment,m),d($.$$.fragment,m),l=!1},d(m){b(t,m),m&&p(r),b(e,m),m&&p(s),b(a,m),m&&p(i),b($,m)}}}function lt(o){let t,r,e,s;return t=new qe({props:{$$slots:{default:[Me]},$$scope:{ctx:o}}}),e=new Se({props:{$$slots:{default:[ft]},$$scope:{ctx:o}}}),{c(){_(t.$$.fragment),r=y(),_(e.$$.fragment)},l(a){g(t.$$.fragment,a),r=x(a),g(e.$$.fragment,a)},m(a,i){w(t,a,i),u(a,r,i),w(e,a,i),s=!0},p(a,i){const $={};i&1024&&($.$$scope={dirty:i,ctx:a}),t.$set($);const l={};i&1024&&(l.$$scope={dirty:i,ctx:a}),e.$set(l)},i(a){s||(h(t.$$.fragment,a),h(e.$$.fragment,a),s=!0)},o(a){d(t.$$.fragment,a),d(e.$$.fragment,a),s=!1},d(a){b(t,a),a&&p(r),b(e,a)}}}function ot(o){let t=String.raw`\hat{y}`+"",r;return{c(){r=P(t)},l(e){r=C(e,t)},m(e,s){u(e,r,s)},p:G,d(e){e&&p(r)}}}function pt(o){let t,r,e,s,a,i,$,l,m,v,c,S,q,k,L,D,M,B;return t=new we({props:{xTicks:[0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1],yTicks:[0,1,2,3],xOffset:-15,yOffset:15}}),e=new he({props:{text:"Predicted Probability",fontSize:15}}),a=new de({props:{text:"Error",fontSize:15}}),$=new V({props:{data:o[0][0],color:"var(--main-color-1)"}}),m=new V({props:{data:o[0][1],color:"var(--main-color-1)"}}),c=new V({props:{data:o[0][2],color:"var(--main-color-2)"}}),q=new V({props:{data:o[0][3],color:"var(--main-color-2)"}}),L=new le({props:{coordinates:{x:.3,y:2.8},legendColor:"var(--main-color-2)",text:"Cross Entropy"}}),M=new le({props:{coordinates:{x:.3,y:2.5},legendColor:"var(--main-color-1)",text:"Mean Squared Error"}}),{c(){_(t.$$.fragment),r=y(),_(e.$$.fragment),s=y(),_(a.$$.fragment),i=y(),_($.$$.fragment),l=y(),_(m.$$.fragment),v=y(),_(c.$$.fragment),S=y(),_(q.$$.fragment),k=y(),_(L.$$.fragment),D=y(),_(M.$$.fragment)},l(n){g(t.$$.fragment,n),r=x(n),g(e.$$.fragment,n),s=x(n),g(a.$$.fragment,n),i=x(n),g($.$$.fragment,n),l=x(n),g(m.$$.fragment,n),v=x(n),g(c.$$.fragment,n),S=x(n),g(q.$$.fragment,n),k=x(n),g(L.$$.fragment,n),D=x(n),g(M.$$.fragment,n)},m(n,E){w(t,n,E),u(n,r,E),w(e,n,E),u(n,s,E),w(a,n,E),u(n,i,E),w($,n,E),u(n,l,E),w(m,n,E),u(n,v,E),w(c,n,E),u(n,S,E),w(q,n,E),u(n,k,E),w(L,n,E),u(n,D,E),w(M,n,E),B=!0},p:G,i(n){B||(h(t.$$.fragment,n),h(e.$$.fragment,n),h(a.$$.fragment,n),h($.$$.fragment,n),h(m.$$.fragment,n),h(c.$$.fragment,n),h(q.$$.fragment,n),h(L.$$.fragment,n),h(M.$$.fragment,n),B=!0)},o(n){d(t.$$.fragment,n),d(e.$$.fragment,n),d(a.$$.fragment,n),d($.$$.fragment,n),d(m.$$.fragment,n),d(c.$$.fragment,n),d(q.$$.fragment,n),d(L.$$.fragment,n),d(M.$$.fragment,n),B=!1},d(n){b(t,n),n&&p(r),b(e,n),n&&p(s),b(a,n),n&&p(i),b($,n),n&&p(l),b(m,n),n&&p(v),b(c,n),n&&p(S),b(q,n),n&&p(k),b(L,n),n&&p(D),b(M,n)}}}function it(o){let t,r,e,s,a,i,$,l,m,v,c,S,q,k,L,D,M,B;return t=new we({props:{xTicks:[0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1],yTicks:[-10,-8,-6,-4,-2,0,2,4,6,8,10],xOffset:-15,yOffset:15}}),e=new he({props:{text:"Predicted Probability",fontSize:15}}),a=new de({props:{text:"Derivative",fontSize:15}}),$=new V({props:{data:o[1][0],color:"var(--main-color-1)"}}),m=new V({props:{data:o[1][1],color:"var(--main-color-1)"}}),c=new V({props:{data:o[1][2],color:"var(--main-color-2)"}}),q=new V({props:{data:o[1][3],color:"var(--main-color-2)"}}),L=new le({props:{coordinates:{x:.3,y:8},legendColor:"var(--main-color-2)",text:"Cross Entropy"}}),M=new le({props:{coordinates:{x:.3,y:6},legendColor:"var(--main-color-1)",text:"Mean Squared Error"}}),{c(){_(t.$$.fragment),r=y(),_(e.$$.fragment),s=y(),_(a.$$.fragment),i=y(),_($.$$.fragment),l=y(),_(m.$$.fragment),v=y(),_(c.$$.fragment),S=y(),_(q.$$.fragment),k=y(),_(L.$$.fragment),D=y(),_(M.$$.fragment)},l(n){g(t.$$.fragment,n),r=x(n),g(e.$$.fragment,n),s=x(n),g(a.$$.fragment,n),i=x(n),g($.$$.fragment,n),l=x(n),g(m.$$.fragment,n),v=x(n),g(c.$$.fragment,n),S=x(n),g(q.$$.fragment,n),k=x(n),g(L.$$.fragment,n),D=x(n),g(M.$$.fragment,n)},m(n,E){w(t,n,E),u(n,r,E),w(e,n,E),u(n,s,E),w(a,n,E),u(n,i,E),w($,n,E),u(n,l,E),w(m,n,E),u(n,v,E),w(c,n,E),u(n,S,E),w(q,n,E),u(n,k,E),w(L,n,E),u(n,D,E),w(M,n,E),B=!0},p:G,i(n){B||(h(t.$$.fragment,n),h(e.$$.fragment,n),h(a.$$.fragment,n),h($.$$.fragment,n),h(m.$$.fragment,n),h(c.$$.fragment,n),h(q.$$.fragment,n),h(L.$$.fragment,n),h(M.$$.fragment,n),B=!0)},o(n){d(t.$$.fragment,n),d(e.$$.fragment,n),d(a.$$.fragment,n),d($.$$.fragment,n),d(m.$$.fragment,n),d(c.$$.fragment,n),d(q.$$.fragment,n),d(L.$$.fragment,n),d(M.$$.fragment,n),B=!1},d(n){b(t,n),n&&p(r),b(e,n),n&&p(s),b(a,n),n&&p(i),b($,n),n&&p(l),b(m,n),n&&p(v),b(c,n),n&&p(S),b(q,n),n&&p(k),b(L,n),n&&p(D),b(M,n)}}}function mt(o){let t,r,e,s,a,i,$,l,m,v,c,S,q,k,L,D,M,B,n,E,ee,O,te,Y,oe,re,N,pe,$e,R,se,j,ie,ae,J,ne;return S=new Te({props:{$$slots:{default:[lt]},$$scope:{ctx:o}}}),n=new I({props:{$$slots:{default:[ot]},$$scope:{ctx:o}}}),O=new ge({props:{width:500,height:250,maxWidth:800,domain:[0,1],range:[0,3],$$slots:{default:[pt]},$$scope:{ctx:o}}}),R=new ge({props:{width:500,height:250,maxWidth:800,domain:[0,1],range:[-10,10],$$slots:{default:[it]},$$scope:{ctx:o}}}),{c(){t=z("h1"),r=P("Cross-Entropy vs Mean Squared Error"),e=y(),s=z("div"),a=y(),i=z("p"),$=P(`The cross-entropy is almost exclusively used as the loss function for
    classification tasks, but it is not obvious why we can not use the mean
    squared error. Actually we can, but as we will see shortly, the
    cross-entropy is a more convenient measure of loss for classification tasks.`),l=y(),m=z("p"),v=P(`For this discusson we will deal with a single sample and distinquish between
    different cases.`),c=y(),_(S.$$.fragment),q=y(),k=z("p"),L=P(`If the label equals to 0 both losses increase as the predicted probability
    grows. If the true label is 1 on the other hand the error decreases when the
    predicted probability grows.`),D=y(),M=z("p"),B=P(`Below we plot the mean squared error and the cross-entropy based on the
    predicted probability `),_(n.$$.fragment),E=P(`. The red plot
    depicts the mean squared error, while the blue plot depicts the
    cross-entropy. There are two plots for each of the losses, one for each
    value of the target.`),ee=y(),_(O.$$.fragment),te=y(),Y=z("p"),oe=P(`The mean squared error and the cross-entropy start at the same position, but
    the difference in errors starts to grow as the predicted probability starts
    to deviate from the true label. The cross-entropy punishes
    misclassifications with a much higher loss, than the mean squared error.
    When we deal with probabilities the difference between the label and the
    predicted probability can not be larger than 1. That means that the mean
    squared error also can not grow beyond 1. The logarithm on the other hand
    literally explodes when the value starts approaching 0.`),re=y(),N=z("p"),pe=P(`This behaviour can also be observed when we draw the predicted probability
    against the derivative of the loss function. While the derivatives of the
    mean squared error are linear, the cross-entropy derivatives grow
    exponentially when the quality of predictions deteriorates.`),$e=y(),_(R.$$.fragment),se=y(),j=z("p"),ie=P(`The exponential growth of derivative of the cross-entropy loss implies, that
    the gradient descent algorithm will take much larger steps compared to the
    mean squared error, when the classification predictions are way off, thereby
    converging at a higher rate.`),ae=y(),J=z("div"),this.h()},l(f){t=A(f,"H1",{});var T=H(t);r=C(T,"Cross-Entropy vs Mean Squared Error"),T.forEach(p),e=x(f),s=A(f,"DIV",{class:!0}),H(s).forEach(p),a=x(f),i=A(f,"P",{});var K=H(i);$=C(K,`The cross-entropy is almost exclusively used as the loss function for
    classification tasks, but it is not obvious why we can not use the mean
    squared error. Actually we can, but as we will see shortly, the
    cross-entropy is a more convenient measure of loss for classification tasks.`),K.forEach(p),l=x(f),m=A(f,"P",{});var Q=H(m);v=C(Q,`For this discusson we will deal with a single sample and distinquish between
    different cases.`),Q.forEach(p),c=x(f),g(S.$$.fragment,f),q=x(f),k=A(f,"P",{});var U=H(k);L=C(U,`If the label equals to 0 both losses increase as the predicted probability
    grows. If the true label is 1 on the other hand the error decreases when the
    predicted probability grows.`),U.forEach(p),D=x(f),M=A(f,"P",{});var X=H(M);B=C(X,`Below we plot the mean squared error and the cross-entropy based on the
    predicted probability `),g(n.$$.fragment,X),E=C(X,`. The red plot
    depicts the mean squared error, while the blue plot depicts the
    cross-entropy. There are two plots for each of the losses, one for each
    value of the target.`),X.forEach(p),ee=x(f),g(O.$$.fragment,f),te=x(f),Y=A(f,"P",{});var ue=H(Y);oe=C(ue,`The mean squared error and the cross-entropy start at the same position, but
    the difference in errors starts to grow as the predicted probability starts
    to deviate from the true label. The cross-entropy punishes
    misclassifications with a much higher loss, than the mean squared error.
    When we deal with probabilities the difference between the label and the
    predicted probability can not be larger than 1. That means that the mean
    squared error also can not grow beyond 1. The logarithm on the other hand
    literally explodes when the value starts approaching 0.`),ue.forEach(p),re=x(f),N=A(f,"P",{});var ce=H(N);pe=C(ce,`This behaviour can also be observed when we draw the predicted probability
    against the derivative of the loss function. While the derivatives of the
    mean squared error are linear, the cross-entropy derivatives grow
    exponentially when the quality of predictions deteriorates.`),ce.forEach(p),$e=x(f),g(R.$$.fragment,f),se=x(f),j=A(f,"P",{});var _e=H(j);ie=C(_e,`The exponential growth of derivative of the cross-entropy loss implies, that
    the gradient descent algorithm will take much larger steps compared to the
    mean squared error, when the classification predictions are way off, thereby
    converging at a higher rate.`),_e.forEach(p),ae=x(f),J=A(f,"DIV",{class:!0}),H(J).forEach(p),this.h()},h(){fe(s,"class","separator"),fe(J,"class","separator")},m(f,T){u(f,t,T),F(t,r),u(f,e,T),u(f,s,T),u(f,a,T),u(f,i,T),F(i,$),u(f,l,T),u(f,m,T),F(m,v),u(f,c,T),w(S,f,T),u(f,q,T),u(f,k,T),F(k,L),u(f,D,T),u(f,M,T),F(M,B),w(n,M,null),F(M,E),u(f,ee,T),w(O,f,T),u(f,te,T),u(f,Y,T),F(Y,oe),u(f,re,T),u(f,N,T),F(N,pe),u(f,$e,T),w(R,f,T),u(f,se,T),u(f,j,T),F(j,ie),u(f,ae,T),u(f,J,T),ne=!0},p(f,T){const K={};T&1024&&(K.$$scope={dirty:T,ctx:f}),S.$set(K);const Q={};T&1024&&(Q.$$scope={dirty:T,ctx:f}),n.$set(Q);const U={};T&1024&&(U.$$scope={dirty:T,ctx:f}),O.$set(U);const X={};T&1024&&(X.$$scope={dirty:T,ctx:f}),R.$set(X)},i(f){ne||(h(S.$$.fragment,f),h(n.$$.fragment,f),h(O.$$.fragment,f),h(R.$$.fragment,f),ne=!0)},o(f){d(S.$$.fragment,f),d(n.$$.fragment,f),d(O.$$.fragment,f),d(R.$$.fragment,f),ne=!1},d(f){f&&p(t),f&&p(e),f&&p(s),f&&p(a),f&&p(i),f&&p(l),f&&p(m),f&&p(c),b(S,f),f&&p(q),f&&p(k),f&&p(D),f&&p(M),b(n),f&&p(ee),b(O,f),f&&p(te),f&&p(Y),f&&p(re),f&&p(N),f&&p($e),b(R,f),f&&p(se),f&&p(j),f&&p(ae),f&&p(J)}}}function ut(o){let t,r,e,s;return e=new Ee({props:{$$slots:{default:[mt]},$$scope:{ctx:o}}}),{c(){t=z("meta"),r=y(),_(e.$$.fragment),this.h()},l(a){const i=xe("svelte-12fnlo5",document.head);t=A(i,"META",{name:!0,content:!0}),i.forEach(p),r=x(a),g(e.$$.fragment,a),this.h()},h(){document.title="Cross-Entropy vs Mean Squared Error - World4AI",fe(t,"name","description"),fe(t,"content","The cross-entropy loss is more suited for classification tasks, due to higher gradients, especially when the true label and the predicted label diverge strongly. Higher gradients lead to faster convergence. It is therefore advisable to avoid the mean squared error in classification tasks.")},m(a,i){F(document.head,t),u(a,r,i),w(e,a,i),s=!0},p(a,[i]){const $={};i&1024&&($.$$scope={dirty:i,ctx:a}),e.$set($)},i(a){s||(h(e.$$.fragment,a),s=!0)},o(a){d(e.$$.fragment,a),s=!1},d(a){p(t),a&&p(r),b(e,a)}}}function ct(o){let t=[],r=[],e=[],s=[],a=[],i=[],$=[],l=[],m=[],v=[];for(let c=0;c<=1;c+=.01){let S,q,k,L;L=(0-c)**2,k=-2*(0-c),S={x:c,y:L},q={x:c,y:k},r.push(S),$.push(q),L=(1-c)**2,k=-2*(1-c),S={x:c,y:L},e.push(S),q={x:c,y:k},l.push(q);let D;c!==0&&c!==1&&(D=-Math.log(1-c),k=1/(1-c),S={x:c,y:D},q={x:c,y:k},s.push(S),m.push(q),D=-Math.log(c),k=-1/c,S={x:c,y:D},q={x:c,y:k},a.push(S),v.push(q))}return t.push(r),t.push(e),t.push(s),t.push(a),i.push($),i.push(l),i.push(m),i.push(v),[t,i]}class xt extends be{constructor(t){super(),ve(this,t,ct,ut,ye,{})}}export{xt as default};
