import{S as ot,i as lt,s as at,k as K,a as I,q as y,y as V,W as st,l as M,h,c as N,m as P,r as A,z as S,n as Y,N as T,b as _,A as z,g as d,d as b,B,Q as _e,e as D,R as ve,C,P as H,v as le,f as ae}from"../chunks/index.4d92b023.js";import{C as it}from"../chunks/Container.b0705c7b.js";import{F as ft,I as ct}from"../chunks/InternalLink.7deb899c.js";import{H as ut}from"../chunks/Highlight.b7c1de53.js";import{L as X}from"../chunks/Latex.e0b308c0.js";import{S as Me}from"../chunks/SvgContainer.f70b5745.js";import{B as W}from"../chunks/Block.059eddcd.js";import{B as ht}from"../chunks/Border.97f6e782.js";function We(i,t,r){const e=i.slice();return e[1]=t[r],e[3]=r,e}function je(i,t,r){const e=i.slice();return e[1]=t[r],e[5]=r,e}function He(i,t,r){const e=i.slice();return e[1]=t[r],e[3]=r,e}function Re(i,t,r){const e=i.slice();return e[1]=t[r],e[5]=r,e}function mt(i,t,r){const e=i.slice();return e[1]=t[r],e[9]=r,e}function Ge(i,t,r){const e=i.slice();return e[1]=t[r],e[3]=r,e}function Je(i,t,r){const e=i.slice();return e[1]=t[r],e[5]=r,e}function $t(i,t,r){const e=i.slice();return e[1]=t[r],e[9]=r,e}function Ue(i,t,r){const e=i.slice();return e[1]=t[r],e[5]=r,e}function pt(i,t,r){const e=i.slice();return e[1]=t[r],e[3]=r,e}function gt(i,t,r){const e=i.slice();return e[1]=t[r],e[16]=r,e}function dt(i){let t;return{c(){t=y("VQ-VAE")},l(r){t=A(r,"VQ-VAE")},m(r,e){_(r,t,e)},d(r){r&&h(t)}}}function _t(i){let t,r;return t=new W({props:{x:25+i[16]*25,y:100,width:"20",height:"120",color:"var(--main-color-2)",text:"e_"+(i[16]+1),fontSize:"10",type:"latex"}}),{c(){V(t.$$.fragment)},l(e){S(t.$$.fragment,e)},m(e,n){z(t,e,n),r=!0},p:C,i(e){r||(d(t.$$.fragment,e),r=!0)},o(e){b(t.$$.fragment,e),r=!1},d(e){B(t,e)}}}function vt(i){let t,r,e,n,c,o,a,s;r=new W({props:{x:"125",y:"15",width:"110",height:"25",text:"CODEBOOK",fontSize:"15",color:"var(--main-color-1)"}});let q=Array(7),w=[];for(let m=0;m<q.length;m+=1)w[m]=_t(gt(i,q,m));return n=new W({props:{x:25+7*25,y:100,width:"20",height:"120",color:"var(--main-color-2)",text:"...",fontSize:"10",type:"latex"}}),c=new W({props:{x:25+8*25,y:100,width:"20",height:"120",color:"var(--main-color-2)",text:"e_K",fontSize:"10",type:"latex"}}),o=new ht({props:{x:5,y:35,width:240,height:130}}),{c(){t=_e("svg"),V(r.$$.fragment);for(let m=0;m<w.length;m+=1)w[m].c();e=D(),V(n.$$.fragment),V(c.$$.fragment),V(o.$$.fragment),a=_e("svg"),this.h()},l(m){t=ve(m,"svg",{viewBox:!0});var p=P(t);S(r.$$.fragment,p);for(let x=0;x<w.length;x+=1)w[x].l(p);e=D(),S(n.$$.fragment,p),S(c.$$.fragment,p),S(o.$$.fragment,p),a=ve(p,"svg",{});var v=P(a);v.forEach(h),p.forEach(h),this.h()},h(){Y(t,"viewBox","0 0 250 170")},m(m,p){_(m,t,p),z(r,t,null);for(let v=0;v<w.length;v+=1)w[v]&&w[v].m(t,null);T(t,e),z(n,t,null),z(c,t,null),z(o,t,null),T(t,a),s=!0},p:C,i(m){if(!s){d(r.$$.fragment,m);for(let p=0;p<q.length;p+=1)d(w[p]);d(n.$$.fragment,m),d(c.$$.fragment,m),d(o.$$.fragment,m),s=!0}},o(m){b(r.$$.fragment,m),w=w.filter(Boolean);for(let p=0;p<w.length;p+=1)b(w[p]);b(n.$$.fragment,m),b(c.$$.fragment,m),b(o.$$.fragment,m),s=!1},d(m){m&&h(t),B(r),H(w,m),B(n),B(c),B(o)}}}function bt(i){let t=String.raw`K`+"",r;return{c(){r=y(t)},l(e){r=A(e,t)},m(e,n){_(e,r,n)},p:C,d(e){e&&h(r)}}}function xt(i){let t=String.raw`D`+"",r;return{c(){r=y(t)},l(e){r=A(e,t)},m(e,n){_(e,r,n)},p:C,d(e){e&&h(r)}}}function wt(i){let t=String.raw`z_e(x)`+"",r;return{c(){r=y(t)},l(e){r=A(e,t)},m(e,n){_(e,r,n)},p:C,d(e){e&&h(r)}}}function kt(i){let t=String.raw`k`+"",r;return{c(){r=y(t)},l(e){r=A(e,t)},m(e,n){_(e,r,n)},p:C,d(e){e&&h(r)}}}function yt(i){let t=String.raw`k = \arg\min_j ||z_e(x) - e_j ||`+"",r;return{c(){r=y(t)},l(e){r=A(e,t)},m(e,n){_(e,r,n)},p:C,d(e){e&&h(r)}}}function At(i){let t,r;return t=new W({props:{x:320+i[5]*25,y:80+i[3]*25,width:"20",height:"20",color:"var(--main-color-2)",fontSize:"10",type:"latex"}}),{c(){V(t.$$.fragment)},l(e){S(t.$$.fragment,e)},m(e,n){z(t,e,n),r=!0},p:C,i(e){r||(d(t.$$.fragment,e),r=!0)},o(e){b(t.$$.fragment,e),r=!1},d(e){B(t,e)}}}function Xe(i){let t,r,e;t=new W({props:{x:320+i[5]*25,y:50,width:"20",height:"20",text:i[5]+1,color:"none",fontSize:"12"}});let n=Array(3),c=[];for(let o=0;o<n.length;o+=1)c[o]=At(pt(i,n,o));return{c(){V(t.$$.fragment);for(let o=0;o<c.length;o+=1)c[o].c();r=D()},l(o){S(t.$$.fragment,o);for(let a=0;a<c.length;a+=1)c[a].l(o);r=D()},m(o,a){z(t,o,a);for(let s=0;s<c.length;s+=1)c[s]&&c[s].m(o,a);_(o,r,a),e=!0},p:C,i(o){if(!e){d(t.$$.fragment,o);for(let a=0;a<n.length;a+=1)d(c[a]);e=!0}},o(o){b(t.$$.fragment,o),c=c.filter(Boolean);for(let a=0;a<c.length;a+=1)b(c[a]);e=!1},d(o){B(t,o),H(c,o),o&&h(r)}}}function Et(i){let t,r;return t=new W({props:{x:45-i[9]*10+i[5]*25,y:180-i[9]*10+i[3]*25,width:20,height:20,color:i[5]===4&&i[3]===0?"var(--main-color-1)":"var(--main-color-3)"}}),{c(){V(t.$$.fragment)},l(e){S(t.$$.fragment,e)},m(e,n){z(t,e,n),r=!0},p:C,i(e){r||(d(t.$$.fragment,e),r=!0)},o(e){b(t.$$.fragment,e),r=!1},d(e){B(t,e)}}}function Ye(i){let t,r,e=Array(3),n=[];for(let c=0;c<e.length;c+=1)n[c]=Et($t(i,e,c));return{c(){for(let c=0;c<n.length;c+=1)n[c].c();t=D()},l(c){for(let o=0;o<n.length;o+=1)n[o].l(c);t=D()},m(c,o){for(let a=0;a<n.length;a+=1)n[a]&&n[a].m(c,o);_(c,t,o),r=!0},p:C,i(c){if(!r){for(let o=0;o<e.length;o+=1)d(n[o]);r=!0}},o(c){n=n.filter(Boolean);for(let o=0;o<n.length;o+=1)b(n[o]);r=!1},d(c){H(n,c),c&&h(t)}}}function Ze(i){let t,r,e=Array(5),n=[];for(let o=0;o<e.length;o+=1)n[o]=Ye(Je(i,e,o));const c=o=>b(n[o],1,1,()=>{n[o]=null});return{c(){for(let o=0;o<n.length;o+=1)n[o].c();t=D()},l(o){for(let a=0;a<n.length;a+=1)n[a].l(o);t=D()},m(o,a){for(let s=0;s<n.length;s+=1)n[s]&&n[s].m(o,a);_(o,t,a),r=!0},p(o,a){if(a&0){e=Array(5);let s;for(s=0;s<e.length;s+=1){const q=Je(o,e,s);n[s]?(n[s].p(q,a),d(n[s],1)):(n[s]=Ye(q),n[s].c(),d(n[s],1),n[s].m(t.parentNode,t))}for(le(),s=e.length;s<n.length;s+=1)c(s);ae()}},i(o){if(!r){for(let a=0;a<e.length;a+=1)d(n[a]);r=!0}},o(o){n=n.filter(Boolean);for(let a=0;a<n.length;a+=1)b(n[a]);r=!1},d(o){H(n,o),o&&h(t)}}}function Vt(i){let t,r;return t=new W({props:{x:45-i[9]*10+i[3]*25,y:180-i[9]*10+i[5]*25,width:20,height:20,color:"var(--main-color-4)"}}),{c(){V(t.$$.fragment)},l(e){S(t.$$.fragment,e)},m(e,n){z(t,e,n),r=!0},p:C,i(e){r||(d(t.$$.fragment,e),r=!0)},o(e){b(t.$$.fragment,e),r=!1},d(e){B(t,e)}}}function et(i){let t,r,e=Array(3),n=[];for(let c=0;c<e.length;c+=1)n[c]=Vt(mt(i,e,c));return{c(){for(let c=0;c<n.length;c+=1)n[c].c();t=D()},l(c){for(let o=0;o<n.length;o+=1)n[o].l(c);t=D()},m(c,o){for(let a=0;a<n.length;a+=1)n[a]&&n[a].m(c,o);_(c,t,o),r=!0},p:C,i(c){if(!r){for(let o=0;o<e.length;o+=1)d(n[o]);r=!0}},o(c){n=n.filter(Boolean);for(let o=0;o<n.length;o+=1)b(n[o]);r=!1},d(c){H(n,c),c&&h(t)}}}function tt(i){let t,r,e=Array(5),n=[];for(let o=0;o<e.length;o+=1)n[o]=et(Re(i,e,o));const c=o=>b(n[o],1,1,()=>{n[o]=null});return{c(){for(let o=0;o<n.length;o+=1)n[o].c();t=D()},l(o){for(let a=0;a<n.length;a+=1)n[a].l(o);t=D()},m(o,a){for(let s=0;s<n.length;s+=1)n[s]&&n[s].m(o,a);_(o,t,a),r=!0},p(o,a){if(a&0){e=Array(5);let s;for(s=0;s<e.length;s+=1){const q=Re(o,e,s);n[s]?(n[s].p(q,a),d(n[s],1)):(n[s]=et(q),n[s].c(),d(n[s],1),n[s].m(t.parentNode,t))}for(le(),s=e.length;s<n.length;s+=1)c(s);ae()}},i(o){if(!r){for(let a=0;a<e.length;a+=1)d(n[a]);r=!0}},o(o){n=n.filter(Boolean);for(let a=0;a<n.length;a+=1)b(n[a]);r=!1},d(o){H(n,o),o&&h(t)}}}function rt(i){let t,r;return t=new W({props:{x:335+i[3]*25,y:180+i[5]*25,width:20,height:20,color:"var(--main-color-2)",text:Math.ceil(Math.random()*6),fontSize:"15"}}),{c(){V(t.$$.fragment)},l(e){S(t.$$.fragment,e)},m(e,n){z(t,e,n),r=!0},p:C,i(e){r||(d(t.$$.fragment,e),r=!0)},o(e){b(t.$$.fragment,e),r=!1},d(e){B(t,e)}}}function nt(i){let t,r,e=Array(5),n=[];for(let o=0;o<e.length;o+=1)n[o]=rt(je(i,e,o));const c=o=>b(n[o],1,1,()=>{n[o]=null});return{c(){for(let o=0;o<n.length;o+=1)n[o].c();t=D()},l(o){for(let a=0;a<n.length;a+=1)n[a].l(o);t=D()},m(o,a){for(let s=0;s<n.length;s+=1)n[s]&&n[s].m(o,a);_(o,t,a),r=!0},p(o,a){if(a&0){e=Array(5);let s;for(s=0;s<e.length;s+=1){const q=je(o,e,s);n[s]?(n[s].p(q,a),d(n[s],1)):(n[s]=rt(q),n[s].c(),d(n[s],1),n[s].m(t.parentNode,t))}for(le(),s=e.length;s<n.length;s+=1)c(s);ae()}},i(o){if(!r){for(let a=0;a<e.length;a+=1)d(n[a]);r=!0}},o(o){n=n.filter(Boolean);for(let a=0;a<n.length;a+=1)b(n[a]);r=!1},d(o){H(n,o),o&&h(t)}}}function St(i){let t,r,e,n,c,o,a,s,q;r=new W({props:{x:"385",y:"20",width:"110",height:"25",text:"CODEBOOK",fontSize:"15",color:"var(--main-color-1)"}});let w=Array(6),m=[];for(let u=0;u<w.length;u+=1)m[u]=Xe(Ue(i,w,u));const p=u=>b(m[u],1,1,()=>{m[u]=null});n=new W({props:{x:"80",y:"130",width:"140",height:"25",text:"Encoder Output",fontSize:"15",color:"var(--main-color-1)"}});let v=Array(5),x=[];for(let u=0;u<v.length;u+=1)x[u]=Ze(Ge(i,v,u));const R=u=>b(x[u],1,1,()=>{x[u]=null});o=new W({props:{x:"710",y:"130",width:"140",height:"25",text:"Decoder Output",fontSize:"15",color:"var(--main-color-1)"}});let j=Array(5),k=[];for(let u=0;u<j.length;u+=1)k[u]=tt(He(i,j,u));const me=u=>b(k[u],1,1,()=>{k[u]=null});let O=Array(5),E=[];for(let u=0;u<O.length;u+=1)E[u]=nt(We(i,O,u));const G=u=>b(E[u],1,1,()=>{E[u]=null});return{c(){t=_e("svg"),V(r.$$.fragment);for(let u=0;u<m.length;u+=1)m[u].c();e=D(),V(n.$$.fragment);for(let u=0;u<x.length;u+=1)x[u].c();c=D(),V(o.$$.fragment),a=_e("g");for(let u=0;u<k.length;u+=1)k[u].c();for(let u=0;u<E.length;u+=1)E[u].c();s=_e("svg"),this.h()},l(u){t=ve(u,"svg",{viewBox:!0});var $=P(t);S(r.$$.fragment,$);for(let Q=0;Q<m.length;Q+=1)m[Q].l($);e=D(),S(n.$$.fragment,$);for(let Q=0;Q<x.length;Q+=1)x[Q].l($);c=D(),S(o.$$.fragment,$),a=ve($,"g",{transform:!0});var f=P(a);for(let Q=0;Q<k.length;Q+=1)k[Q].l(f);f.forEach(h);for(let Q=0;Q<E.length;Q+=1)E[Q].l($);s=ve($,"svg",{});var L=P(s);L.forEach(h),$.forEach(h),this.h()},h(){Y(a,"transform","translate(630, 0)"),Y(t,"viewBox","0 0 800 300")},m(u,$){_(u,t,$),z(r,t,null);for(let f=0;f<m.length;f+=1)m[f]&&m[f].m(t,null);T(t,e),z(n,t,null);for(let f=0;f<x.length;f+=1)x[f]&&x[f].m(t,null);T(t,c),z(o,t,null),T(t,a);for(let f=0;f<k.length;f+=1)k[f]&&k[f].m(a,null);for(let f=0;f<E.length;f+=1)E[f]&&E[f].m(t,null);T(t,s),q=!0},p(u,$){if($&0){w=Array(6);let f;for(f=0;f<w.length;f+=1){const L=Ue(u,w,f);m[f]?(m[f].p(L,$),d(m[f],1)):(m[f]=Xe(L),m[f].c(),d(m[f],1),m[f].m(t,e))}for(le(),f=w.length;f<m.length;f+=1)p(f);ae()}if($&0){v=Array(5);let f;for(f=0;f<v.length;f+=1){const L=Ge(u,v,f);x[f]?(x[f].p(L,$),d(x[f],1)):(x[f]=Ze(L),x[f].c(),d(x[f],1),x[f].m(t,c))}for(le(),f=v.length;f<x.length;f+=1)R(f);ae()}if($&0){j=Array(5);let f;for(f=0;f<j.length;f+=1){const L=He(u,j,f);k[f]?(k[f].p(L,$),d(k[f],1)):(k[f]=tt(L),k[f].c(),d(k[f],1),k[f].m(a,null))}for(le(),f=j.length;f<k.length;f+=1)me(f);ae()}if($&0){O=Array(5);let f;for(f=0;f<O.length;f+=1){const L=We(u,O,f);E[f]?(E[f].p(L,$),d(E[f],1)):(E[f]=nt(L),E[f].c(),d(E[f],1),E[f].m(t,s))}for(le(),f=O.length;f<E.length;f+=1)G(f);ae()}},i(u){if(!q){d(r.$$.fragment,u);for(let $=0;$<w.length;$+=1)d(m[$]);d(n.$$.fragment,u);for(let $=0;$<v.length;$+=1)d(x[$]);d(o.$$.fragment,u);for(let $=0;$<j.length;$+=1)d(k[$]);for(let $=0;$<O.length;$+=1)d(E[$]);q=!0}},o(u){b(r.$$.fragment,u),m=m.filter(Boolean);for(let $=0;$<m.length;$+=1)b(m[$]);b(n.$$.fragment,u),x=x.filter(Boolean);for(let $=0;$<x.length;$+=1)b(x[$]);b(o.$$.fragment,u),k=k.filter(Boolean);for(let $=0;$<k.length;$+=1)b(k[$]);E=E.filter(Boolean);for(let $=0;$<E.length;$+=1)b(E[$]);q=!1},d(u){u&&h(t),B(r),H(m,u),B(n),H(x,u),B(o),H(k,u),H(E,u)}}}function zt(i){let t=String.raw`K`+"",r;return{c(){r=y(t)},l(e){r=A(e,t)},m(e,n){_(e,r,n)},p:C,d(e){e&&h(r)}}}function Bt(i){let t=String.raw`x`+"",r;return{c(){r=y(t)},l(e){r=A(e,t)},m(e,n){_(e,r,n)},p:C,d(e){e&&h(r)}}}function qt(i){let t=String.raw`z_q(x)`+"",r;return{c(){r=y(t)},l(e){r=A(e,t)},m(e,n){_(e,r,n)},p:C,d(e){e&&h(r)}}}function Tt(i){let t=String.raw`L = \underbrace{||x - z_q(x)||^2_2}_{\text{Reconstruction Loss}} + \underbrace{||sg[z_e(x)] - e||^2_2}_{\text{VQ Loss}} + \beta\underbrace{||z_e(x) - sg(e)||^2_2}_{\text{Commitment Loss}}`+"",r;return{c(){r=y(t)},l(e){r=A(e,t)},m(e,n){_(e,r,n)},p:C,d(e){e&&h(r)}}}function Qt(i){let t,r,e,n,c,o,a,s,q,w,m,p,v,x,R,j,k,me,O,E,G,u,$,f,L,Q,be,Z,Be,ee,qe,xe,se,Te,we,J,Qe,te,Le,re,Pe,ke,ne,ye,ie,Ae,fe,De,Ee,ce,Ve,ue,Ce,Se,he,ze;return e=new ct({props:{type:"reference",id:1}}),c=new ut({props:{$$slots:{default:[dt]},$$scope:{ctx:i}}}),m=new Me({props:{maxWidth:"400px",$$slots:{default:[vt]},$$scope:{ctx:i}}}),R=new X({props:{$$slots:{default:[bt]},$$scope:{ctx:i}}}),k=new X({props:{$$slots:{default:[xt]},$$scope:{ctx:i}}}),O=new X({props:{$$slots:{default:[wt]},$$scope:{ctx:i}}}),G=new X({props:{$$slots:{default:[kt]},$$scope:{ctx:i}}}),$=new X({props:{$$slots:{default:[yt]},$$scope:{ctx:i}}}),Q=new Me({props:{maxWidth:"1000px",$$slots:{default:[St]},$$scope:{ctx:i}}}),ee=new X({props:{$$slots:{default:[zt]},$$scope:{ctx:i}}}),te=new X({props:{$$slots:{default:[Bt]},$$scope:{ctx:i}}}),re=new X({props:{$$slots:{default:[qt]},$$scope:{ctx:i}}}),ne=new X({props:{$$slots:{default:[Tt]},$$scope:{ctx:i}}}),{c(){t=K("p"),r=y("The vector quantised variational autoencoder "),V(e.$$.fragment),n=y(", "),V(c.$$.fragment),o=y(", was developed by DeepMind in 2017. While in deep learning terms this paper is considered to be quite old, the techniques that we learn in this section are still relevant to this day. Modern text to image generative models rely heavily on VQ-VAE."),a=I(),s=K("p"),q=y("The major idea of the paper is to quantise encoder outputs, which means that the latent variables produced by the encoder are transformed into discrete values. For that purpose we require a so called codebook."),w=I(),V(m.$$.fragment),p=I(),v=K("p"),x=y("The codebook contains "),V(R.$$.fragment),j=y(" embeddings of dimensionality "),V(k.$$.fragment),me=y(". Encoder outputs "),V(O.$$.fragment),E=y(" are compared to each individual embedding and the index "),V(G.$$.fragment),u=y(" of the nearest neighbour is used as the quantised value:"),V($.$$.fragment),f=y(". Let's look at a stylized example of a convolutional VQ-VAE and try to understand what exactly that means."),L=I(),V(Q.$$.fragment),be=I(),Z=K("p"),Be=y("Let's assume for simplicity, that the encoder produces a 5x5x3 image. The number of channels has to match the embedding dimensionality"),V(ee.$$.fragment),qe=y(", because we essentially compare each of the embeddings from the codebook to each of the vectors along the channel dimension. So in our case the codebook has vectors of size 3. For each pixel location, the quantised (blue) matrix contains the index of the embedding, that is closest to the encoder output at that particular pixel location. The decoder takes that quantised matrix and uses the corresponding embeddings from the codebooks as input, instead of the encoder output."),xe=I(),se=K("p"),Te=y("This lookup approach poses a problem, as we can not use backpropagation from the decoder input to the encoder output. Instead we assume that the gradients of the decoder input and the decoder output are similar and simply copy them from the decoder to the encoder."),we=I(),J=K("p"),Qe=y("The loss function consists of three parts. First we measure the usual reconstruction loss between the intput"),V(te.$$.fragment),Le=y(" and the decoder output "),V(re.$$.fragment),Pe=y(". Second we measure the VQ loss, as the difference between the frozen encoder outputs and the embeddings. Basically we try to move embeddings closer to the encoder outputs. Lastly we measure the commitment loss as the difference between frozen embeddings and encoder outputs. That makes sure that the encoder commits to a particular embedding and does not grow out of proportions."),ke=I(),V(ne.$$.fragment),ye=I(),ie=K("div"),Ae=I(),fe=K("h2"),De=y("Autoregressive Prior - PixelCNN"),Ee=I(),ce=K("div"),Ve=I(),ue=K("h2"),Ce=y("VQ-VAE2"),Se=I(),he=K("div"),this.h()},l(l){t=M(l,"P",{});var g=P(t);r=A(g,"The vector quantised variational autoencoder "),S(e.$$.fragment,g),n=A(g,", "),S(c.$$.fragment,g),o=A(g,", was developed by DeepMind in 2017. While in deep learning terms this paper is considered to be quite old, the techniques that we learn in this section are still relevant to this day. Modern text to image generative models rely heavily on VQ-VAE."),g.forEach(h),a=N(l),s=M(l,"P",{});var $e=P(s);q=A($e,"The major idea of the paper is to quantise encoder outputs, which means that the latent variables produced by the encoder are transformed into discrete values. For that purpose we require a so called codebook."),$e.forEach(h),w=N(l),S(m.$$.fragment,l),p=N(l),v=M(l,"P",{});var F=P(v);x=A(F,"The codebook contains "),S(R.$$.fragment,F),j=A(F," embeddings of dimensionality "),S(k.$$.fragment,F),me=A(F,". Encoder outputs "),S(O.$$.fragment,F),E=A(F," are compared to each individual embedding and the index "),S(G.$$.fragment,F),u=A(F," of the nearest neighbour is used as the quantised value:"),S($.$$.fragment,F),f=A(F,". Let's look at a stylized example of a convolutional VQ-VAE and try to understand what exactly that means."),F.forEach(h),L=N(l),S(Q.$$.fragment,l),be=N(l),Z=M(l,"P",{});var oe=P(Z);Be=A(oe,"Let's assume for simplicity, that the encoder produces a 5x5x3 image. The number of channels has to match the embedding dimensionality"),S(ee.$$.fragment,oe),qe=A(oe,", because we essentially compare each of the embeddings from the codebook to each of the vectors along the channel dimension. So in our case the codebook has vectors of size 3. For each pixel location, the quantised (blue) matrix contains the index of the embedding, that is closest to the encoder output at that particular pixel location. The decoder takes that quantised matrix and uses the corresponding embeddings from the codebooks as input, instead of the encoder output."),oe.forEach(h),xe=N(l),se=M(l,"P",{});var pe=P(se);Te=A(pe,"This lookup approach poses a problem, as we can not use backpropagation from the decoder input to the encoder output. Instead we assume that the gradients of the decoder input and the decoder output are similar and simply copy them from the decoder to the encoder."),pe.forEach(h),we=N(l),J=M(l,"P",{});var U=P(J);Qe=A(U,"The loss function consists of three parts. First we measure the usual reconstruction loss between the intput"),S(te.$$.fragment,U),Le=A(U," and the decoder output "),S(re.$$.fragment,U),Pe=A(U,". Second we measure the VQ loss, as the difference between the frozen encoder outputs and the embeddings. Basically we try to move embeddings closer to the encoder outputs. Lastly we measure the commitment loss as the difference between frozen embeddings and encoder outputs. That makes sure that the encoder commits to a particular embedding and does not grow out of proportions."),U.forEach(h),ke=N(l),S(ne.$$.fragment,l),ye=N(l),ie=M(l,"DIV",{class:!0}),P(ie).forEach(h),Ae=N(l),fe=M(l,"H2",{});var ge=P(fe);De=A(ge,"Autoregressive Prior - PixelCNN"),ge.forEach(h),Ee=N(l),ce=M(l,"DIV",{class:!0}),P(ce).forEach(h),Ve=N(l),ue=M(l,"H2",{});var de=P(ue);Ce=A(de,"VQ-VAE2"),de.forEach(h),Se=N(l),he=M(l,"DIV",{class:!0}),P(he).forEach(h),this.h()},h(){Y(ie,"class","separator"),Y(ce,"class","separator"),Y(he,"class","separator")},m(l,g){_(l,t,g),T(t,r),z(e,t,null),T(t,n),z(c,t,null),T(t,o),_(l,a,g),_(l,s,g),T(s,q),_(l,w,g),z(m,l,g),_(l,p,g),_(l,v,g),T(v,x),z(R,v,null),T(v,j),z(k,v,null),T(v,me),z(O,v,null),T(v,E),z(G,v,null),T(v,u),z($,v,null),T(v,f),_(l,L,g),z(Q,l,g),_(l,be,g),_(l,Z,g),T(Z,Be),z(ee,Z,null),T(Z,qe),_(l,xe,g),_(l,se,g),T(se,Te),_(l,we,g),_(l,J,g),T(J,Qe),z(te,J,null),T(J,Le),z(re,J,null),T(J,Pe),_(l,ke,g),z(ne,l,g),_(l,ye,g),_(l,ie,g),_(l,Ae,g),_(l,fe,g),T(fe,De),_(l,Ee,g),_(l,ce,g),_(l,Ve,g),_(l,ue,g),T(ue,Ce),_(l,Se,g),_(l,he,g),ze=!0},p(l,g){const $e={};g&131072&&($e.$$scope={dirty:g,ctx:l}),c.$set($e);const F={};g&131072&&(F.$$scope={dirty:g,ctx:l}),m.$set(F);const oe={};g&131072&&(oe.$$scope={dirty:g,ctx:l}),R.$set(oe);const pe={};g&131072&&(pe.$$scope={dirty:g,ctx:l}),k.$set(pe);const U={};g&131072&&(U.$$scope={dirty:g,ctx:l}),O.$set(U);const ge={};g&131072&&(ge.$$scope={dirty:g,ctx:l}),G.$set(ge);const de={};g&131072&&(de.$$scope={dirty:g,ctx:l}),$.$set(de);const Ie={};g&131072&&(Ie.$$scope={dirty:g,ctx:l}),Q.$set(Ie);const Ne={};g&131072&&(Ne.$$scope={dirty:g,ctx:l}),ee.$set(Ne);const Oe={};g&131072&&(Oe.$$scope={dirty:g,ctx:l}),te.$set(Oe);const Fe={};g&131072&&(Fe.$$scope={dirty:g,ctx:l}),re.$set(Fe);const Ke={};g&131072&&(Ke.$$scope={dirty:g,ctx:l}),ne.$set(Ke)},i(l){ze||(d(e.$$.fragment,l),d(c.$$.fragment,l),d(m.$$.fragment,l),d(R.$$.fragment,l),d(k.$$.fragment,l),d(O.$$.fragment,l),d(G.$$.fragment,l),d($.$$.fragment,l),d(Q.$$.fragment,l),d(ee.$$.fragment,l),d(te.$$.fragment,l),d(re.$$.fragment,l),d(ne.$$.fragment,l),ze=!0)},o(l){b(e.$$.fragment,l),b(c.$$.fragment,l),b(m.$$.fragment,l),b(R.$$.fragment,l),b(k.$$.fragment,l),b(O.$$.fragment,l),b(G.$$.fragment,l),b($.$$.fragment,l),b(Q.$$.fragment,l),b(ee.$$.fragment,l),b(te.$$.fragment,l),b(re.$$.fragment,l),b(ne.$$.fragment,l),ze=!1},d(l){l&&h(t),B(e),B(c),l&&h(a),l&&h(s),l&&h(w),B(m,l),l&&h(p),l&&h(v),B(R),B(k),B(O),B(G),B($),l&&h(L),B(Q,l),l&&h(be),l&&h(Z),B(ee),l&&h(xe),l&&h(se),l&&h(we),l&&h(J),B(te),B(re),l&&h(ke),B(ne,l),l&&h(ye),l&&h(ie),l&&h(Ae),l&&h(fe),l&&h(Ee),l&&h(ce),l&&h(Ve),l&&h(ue),l&&h(Se),l&&h(he)}}}function Lt(i){let t,r,e,n,c,o,a,s,q,w,m;return s=new it({props:{$$slots:{default:[Qt]},$$scope:{ctx:i}}}),w=new ft({props:{references:i[0]}}),{c(){t=K("meta"),r=I(),e=K("h1"),n=y("VQ-VAE"),c=I(),o=K("div"),a=I(),V(s.$$.fragment),q=I(),V(w.$$.fragment),this.h()},l(p){const v=st("svelte-1ry29t3",document.head);t=M(v,"META",{name:!0,content:!0}),v.forEach(h),r=N(p),e=M(p,"H1",{});var x=P(e);n=A(x,"VQ-VAE"),x.forEach(h),c=N(p),o=M(p,"DIV",{class:!0}),P(o).forEach(h),a=N(p),S(s.$$.fragment,p),q=N(p),S(w.$$.fragment,p),this.h()},h(){document.title="World4AI | Deep Learning | VQ-VAE",Y(t,"name","description"),Y(t,"content","A vector quantazed variational autoencoder (VQ-VAE) produces discrete encoder output values. A codebook with embedding values is stored and the encoder output measures the distance between those outputs and embeddings. The corresponding indices are the discrete quantised values."),Y(o,"class","separator")},m(p,v){T(document.head,t),_(p,r,v),_(p,e,v),T(e,n),_(p,c,v),_(p,o,v),_(p,a,v),z(s,p,v),_(p,q,v),z(w,p,v),m=!0},p(p,[v]){const x={};v&131072&&(x.$$scope={dirty:v,ctx:p}),s.$set(x)},i(p){m||(d(s.$$.fragment,p),d(w.$$.fragment,p),m=!0)},o(p){b(s.$$.fragment,p),b(w.$$.fragment,p),m=!1},d(p){h(t),p&&h(r),p&&h(e),p&&h(c),p&&h(o),p&&h(a),B(s,p),p&&h(q),B(w,p)}}}function Pt(i){return[[{author:"van den Oord, Aaron and Vinyals, Oriol and Kavukcuoglu, Koray",title:"Neural Discrete Representation Learning",journal:"Advances in Neural Information Processing Systems",year:"2017",pages:"",volume:"30",issue:""}]]}class Wt extends ot{constructor(t){super(),lt(this,t,Pt,Lt,at,{})}}export{Wt as default};
