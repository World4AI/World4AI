import{S as ot,i as lt,s as ft,k as L,a as z,q as f,y as u,W as $t,l as q,h as i,c as N,m as M,r as $,z as p,n as he,N as v,b as l,A as c,g,d,B as w,C as P,Q as mt,R as ht}from"../chunks/index.4d92b023.js";import{C as ut}from"../chunks/Container.b0705c7b.js";import{F as pt,I as it}from"../chunks/InternalLink.7deb899c.js";import{L as V}from"../chunks/Latex.e0b308c0.js";import{S as ct}from"../chunks/SvgContainer.f70b5745.js";import{B as oe}from"../chunks/Block.059eddcd.js";import{B as st}from"../chunks/Border.97f6e782.js";import{A as _e}from"../chunks/Arrow.ae91874c.js";function gt(h){let r=String.raw`G`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function dt(h){let r=String.raw`D`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function wt(h){let r,a,t,n,k,x,W,A,G,S,I,o,b,y,F,B,O;return a=new oe({props:{x:"20",y:"110",width:"20",height:"20",text:"z",fontSize:"15",type:"latex"}}),t=new oe({props:{x:"100",y:"110",width:"40",height:"40",text:"G",fontSize:"15",type:"latex",color:"var(--main-color-3)"}}),n=new oe({props:{x:"200",y:"30",width:"40",height:"40",text:"x",fontSize:"15",type:"latex"}}),k=new oe({props:{x:"200",y:"110",width:"40",height:"40",text:"G(z)",fontSize:"15",type:"latex"}}),x=new oe({props:{x:"300",y:"70",width:"40",height:"40",text:"D",fontSize:"15",type:"latex",color:"var(--main-color-3)"}}),W=new oe({props:{x:"400",y:"70",width:"50",height:"20",text:"p(true)",fontSize:"10",type:"latex"}}),A=new st({props:{x:"5",y:"80",width:"220",height:"55"}}),G=new st({props:{x:"170",y:"2",width:"260",height:"135"}}),S=new oe({props:{x:"100",y:"60",width:"70",height:"20",text:"Generator",fontSize:"10",color:"var(--main-color-1)"}}),I=new oe({props:{x:"380",y:"20",width:"80",height:"20",text:"Discriminator",fontSize:"10",color:"var(--main-color-1)"}}),o=new _e({props:{data:[{x:35,y:110},{x:70,y:110}],strokeWidth:"1.5",dashed:!0,strokeDashArray:"5, 5",moving:!0,speed:"50"}}),b=new _e({props:{data:[{x:120,y:110},{x:175,y:110}],strokeWidth:"1.5",dashed:!0,strokeDashArray:"5, 5",moving:!0,speed:"50"}}),y=new _e({props:{data:[{x:220,y:110},{x:300,y:110},{x:300,y:97}],strokeWidth:"1.5",dashed:!0,strokeDashArray:"5, 5",moving:!0,speed:"50"}}),F=new _e({props:{data:[{x:220,y:30},{x:300,y:30},{x:300,y:44}],strokeWidth:"1.5",dashed:!0,strokeDashArray:"5, 5",moving:!0,speed:"50"}}),B=new _e({props:{data:[{x:320,y:70},{x:370,y:70}],strokeWidth:"1.5",dashed:!0,strokeDashArray:"5, 5",moving:!0,speed:"50"}}),{c(){r=mt("svg"),u(a.$$.fragment),u(t.$$.fragment),u(n.$$.fragment),u(k.$$.fragment),u(x.$$.fragment),u(W.$$.fragment),u(A.$$.fragment),u(G.$$.fragment),u(S.$$.fragment),u(I.$$.fragment),u(o.$$.fragment),u(b.$$.fragment),u(y.$$.fragment),u(F.$$.fragment),u(B.$$.fragment),this.h()},l(m){r=ht(m,"svg",{viewBox:!0});var _=M(r);p(a.$$.fragment,_),p(t.$$.fragment,_),p(n.$$.fragment,_),p(k.$$.fragment,_),p(x.$$.fragment,_),p(W.$$.fragment,_),p(A.$$.fragment,_),p(G.$$.fragment,_),p(S.$$.fragment,_),p(I.$$.fragment,_),p(o.$$.fragment,_),p(b.$$.fragment,_),p(y.$$.fragment,_),p(F.$$.fragment,_),p(B.$$.fragment,_),_.forEach(i),this.h()},h(){he(r,"viewBox","0 0 440 140")},m(m,_){l(m,r,_),c(a,r,null),c(t,r,null),c(n,r,null),c(k,r,null),c(x,r,null),c(W,r,null),c(A,r,null),c(G,r,null),c(S,r,null),c(I,r,null),c(o,r,null),c(b,r,null),c(y,r,null),c(F,r,null),c(B,r,null),O=!0},p:P,i(m){O||(g(a.$$.fragment,m),g(t.$$.fragment,m),g(n.$$.fragment,m),g(k.$$.fragment,m),g(x.$$.fragment,m),g(W.$$.fragment,m),g(A.$$.fragment,m),g(G.$$.fragment,m),g(S.$$.fragment,m),g(I.$$.fragment,m),g(o.$$.fragment,m),g(b.$$.fragment,m),g(y.$$.fragment,m),g(F.$$.fragment,m),g(B.$$.fragment,m),O=!0)},o(m){d(a.$$.fragment,m),d(t.$$.fragment,m),d(n.$$.fragment,m),d(k.$$.fragment,m),d(x.$$.fragment,m),d(W.$$.fragment,m),d(A.$$.fragment,m),d(G.$$.fragment,m),d(S.$$.fragment,m),d(I.$$.fragment,m),d(o.$$.fragment,m),d(b.$$.fragment,m),d(y.$$.fragment,m),d(F.$$.fragment,m),d(B.$$.fragment,m),O=!1},d(m){m&&i(r),w(a),w(t),w(n),w(k),w(x),w(W),w(A),w(G),w(S),w(I),w(o),w(b),w(y),w(F),w(B)}}}function vt(h){let r=String.raw`z \sim N(0,1)`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function _t(h){let r=String.raw`\mathbf{z}`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function bt(h){let r=String.raw`G`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function kt(h){let r=String.raw`D`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function xt(h){let r=String.raw`\mathbf{x}`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function yt(h){let r=String.raw`G(z)`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function At(h){let r=String.raw`V`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function Gt(h){let r=String.raw`\large \min_G \max_D V(D, G) = \mathbb{E}_{x \sim p_{data}(x)}[\log D(\mathbf{x})] + \mathbb{E}_{ z \sim p_{z}(z)}[\log(1 - D(G(\mathbf{z})))]`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function zt(h){let r=String.raw`\mathbf{x}`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function Nt(h){let r=String.raw`D(x)`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function St(h){let r=String.raw`G(\mathbf{z})`+"",a,t;return{c(){a=f(r),t=z()},l(n){a=$(n,r),t=N(n)},m(n,k){l(n,a,k),l(n,t,k)},p:P,d(n){n&&i(a),n&&i(t)}}}function Dt(h){let r=String.raw`D(G(\mathbf{z}))`+"",a,t;return{c(){a=f(r),t=z()},l(n){a=$(n,r),t=N(n)},m(n,k){l(n,a,k),l(n,t,k)},p:P,d(n){n&&i(a),n&&i(t)}}}function Tt(h){let r=String.raw`\log(1 - D(G(\mathbf{z})))`+"",a,t;return{c(){a=f(r),t=z()},l(n){a=$(n,r),t=N(n)},m(n,k){l(n,a,k),l(n,t,k)},p:P,d(n){n&&i(a),n&&i(t)}}}function It(h){let r=String.raw`D(G(\mathbf{z}))`+"",a;return{c(){a=f(r)},l(t){a=$(t,r)},m(t,n){l(t,a,n)},p:P,d(t){t&&i(a)}}}function Et(h){let r,a,t,n,k,x,W,A,G,S,I,o,b,y,F,B,O,m,_,be,D,Te,R,Ie,U,Ee,j,Ce,J,Pe,Q,We,X,Be,ke,ue,Ve,xe,Y,Le,K,qe,ye,Z,Ae,T,Me,ee,Fe,te,He,ae,Oe,re,Re,ne,Ue,ie,je,Ge,pe,ze,ce,Je,Ne,se,Qe,le,Xe,Se,ge,De;return x=new it({props:{id:1,type:"reference"}}),y=new V({props:{$$slots:{default:[gt]},$$scope:{ctx:h}}}),B=new V({props:{$$slots:{default:[dt]},$$scope:{ctx:h}}}),_=new ct({props:{maxWidth:"800px",$$slots:{default:[wt]},$$scope:{ctx:h}}}),R=new V({props:{$$slots:{default:[vt]},$$scope:{ctx:h}}}),U=new V({props:{$$slots:{default:[_t]},$$scope:{ctx:h}}}),j=new V({props:{$$slots:{default:[bt]},$$scope:{ctx:h}}}),J=new V({props:{$$slots:{default:[kt]},$$scope:{ctx:h}}}),Q=new V({props:{$$slots:{default:[xt]},$$scope:{ctx:h}}}),X=new V({props:{$$slots:{default:[yt]},$$scope:{ctx:h}}}),K=new V({props:{$$slots:{default:[At]},$$scope:{ctx:h}}}),Z=new V({props:{$$slots:{default:[Gt]},$$scope:{ctx:h}}}),ee=new V({props:{$$slots:{default:[zt]},$$scope:{ctx:h}}}),te=new V({props:{$$slots:{default:[Nt]},$$scope:{ctx:h}}}),ae=new V({props:{$$slots:{default:[St]},$$scope:{ctx:h}}}),re=new V({props:{$$slots:{default:[Dt]},$$scope:{ctx:h}}}),ne=new V({props:{$$slots:{default:[Tt]},$$scope:{ctx:h}}}),ie=new V({props:{$$slots:{default:[It]},$$scope:{ctx:h}}}),le=new it({props:{id:2,type:"reference"}}),{c(){r=L("h2"),a=f("Vanilla Generative Adversarial Networks"),t=z(),n=L("p"),k=f("Generative adversarial networks"),u(x.$$.fragment),W=f(" (GAN) were designed to train a generative model through an adversarial process. The authors of the GAN paper provided the following explanation to exemplify how this process looks like."),A=z(),G=L("p"),S=f('"There is a team of counterfeiters, trying to produce fake currency and use it without detection, while the the police is trying to detect the counterfeit currency. Competition in this game drives both teams to improve their methods until the counterfeits are indistiguishable from the genuine articles."'),I=z(),o=L("p"),b=f("The counterfeiters and the police can be thought of as two separate fully connected neural networks, that are optimized using two opposing goals and can thought of as adversaries in a two player game. In our case the counterfeiters generate new data (like images) therefore this network is called the generator model "),u(y.$$.fragment),F=f(". The other (policing) network is designed to distinguished between real and fake/generated data and is therefore called the discriminator "),u(B.$$.fragment),O=f("."),m=z(),u(_.$$.fragment),be=z(),D=L("p"),Te=f("We start the generation process by drawing Gaussian noise from the standard normal distribution"),u(R.$$.fragment),Ie=f(". In the next step we generate a fake image by feeding a noise/latent vector "),u(U.$$.fragment),Ee=f(" into the generator neural network "),u(j.$$.fragment),Ce=f(". The discriminator neural network "),u(J.$$.fragment),Pe=f(" on the other hand receveis a batch of real data "),u(Q.$$.fragment),We=f(" and a batch of fake data "),u(X.$$.fragment),Be=f(" and needs to predict the probability of the data to be real."),ke=z(),ue=L("p"),Ve=f("The intuition why this process works goes as follows. At the beginnig the discriminator can not differentiate between true and fake images, but the discriminator faces a relatively straighforward classification task, which is not that hard to learn. Once classification accuracy increases the generator needs to learn to generate better images in order to fool the discriminator, which in turn forces the discriminator to get better and so the arms race keeps continues until the generator creates images that look real and the discriminator guesses with a probability of 50% whether the images are real or not. Unfortunately the reality is more complicated. GANs are notoriously hard to train, as we will discover in our practice section. In fact there are hundreds of GANs architectures which were designed to improve on the original GAN architecture. Some of them we will discuss in a separate section."),xe=z(),Y=L("p"),Le=f("The generator and the discriminator play a so called min-max game with the following value function "),u(K.$$.fragment),qe=f(", which the generator tries to minimize and the discriminator tries to maximize."),ye=z(),u(Z.$$.fragment),Ae=z(),T=L("p"),Me=f("Now let's see why this is the case starting with the discriminator. If the discriminator faces real data "),u(ee.$$.fragment),Fe=f(", it makes sense to maximize "),u(te.$$.fragment),He=f(" indicates the probability of the data to be real. If the discriminator faces fake data "),u(ae.$$.fragment),Oe=f(", the discriminator will try to reduce the probability "),u(re.$$.fragment),Re=f(", thereby increasing "),u(ne.$$.fragment),Ue=f(". The generator does the exact opposite. Its goal is to fool the discriminator and to increase the probability of the fake data to be seen as real, which can be achieved by maximizing "),u(ie.$$.fragment),je=f("."),Ge=z(),pe=L("div"),ze=z(),ce=L("h2"),Je=f("DCGAN"),Ne=z(),se=L("p"),Qe=f("The original GAN implementation was developed using fully connected neural networks. As you know, convolutional neural networks work much better with image data, therefore researchers tried to implement a convolutional GAN architecture to generate better quality images. DCGAN"),u(le.$$.fragment),Xe=f(" (Deep Convolutional GAN) was one of the first successful convolutional GAN implementations. The architecture is relatively straightforward from todays perspective. The authors combined several state of the art research results to form their convolutioanl GAN. They used batch normalization, relu and leaky relu, replaced pooling layers with strided convolutions and utilized the Adam optimizer."),Se=z(),ge=L("div"),this.h()},l(e){r=q(e,"H2",{});var s=M(r);a=$(s,"Vanilla Generative Adversarial Networks"),s.forEach(i),t=N(e),n=q(e,"P",{});var fe=M(n);k=$(fe,"Generative adversarial networks"),p(x.$$.fragment,fe),W=$(fe," (GAN) were designed to train a generative model through an adversarial process. The authors of the GAN paper provided the following explanation to exemplify how this process looks like."),fe.forEach(i),A=N(e),G=q(e,"P",{class:!0});var de=M(G);S=$(de,'"There is a team of counterfeiters, trying to produce fake currency and use it without detection, while the the police is trying to detect the counterfeit currency. Competition in this game drives both teams to improve their methods until the counterfeits are indistiguishable from the genuine articles."'),de.forEach(i),I=N(e),o=q(e,"P",{});var H=M(o);b=$(H,"The counterfeiters and the police can be thought of as two separate fully connected neural networks, that are optimized using two opposing goals and can thought of as adversaries in a two player game. In our case the counterfeiters generate new data (like images) therefore this network is called the generator model "),p(y.$$.fragment,H),F=$(H,". The other (policing) network is designed to distinguished between real and fake/generated data and is therefore called the discriminator "),p(B.$$.fragment,H),O=$(H,"."),H.forEach(i),m=N(e),p(_.$$.fragment,e),be=N(e),D=q(e,"P",{});var E=M(D);Te=$(E,"We start the generation process by drawing Gaussian noise from the standard normal distribution"),p(R.$$.fragment,E),Ie=$(E,". In the next step we generate a fake image by feeding a noise/latent vector "),p(U.$$.fragment,E),Ee=$(E," into the generator neural network "),p(j.$$.fragment,E),Ce=$(E,". The discriminator neural network "),p(J.$$.fragment,E),Pe=$(E," on the other hand receveis a batch of real data "),p(Q.$$.fragment,E),We=$(E," and a batch of fake data "),p(X.$$.fragment,E),Be=$(E," and needs to predict the probability of the data to be real."),E.forEach(i),ke=N(e),ue=q(e,"P",{});var we=M(ue);Ve=$(we,"The intuition why this process works goes as follows. At the beginnig the discriminator can not differentiate between true and fake images, but the discriminator faces a relatively straighforward classification task, which is not that hard to learn. Once classification accuracy increases the generator needs to learn to generate better images in order to fool the discriminator, which in turn forces the discriminator to get better and so the arms race keeps continues until the generator creates images that look real and the discriminator guesses with a probability of 50% whether the images are real or not. Unfortunately the reality is more complicated. GANs are notoriously hard to train, as we will discover in our practice section. In fact there are hundreds of GANs architectures which were designed to improve on the original GAN architecture. Some of them we will discuss in a separate section."),we.forEach(i),xe=N(e),Y=q(e,"P",{});var $e=M(Y);Le=$($e,"The generator and the discriminator play a so called min-max game with the following value function "),p(K.$$.fragment,$e),qe=$($e,", which the generator tries to minimize and the discriminator tries to maximize."),$e.forEach(i),ye=N(e),p(Z.$$.fragment,e),Ae=N(e),T=q(e,"P",{});var C=M(T);Me=$(C,"Now let's see why this is the case starting with the discriminator. If the discriminator faces real data "),p(ee.$$.fragment,C),Fe=$(C,", it makes sense to maximize "),p(te.$$.fragment,C),He=$(C," indicates the probability of the data to be real. If the discriminator faces fake data "),p(ae.$$.fragment,C),Oe=$(C,", the discriminator will try to reduce the probability "),p(re.$$.fragment,C),Re=$(C,", thereby increasing "),p(ne.$$.fragment,C),Ue=$(C,". The generator does the exact opposite. Its goal is to fool the discriminator and to increase the probability of the fake data to be seen as real, which can be achieved by maximizing "),p(ie.$$.fragment,C),je=$(C,"."),C.forEach(i),Ge=N(e),pe=q(e,"DIV",{class:!0}),M(pe).forEach(i),ze=N(e),ce=q(e,"H2",{});var ve=M(ce);Je=$(ve,"DCGAN"),ve.forEach(i),Ne=N(e),se=q(e,"P",{});var me=M(se);Qe=$(me,"The original GAN implementation was developed using fully connected neural networks. As you know, convolutional neural networks work much better with image data, therefore researchers tried to implement a convolutional GAN architecture to generate better quality images. DCGAN"),p(le.$$.fragment,me),Xe=$(me," (Deep Convolutional GAN) was one of the first successful convolutional GAN implementations. The architecture is relatively straightforward from todays perspective. The authors combined several state of the art research results to form their convolutioanl GAN. They used batch normalization, relu and leaky relu, replaced pooling layers with strided convolutions and utilized the Adam optimizer."),me.forEach(i),Se=N(e),ge=q(e,"DIV",{class:!0}),M(ge).forEach(i),this.h()},h(){he(G,"class","info"),he(pe,"class","separator"),he(ge,"class","separator")},m(e,s){l(e,r,s),v(r,a),l(e,t,s),l(e,n,s),v(n,k),c(x,n,null),v(n,W),l(e,A,s),l(e,G,s),v(G,S),l(e,I,s),l(e,o,s),v(o,b),c(y,o,null),v(o,F),c(B,o,null),v(o,O),l(e,m,s),c(_,e,s),l(e,be,s),l(e,D,s),v(D,Te),c(R,D,null),v(D,Ie),c(U,D,null),v(D,Ee),c(j,D,null),v(D,Ce),c(J,D,null),v(D,Pe),c(Q,D,null),v(D,We),c(X,D,null),v(D,Be),l(e,ke,s),l(e,ue,s),v(ue,Ve),l(e,xe,s),l(e,Y,s),v(Y,Le),c(K,Y,null),v(Y,qe),l(e,ye,s),c(Z,e,s),l(e,Ae,s),l(e,T,s),v(T,Me),c(ee,T,null),v(T,Fe),c(te,T,null),v(T,He),c(ae,T,null),v(T,Oe),c(re,T,null),v(T,Re),c(ne,T,null),v(T,Ue),c(ie,T,null),v(T,je),l(e,Ge,s),l(e,pe,s),l(e,ze,s),l(e,ce,s),v(ce,Je),l(e,Ne,s),l(e,se,s),v(se,Qe),c(le,se,null),v(se,Xe),l(e,Se,s),l(e,ge,s),De=!0},p(e,s){const fe={};s&2&&(fe.$$scope={dirty:s,ctx:e}),y.$set(fe);const de={};s&2&&(de.$$scope={dirty:s,ctx:e}),B.$set(de);const H={};s&2&&(H.$$scope={dirty:s,ctx:e}),_.$set(H);const E={};s&2&&(E.$$scope={dirty:s,ctx:e}),R.$set(E);const we={};s&2&&(we.$$scope={dirty:s,ctx:e}),U.$set(we);const $e={};s&2&&($e.$$scope={dirty:s,ctx:e}),j.$set($e);const C={};s&2&&(C.$$scope={dirty:s,ctx:e}),J.$set(C);const ve={};s&2&&(ve.$$scope={dirty:s,ctx:e}),Q.$set(ve);const me={};s&2&&(me.$$scope={dirty:s,ctx:e}),X.$set(me);const Ye={};s&2&&(Ye.$$scope={dirty:s,ctx:e}),K.$set(Ye);const Ke={};s&2&&(Ke.$$scope={dirty:s,ctx:e}),Z.$set(Ke);const Ze={};s&2&&(Ze.$$scope={dirty:s,ctx:e}),ee.$set(Ze);const et={};s&2&&(et.$$scope={dirty:s,ctx:e}),te.$set(et);const tt={};s&2&&(tt.$$scope={dirty:s,ctx:e}),ae.$set(tt);const at={};s&2&&(at.$$scope={dirty:s,ctx:e}),re.$set(at);const rt={};s&2&&(rt.$$scope={dirty:s,ctx:e}),ne.$set(rt);const nt={};s&2&&(nt.$$scope={dirty:s,ctx:e}),ie.$set(nt)},i(e){De||(g(x.$$.fragment,e),g(y.$$.fragment,e),g(B.$$.fragment,e),g(_.$$.fragment,e),g(R.$$.fragment,e),g(U.$$.fragment,e),g(j.$$.fragment,e),g(J.$$.fragment,e),g(Q.$$.fragment,e),g(X.$$.fragment,e),g(K.$$.fragment,e),g(Z.$$.fragment,e),g(ee.$$.fragment,e),g(te.$$.fragment,e),g(ae.$$.fragment,e),g(re.$$.fragment,e),g(ne.$$.fragment,e),g(ie.$$.fragment,e),g(le.$$.fragment,e),De=!0)},o(e){d(x.$$.fragment,e),d(y.$$.fragment,e),d(B.$$.fragment,e),d(_.$$.fragment,e),d(R.$$.fragment,e),d(U.$$.fragment,e),d(j.$$.fragment,e),d(J.$$.fragment,e),d(Q.$$.fragment,e),d(X.$$.fragment,e),d(K.$$.fragment,e),d(Z.$$.fragment,e),d(ee.$$.fragment,e),d(te.$$.fragment,e),d(ae.$$.fragment,e),d(re.$$.fragment,e),d(ne.$$.fragment,e),d(ie.$$.fragment,e),d(le.$$.fragment,e),De=!1},d(e){e&&i(r),e&&i(t),e&&i(n),w(x),e&&i(A),e&&i(G),e&&i(I),e&&i(o),w(y),w(B),e&&i(m),w(_,e),e&&i(be),e&&i(D),w(R),w(U),w(j),w(J),w(Q),w(X),e&&i(ke),e&&i(ue),e&&i(xe),e&&i(Y),w(K),e&&i(ye),w(Z,e),e&&i(Ae),e&&i(T),w(ee),w(te),w(ae),w(re),w(ne),w(ie),e&&i(Ge),e&&i(pe),e&&i(ze),e&&i(ce),e&&i(Ne),e&&i(se),w(le),e&&i(Se),e&&i(ge)}}}function Ct(h){let r,a,t,n,k,x,W,A,G,S,I;return A=new ut({props:{$$slots:{default:[Et]},$$scope:{ctx:h}}}),S=new pt({props:{references:h[0]}}),{c(){r=L("meta"),a=z(),t=L("h1"),n=f("Generative Adversarial Networks"),k=z(),x=L("div"),W=z(),u(A.$$.fragment),G=z(),u(S.$$.fragment),this.h()},l(o){const b=$t("svelte-1m6gim3",document.head);r=q(b,"META",{name:!0,content:!0}),b.forEach(i),a=N(o),t=q(o,"H1",{});var y=M(t);n=$(y,"Generative Adversarial Networks"),y.forEach(i),k=N(o),x=q(o,"DIV",{class:!0}),M(x).forEach(i),W=N(o),p(A.$$.fragment,o),G=N(o),p(S.$$.fragment,o),this.h()},h(){document.title="World4AI | Deep Learning | Generative Adversarial Networks",he(r,"name","description"),he(r,"content","Generative adversarial networks are a pair of neural networks, that compete againts each other. The generator creates fake images, while the discriminator tries to separate real from fake images."),he(x,"class","separator")},m(o,b){v(document.head,r),l(o,a,b),l(o,t,b),v(t,n),l(o,k,b),l(o,x,b),l(o,W,b),c(A,o,b),l(o,G,b),c(S,o,b),I=!0},p(o,[b]){const y={};b&2&&(y.$$scope={dirty:b,ctx:o}),A.$set(y)},i(o){I||(g(A.$$.fragment,o),g(S.$$.fragment,o),I=!0)},o(o){d(A.$$.fragment,o),d(S.$$.fragment,o),I=!1},d(o){i(r),o&&i(a),o&&i(t),o&&i(k),o&&i(x),o&&i(W),w(A,o),o&&i(G),w(S,o)}}}function Pt(h){return[[{author:"Goodfellow, Ian and Pouget-Abadie, Jean and Mirza, Mehdi and Xu, Bing and Warde-Farley, David and Ozair, Sherjil and Courville, Aaron and Bengio, Yoshua",title:"Generative Adversarial Nets",journal:"Advances in Neural Information Processing Systems",year:"2014",volume:"27"},{author:"A. Radford, L. Metz, and S. Chintala",title:"Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks",year:"2016"}]]}class Ot extends ot{constructor(r){super(),lt(this,r,Pt,Ct,ft,{})}}export{Ot as default};
