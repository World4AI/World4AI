import{S as $f,i as sf,s as rf,w as Qs,a9 as Zs,y as u,a as v,z as p,c as x,A as _,b as l,aa as er,g,d as h,B as c,h as f,k as V,q as i,W as of,l as q,m as I,r as m,n as Ee,N as z,L as tf,C as M}from"../chunks/index.4d92b023.js";import{C as mf}from"../chunks/Container.b0705c7b.js";import{H as Fs}from"../chunks/Highlight.b7c1de53.js";import{L as P}from"../chunks/Latex.e0b308c0.js";import{B as nf}from"../chunks/ButtonContainer.e9aac418.js";import{P as ff}from"../chunks/PlayButton.85103c5a.js";import{S as tr}from"../chunks/Slider.93409d64.js";import{P as Te,T as ze}from"../chunks/Ticks.45eca5c5.js";import{P as j}from"../chunks/Path.7e6df014.js";import{C as Gt}from"../chunks/Circle.f281e92b.js";import{P as Le}from"../chunks/PythonCode.212ba7a6.js";import{X as on,Y as mn}from"../chunks/YLabel.182e66a3.js";import{T as Ks}from"../chunks/Text.b1e2b624.js";function uf(a){let n,t,s,w,T,A,L,E;return n=new ze({props:{xTicks:[0,10,20,30],yTicks:[-100,-50,0,50,100]}}),s=new Gt({props:{data:a[2]}}),T=new j({props:{data:a[3]}}),L=new j({props:{data:a[1]}}),{c(){u(n.$$.fragment),t=v(),u(s.$$.fragment),w=v(),u(T.$$.fragment),A=v(),u(L.$$.fragment)},l(o){p(n.$$.fragment,o),t=x(o),p(s.$$.fragment,o),w=x(o),p(T.$$.fragment,o),A=x(o),p(L.$$.fragment,o)},m(o,b){_(n,o,b),l(o,t,b),_(s,o,b),l(o,w,b),_(T,o,b),l(o,A,b),_(L,o,b),E=!0},p(o,b){const y={};b&2&&(y.data=o[1]),L.$set(y)},i(o){E||(g(n.$$.fragment,o),g(s.$$.fragment,o),g(T.$$.fragment,o),g(L.$$.fragment,o),E=!0)},o(o){h(n.$$.fragment,o),h(s.$$.fragment,o),h(T.$$.fragment,o),h(L.$$.fragment,o),E=!1},d(o){c(n,o),o&&f(t),c(s,o),o&&f(w),c(T,o),o&&f(A),c(L,o)}}}function pf(a){let n,t,s,w,T;n=new Te({props:{width:800,height:300,maxWidth:800,domain:[0,30],range:[-100,100],$$slots:{default:[uf]},$$scope:{ctx:a}}});function A(E){a[5](E)}let L={label:"Lambda",showValue:!0,min:"0.001",max:"0.1",step:"0.001"};return a[0]!==void 0&&(L.value=a[0]),s=new tr({props:L}),Qs.push(()=>Zs(s,"value",A)),{c(){u(n.$$.fragment),t=v(),u(s.$$.fragment)},l(E){p(n.$$.fragment,E),t=x(E),p(s.$$.fragment,E)},m(E,o){_(n,E,o),l(E,t,o),_(s,E,o),T=!0},p(E,[o]){const b={};o&4098&&(b.$$scope={dirty:o,ctx:E}),n.$set(b);const y={};!w&&o&1&&(w=!0,y.value=E[0],er(()=>w=!1)),s.$set(y)},i(E){T||(g(n.$$.fragment,E),g(s.$$.fragment,E),T=!0)},o(E){h(n.$$.fragment,E),h(s.$$.fragment,E),T=!1},d(E){c(n,E),E&&f(t),c(s,E)}}}let Js=10,_f=1,gf=500,hf=100;function cf(a,n,t){let s=.001,w=[],T=1;for(let k=0;k<=30;k++){let W=k;k%10===0&&(T*=-1);let D=Math.random()*hf*T;w.push({x:W,y:D})}let A=[];for(let k=0;k<Js;k++){let W=Number.MAX_VALUE,D=Number.MIN_VALUE;w.forEach(O=>{let G=O.x**k;G>D?D=G:G<W&&(W=G)}),A.push({min:W,max:D})}let L=[],E=[];w.forEach(k=>{E.push(k.y);let W=[];for(let D=0;D<Js;D++)if(D===0)W.push(1);else{let O=(k.x**D-A[D].min)/(A[D].max-A[D].min);W.push(O)}L.push(W)});function o(k=0){let W=[],D=[];for(let O=0;O<Js;O++)W.push(Math.random()),D.push(0);for(let O=0;O<gf;O++){D.forEach((N,R)=>{D[R]=0});let G=[];L.forEach(N=>{let R=0;W.forEach((_e,$e)=>{R+=_e*N[$e]}),G.push(R)}),L.forEach((N,R)=>{let _e=E[R]-G[R];W.forEach(($e,se)=>{let ge=-(N[se]**se),Ut=_e*ge,Ve=$e*k;D[se]+=Ut+Ve})}),D.forEach((N,R)=>{D[R]=N/L.length}),W.forEach((N,R)=>{W[R]=N-_f*D[R]})}return W}function b(k){let W=[];for(let D=0;D<L.length;D+=1){let O=D,G=0;k.forEach((N,R)=>{G+=N*L[D][R]}),W.push({x:O,y:G})}return W}let y=o(),S=b(y),$=[];function d(k){s=k,t(0,s)}return a.$$.update=()=>{a.$$.dirty&17&&s&&(t(4,y=o(s)),t(1,$=b(y)))},[s,$,w,S,y,d]}class wf extends $f{constructor(n){super(),sf(this,n,cf,pf,rf,{})}}const df=""+new URL("../assets/l1_overfitting.b2b211ec.webp",import.meta.url).href,vf=""+new URL("../assets/l2_overfitting.029d20b3.webp",import.meta.url).href;function xf(a){let n;return{c(){n=i("norm")},l(t){n=m(t,"norm")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function bf(a){let n=String.raw`\mathbf{v}`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function Lf(a){let n;return{c(){n=i("L_p")},l(t){n=m(t,"L_p")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Tf(a){let n=String.raw`\mathbf{v}`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function Ef(a){let n=String.raw`||\mathbf{v}||_p = \large\sqrt{\sum_{i=1}^n |v_i|^p}`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function zf(a){let n;return{c(){n=i("p")},l(t){n=m(t,"p")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function yf(a){let n=String.raw`L_1`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function Af(a){let n=String.raw`L_2`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function Pf(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Sf(a){let n=String.raw`\begin{bmatrix}
        5 \\
        4
      \end{bmatrix}`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function kf(a){let n=String.raw`c^2 = \displaystyle\sqrt{a^2 + b^2}`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function Wf(a){let n,t,s,w,T,A,L,E,o,b,y,S;return n=new j({props:{data:[{x:0,y:0},{x:5,y:0},{x:5,y:4},{x:0,y:0}]}}),s=new Gt({props:{data:[{x:5,y:4}]}}),T=new ze({props:{xTicks:[0,1,2,3,4,5],yTicks:[0,1,2,3,4,5]}}),L=new Ks({props:{text:"a",x:2.5,y:.2,fontSize:20}}),o=new Ks({props:{text:"b",x:4.7,y:2,fontSize:20}}),y=new Ks({props:{text:"c",x:2.5,y:2.5,fontSize:20}}),{c(){u(n.$$.fragment),t=v(),u(s.$$.fragment),w=v(),u(T.$$.fragment),A=v(),u(L.$$.fragment),E=v(),u(o.$$.fragment),b=v(),u(y.$$.fragment)},l($){p(n.$$.fragment,$),t=x($),p(s.$$.fragment,$),w=x($),p(T.$$.fragment,$),A=x($),p(L.$$.fragment,$),E=x($),p(o.$$.fragment,$),b=x($),p(y.$$.fragment,$)},m($,d){_(n,$,d),l($,t,d),_(s,$,d),l($,w,d),_(T,$,d),l($,A,d),_(L,$,d),l($,E,d),_(o,$,d),l($,b,d),_(y,$,d),S=!0},p:M,i($){S||(g(n.$$.fragment,$),g(s.$$.fragment,$),g(T.$$.fragment,$),g(L.$$.fragment,$),g(o.$$.fragment,$),g(y.$$.fragment,$),S=!0)},o($){h(n.$$.fragment,$),h(s.$$.fragment,$),h(T.$$.fragment,$),h(L.$$.fragment,$),h(o.$$.fragment,$),h(y.$$.fragment,$),S=!1},d($){c(n,$),$&&f(t),c(s,$),$&&f(w),c(T,$),$&&f(A),c(L,$),$&&f(E),c(o,$),$&&f(b),c(y,$)}}}function Vf(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function qf(a){let n;return{c(){n=i("n")},l(t){n=m(t,"n")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Df(a){let n=String.raw`
||\mathbf{v}||_2 =\displaystyle \sqrt{\sum_{i=1}^n v_i^2}
      `+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function If(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Cf(a){let n;return{c(){n=i("l")},l(t){n=m(t,"l")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Of(a){let n;return{c(){n=i("l")},l(t){n=m(t,"l")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Mf(a){let n=String.raw`\displaystyle \sqrt{x_1^2 + x_2^2} = l`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function Nf(a){let n=String.raw`\displaystyle \sqrt{x_1^2 + x_2^2} = 1`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function Bf(a){let n,t;return n=new ff({props:{f:a[9],delta:100}}),{c(){u(n.$$.fragment)},l(s){p(n.$$.fragment,s)},m(s,w){_(n,s,w),t=!0},p:M,i(s){t||(g(n.$$.fragment,s),t=!0)},o(s){h(n.$$.fragment,s),t=!1},d(s){c(n,s)}}}function Rf(a){let n,t,s,w,T,A,L,E,o,b,y,S;return n=new j({props:{data:a[8]}}),s=new j({props:{data:a[2]}}),T=new Gt({props:{data:a[3]}}),L=new ze({props:{xTicks:[-2,-1,0,1,2],yTicks:[-2,-1,0,1,2],xOffset:-15,yOffset:20}}),o=new on({props:{text:"x_1",type:"latex",fontSize:15}}),y=new mn({props:{text:"x_2",type:"latex",fontSize:15,x:0}}),{c(){u(n.$$.fragment),t=v(),u(s.$$.fragment),w=v(),u(T.$$.fragment),A=v(),u(L.$$.fragment),E=v(),u(o.$$.fragment),b=v(),u(y.$$.fragment)},l($){p(n.$$.fragment,$),t=x($),p(s.$$.fragment,$),w=x($),p(T.$$.fragment,$),A=x($),p(L.$$.fragment,$),E=x($),p(o.$$.fragment,$),b=x($),p(y.$$.fragment,$)},m($,d){_(n,$,d),l($,t,d),_(s,$,d),l($,w,d),_(T,$,d),l($,A,d),_(L,$,d),l($,E,d),_(o,$,d),l($,b,d),_(y,$,d),S=!0},p($,d){const k={};d[0]&4&&(k.data=$[2]),s.$set(k);const W={};d[0]&8&&(W.data=$[3]),T.$set(W)},i($){S||(g(n.$$.fragment,$),g(s.$$.fragment,$),g(T.$$.fragment,$),g(L.$$.fragment,$),g(o.$$.fragment,$),g(y.$$.fragment,$),S=!0)},o($){h(n.$$.fragment,$),h(s.$$.fragment,$),h(T.$$.fragment,$),h(L.$$.fragment,$),h(o.$$.fragment,$),h(y.$$.fragment,$),S=!1},d($){c(n,$),$&&f(t),c(s,$),$&&f(w),c(T,$),$&&f(A),c(L,$),$&&f(E),c(o,$),$&&f(b),c(y,$)}}}function jf(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Gf(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Uf(a){let n,t,s,w,T,A,L,E,o,b,y,S;return n=new j({props:{data:a[10]}}),s=new j({props:{data:a[11]}}),T=new j({props:{data:a[12]}}),L=new ze({props:{xTicks:[-4,-3,-2,-1,0,1,2,3,4],yTicks:[-4,-3,-2,-1,0,1,2,3,4],xOffset:-15,yOffset:20}}),o=new on({props:{text:"x_1",type:"latex",fontSize:15}}),y=new mn({props:{text:"x_2",type:"latex",fontSize:15,x:0}}),{c(){u(n.$$.fragment),t=v(),u(s.$$.fragment),w=v(),u(T.$$.fragment),A=v(),u(L.$$.fragment),E=v(),u(o.$$.fragment),b=v(),u(y.$$.fragment)},l($){p(n.$$.fragment,$),t=x($),p(s.$$.fragment,$),w=x($),p(T.$$.fragment,$),A=x($),p(L.$$.fragment,$),E=x($),p(o.$$.fragment,$),b=x($),p(y.$$.fragment,$)},m($,d){_(n,$,d),l($,t,d),_(s,$,d),l($,w,d),_(T,$,d),l($,A,d),_(L,$,d),l($,E,d),_(o,$,d),l($,b,d),_(y,$,d),S=!0},p:M,i($){S||(g(n.$$.fragment,$),g(s.$$.fragment,$),g(T.$$.fragment,$),g(L.$$.fragment,$),g(o.$$.fragment,$),g(y.$$.fragment,$),S=!0)},o($){h(n.$$.fragment,$),h(s.$$.fragment,$),h(T.$$.fragment,$),h(L.$$.fragment,$),h(o.$$.fragment,$),h(y.$$.fragment,$),S=!1},d($){c(n,$),$&&f(t),c(s,$),$&&f(w),c(T,$),$&&f(A),c(L,$),$&&f(E),c(o,$),$&&f(b),c(y,$)}}}function Hf(a){let n=String.raw`x_1 + x_2 = 3`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function Yf(a){let n;return{c(){n=i("x_1")},l(t){n=m(t,"x_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Xf(a){let n;return{c(){n=i("x_2")},l(t){n=m(t,"x_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Ff(a){let n,t,s,w,T,A,L,E;return n=new j({props:{data:a[13]}}),s=new ze({props:{xTicks:[-4,-3,-2,-1,0,1,2,3,4],yTicks:[-4,-3,-2,-1,0,1,2,3,4],xOffset:-15,yOffset:20}}),T=new on({props:{text:"x_1",type:"latex",fontSize:15}}),L=new mn({props:{text:"x_2",type:"latex",fontSize:15,x:0}}),{c(){u(n.$$.fragment),t=v(),u(s.$$.fragment),w=v(),u(T.$$.fragment),A=v(),u(L.$$.fragment)},l(o){p(n.$$.fragment,o),t=x(o),p(s.$$.fragment,o),w=x(o),p(T.$$.fragment,o),A=x(o),p(L.$$.fragment,o)},m(o,b){_(n,o,b),l(o,t,b),_(s,o,b),l(o,w,b),_(T,o,b),l(o,A,b),_(L,o,b),E=!0},p:M,i(o){E||(g(n.$$.fragment,o),g(s.$$.fragment,o),g(T.$$.fragment,o),g(L.$$.fragment,o),E=!0)},o(o){h(n.$$.fragment,o),h(s.$$.fragment,o),h(T.$$.fragment,o),h(L.$$.fragment,o),E=!1},d(o){c(n,o),o&&f(t),c(s,o),o&&f(w),c(T,o),o&&f(A),c(L,o)}}}function Kf(a){let n;return{c(){n=i("x_1")},l(t){n=m(t,"x_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Jf(a){let n;return{c(){n=i("x_2")},l(t){n=m(t,"x_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Qf(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Zf(a){let n=String.raw`x_1 + x_2 = 3`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function ea(a){let n;return{c(){n=i("L2")},l(t){n=m(t,"L2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function ta(a){let n,t,s,w,T,A,L,E,o,b,y,S;return n=new j({props:{data:a[13]}}),s=new j({props:{data:a[7]}}),T=new Gt({props:{data:[{x:1.5,y:1.5}]}}),L=new ze({props:{xTicks:[-4,-3,-2,-1,0,1,2,3,4],yTicks:[-4,-3,-2,-1,0,1,2,3,4],xOffset:-15,yOffset:20}}),o=new on({props:{text:"x_1",type:"latex",fontSize:15}}),y=new mn({props:{text:"x_2",type:"latex",fontSize:15,x:0}}),{c(){u(n.$$.fragment),t=v(),u(s.$$.fragment),w=v(),u(T.$$.fragment),A=v(),u(L.$$.fragment),E=v(),u(o.$$.fragment),b=v(),u(y.$$.fragment)},l($){p(n.$$.fragment,$),t=x($),p(s.$$.fragment,$),w=x($),p(T.$$.fragment,$),A=x($),p(L.$$.fragment,$),E=x($),p(o.$$.fragment,$),b=x($),p(y.$$.fragment,$)},m($,d){_(n,$,d),l($,t,d),_(s,$,d),l($,w,d),_(T,$,d),l($,A,d),_(L,$,d),l($,E,d),_(o,$,d),l($,b,d),_(y,$,d),S=!0},p($,d){const k={};d[0]&128&&(k.data=$[7]),s.$set(k)},i($){S||(g(n.$$.fragment,$),g(s.$$.fragment,$),g(T.$$.fragment,$),g(L.$$.fragment,$),g(o.$$.fragment,$),g(y.$$.fragment,$),S=!0)},o($){h(n.$$.fragment,$),h(s.$$.fragment,$),h(T.$$.fragment,$),h(L.$$.fragment,$),h(o.$$.fragment,$),h(y.$$.fragment,$),S=!1},d($){c(n,$),$&&f(t),c(s,$),$&&f(w),c(T,$),$&&f(A),c(L,$),$&&f(E),c(o,$),$&&f(b),c(y,$)}}}function na(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function $a(a){let n;return{c(){n=i("squared")},l(t){n=m(t,"squared")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function sa(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function ra(a){let n;return{c(){n=i("||L||_2")},l(t){n=m(t,"||L||_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function fa(a){let n;return{c(){n=i("||L||_2^2")},l(t){n=m(t,"||L||_2^2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function aa(a){let n=String.raw`L=\dfrac{1}{n}\sum_i^n (y^{(i)} - \hat{y}^{(i)} )^2 + \lambda \sum_j^m w_j^2`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function la(a){let n;return{c(){n=i("\\lambda")},l(t){n=m(t,"\\lambda")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function oa(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function ia(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function ma(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function ua(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function pa(a){let n;return{c(){n=i("\\lambda")},l(t){n=m(t,"\\lambda")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function _a(a){let n;return{c(){n=i("L_1")},l(t){n=m(t,"L_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function ga(a){let n=String.raw`
      ||\mathbf{v}||_1 = \sum_{i=1}^n |v_i|
      `+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function ha(a){let n,t,s,w,T,A,L,E;return n=new j({props:{data:[{x:0,y:0},{x:5,y:0},{x:5,y:4}]}}),s=new Gt({props:{data:[{x:0,y:0}],color:"var(--main-color-2)"}}),T=new Gt({props:{data:[{x:5,y:4}],color:"var(--main-color-1)"}}),L=new ze({props:{xTicks:[0,1,2,3,4,5],yTicks:[0,1,2,3,4,5]}}),{c(){u(n.$$.fragment),t=v(),u(s.$$.fragment),w=v(),u(T.$$.fragment),A=v(),u(L.$$.fragment)},l(o){p(n.$$.fragment,o),t=x(o),p(s.$$.fragment,o),w=x(o),p(T.$$.fragment,o),A=x(o),p(L.$$.fragment,o)},m(o,b){_(n,o,b),l(o,t,b),_(s,o,b),l(o,w,b),_(T,o,b),l(o,A,b),_(L,o,b),E=!0},p:M,i(o){E||(g(n.$$.fragment,o),g(s.$$.fragment,o),g(T.$$.fragment,o),g(L.$$.fragment,o),E=!0)},o(o){h(n.$$.fragment,o),h(s.$$.fragment,o),h(T.$$.fragment,o),h(L.$$.fragment,o),E=!1},d(o){c(n,o),o&&f(t),c(s,o),o&&f(w),c(T,o),o&&f(A),c(L,o)}}}function ca(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function wa(a){let n;return{c(){n=i("L_1")},l(t){n=m(t,"L_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function da(a){let n;return{c(){n=i("1")},l(t){n=m(t,"1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function va(a){let n=String.raw`|x_1| + |x_2| = 1`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function xa(a){let n;return{c(){n=i("L_1")},l(t){n=m(t,"L_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function ba(a){let n,t;return n=new ff({props:{f:a[15],delta:100}}),{c(){u(n.$$.fragment)},l(s){p(n.$$.fragment,s)},m(s,w){_(n,s,w),t=!0},p:M,i(s){t||(g(n.$$.fragment,s),t=!0)},o(s){h(n.$$.fragment,s),t=!1},d(s){c(n,s)}}}function La(a){let n,t,s,w,T,A,L,E,o,b,y,S;return n=new j({props:{data:a[14]}}),s=new j({props:{data:a[4]}}),T=new Gt({props:{data:a[5]}}),L=new ze({props:{xTicks:[-2,-1,0,1,2],yTicks:[-2,-1,0,1,2],xOffset:-15,yOffset:20}}),o=new on({props:{text:"x_1",type:"latex",fontSize:15}}),y=new mn({props:{text:"x_2",type:"latex",fontSize:15,x:0}}),{c(){u(n.$$.fragment),t=v(),u(s.$$.fragment),w=v(),u(T.$$.fragment),A=v(),u(L.$$.fragment),E=v(),u(o.$$.fragment),b=v(),u(y.$$.fragment)},l($){p(n.$$.fragment,$),t=x($),p(s.$$.fragment,$),w=x($),p(T.$$.fragment,$),A=x($),p(L.$$.fragment,$),E=x($),p(o.$$.fragment,$),b=x($),p(y.$$.fragment,$)},m($,d){_(n,$,d),l($,t,d),_(s,$,d),l($,w,d),_(T,$,d),l($,A,d),_(L,$,d),l($,E,d),_(o,$,d),l($,b,d),_(y,$,d),S=!0},p($,d){const k={};d[0]&16&&(k.data=$[4]),s.$set(k);const W={};d[0]&32&&(W.data=$[5]),T.$set(W)},i($){S||(g(n.$$.fragment,$),g(s.$$.fragment,$),g(T.$$.fragment,$),g(L.$$.fragment,$),g(o.$$.fragment,$),g(y.$$.fragment,$),S=!0)},o($){h(n.$$.fragment,$),h(s.$$.fragment,$),h(T.$$.fragment,$),h(L.$$.fragment,$),h(o.$$.fragment,$),h(y.$$.fragment,$),S=!1},d($){c(n,$),$&&f(t),c(s,$),$&&f(w),c(T,$),$&&f(A),c(L,$),$&&f(E),c(o,$),$&&f(b),c(y,$)}}}function Ta(a){let n;return{c(){n=i("L_1")},l(t){n=m(t,"L_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Ea(a){let n,t,s,w,T,A,L,E,o,b,y,S;return n=new j({props:{data:a[16]}}),s=new j({props:{data:a[17]}}),T=new j({props:{data:a[18]}}),L=new ze({props:{xTicks:[-4,-3,-2,-1,0,1,2,3,4],yTicks:[-4,-3,-2,-1,0,1,2,3,4],xOffset:-15,yOffset:20}}),o=new on({props:{text:"x_1",type:"latex",fontSize:15}}),y=new mn({props:{text:"x_2",type:"latex",fontSize:15,x:0}}),{c(){u(n.$$.fragment),t=v(),u(s.$$.fragment),w=v(),u(T.$$.fragment),A=v(),u(L.$$.fragment),E=v(),u(o.$$.fragment),b=v(),u(y.$$.fragment)},l($){p(n.$$.fragment,$),t=x($),p(s.$$.fragment,$),w=x($),p(T.$$.fragment,$),A=x($),p(L.$$.fragment,$),E=x($),p(o.$$.fragment,$),b=x($),p(y.$$.fragment,$)},m($,d){_(n,$,d),l($,t,d),_(s,$,d),l($,w,d),_(T,$,d),l($,A,d),_(L,$,d),l($,E,d),_(o,$,d),l($,b,d),_(y,$,d),S=!0},p:M,i($){S||(g(n.$$.fragment,$),g(s.$$.fragment,$),g(T.$$.fragment,$),g(L.$$.fragment,$),g(o.$$.fragment,$),g(y.$$.fragment,$),S=!0)},o($){h(n.$$.fragment,$),h(s.$$.fragment,$),h(T.$$.fragment,$),h(L.$$.fragment,$),h(o.$$.fragment,$),h(y.$$.fragment,$),S=!1},d($){c(n,$),$&&f(t),c(s,$),$&&f(w),c(T,$),$&&f(A),c(L,$),$&&f(E),c(o,$),$&&f(b),c(y,$)}}}function za(a){let n;return{c(){n=i("2x_1 + x_2 = 3")},l(t){n=m(t,"2x_1 + x_2 = 3")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function ya(a){let n;return{c(){n=i("L_1")},l(t){n=m(t,"L_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Aa(a){let n,t,s,w,T,A,L,E,o,b,y,S;return n=new j({props:{data:a[19]}}),s=new j({props:{data:a[6]}}),T=new Gt({props:{data:[{x:0,y:3}]}}),L=new ze({props:{xTicks:[-4,-3,-2,-1,0,1,2,3,4],yTicks:[-4,-3,-2,-1,0,1,2,3,4],xOffset:-15,yOffset:20}}),o=new on({props:{text:"x_1",type:"latex",fontSize:15}}),y=new mn({props:{text:"x_2",type:"latex",fontSize:15,x:0}}),{c(){u(n.$$.fragment),t=v(),u(s.$$.fragment),w=v(),u(T.$$.fragment),A=v(),u(L.$$.fragment),E=v(),u(o.$$.fragment),b=v(),u(y.$$.fragment)},l($){p(n.$$.fragment,$),t=x($),p(s.$$.fragment,$),w=x($),p(T.$$.fragment,$),A=x($),p(L.$$.fragment,$),E=x($),p(o.$$.fragment,$),b=x($),p(y.$$.fragment,$)},m($,d){_(n,$,d),l($,t,d),_(s,$,d),l($,w,d),_(T,$,d),l($,A,d),_(L,$,d),l($,E,d),_(o,$,d),l($,b,d),_(y,$,d),S=!0},p($,d){const k={};d[0]&64&&(k.data=$[6]),s.$set(k)},i($){S||(g(n.$$.fragment,$),g(s.$$.fragment,$),g(T.$$.fragment,$),g(L.$$.fragment,$),g(o.$$.fragment,$),g(y.$$.fragment,$),S=!0)},o($){h(n.$$.fragment,$),h(s.$$.fragment,$),h(T.$$.fragment,$),h(L.$$.fragment,$),h(o.$$.fragment,$),h(y.$$.fragment,$),S=!1},d($){c(n,$),$&&f(t),c(s,$),$&&f(w),c(T,$),$&&f(A),c(L,$),$&&f(E),c(o,$),$&&f(b),c(y,$)}}}function Pa(a){let n;return{c(){n=i("L_1")},l(t){n=m(t,"L_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Sa(a){let n;return{c(){n=i("L_1")},l(t){n=m(t,"L_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function ka(a){let n;return{c(){n=i("sparse")},l(t){n=m(t,"sparse")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Wa(a){let n;return{c(){n=i("L_1")},l(t){n=m(t,"L_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Va(a){let n;return{c(){n=i("L_1")},l(t){n=m(t,"L_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function qa(a){let n;return{c(){n=i("L_2")},l(t){n=m(t,"L_2")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Da(a){let n;return{c(){n=i("L_1")},l(t){n=m(t,"L_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Ia(a){let n;return{c(){n=i("L_1")},l(t){n=m(t,"L_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Ca(a){let n=String.raw`L=\frac{1}{n}\sum_i^n (y^{(i)} - \hat{y}^{(i)} )^2 + \lambda \sum_j^m |w_j|`+"",t;return{c(){t=i(n)},l(s){t=m(s,n)},m(s,w){l(s,t,w)},p:M,d(s){s&&f(t)}}}function Oa(a){let n;return{c(){n=i("L_1")},l(t){n=m(t,"L_1")},m(t,s){l(t,n,s)},d(t){t&&f(n)}}}function Ma(a){let n,t,s,w,T,A,L,E,o,b,y,S,$,d,k,W,D,O,G,N,R,_e,$e,se,ge,Ut,Ve,ne,dn,he,vn,ce,xn,we,bn,un,C,re,U,S$,qe,k$,De,W$,Ie,V$,Vn,Ln,qn,H,q$,Ce,D$,Oe,I$,Me,C$,Ne,O$,Be,M$,Dn,Re,In,je,Cn,de,N$,Ge,B$,Ue,R$,On,He,Mn,fe,j$,Ye,G$,Xe,U$,Fe,H$,Nn,Ke,Bn,Y,Y$,Je,X$,Qe,F$,Ze,K$,et,J$,tt,Q$,Rn,nt,jn,ye,Z$,Gn,X,es,$t,ts,st,ns,rt,$s,ft,ss,at,rs,Un,pn,fs,Hn,lt,Yn,ve,as,ot,ls,it,os,Xn,mt,is,ut,ms,Fn,Ht,Kn,pt,us,_t,ps,Jn,Yt,Qn,Xt,Zn,_n,_s,e$,Ft,t$,Kt,n$,Jt,nr,$$,ae,gs,gt,hs,Tn,cs,ws,ht,ds,s$,Qt,r$,gn,f$,hn,vs,a$,xe,xs,ct,bs,wt,Ls,l$,cn,Ts,o$,dt,i$,F,Es,vt,zs,xt,ys,bt,As,Lt,Ps,Tt,Ss,m$,Et,u$,zt,p$,yt,ks,At,Ws,_$,Pt,g$,be,Vs,St,qs,kt,Ds,h$,Wt,c$,Ae,Is,w$,le,Cs,Vt,Os,qt,Ms,Dt,Ns,d$,K,Bs,It,Rs,Ct,js,Ot,Gs,Mt,Us,Nt,Hs,v$,Bt,x$,Rt,Ys,jt,Xs,b$,Zt,L$,en,T$,tn,E$,nn,z$,$n,y$,sn,$r,A$,wn,P$;A=new Fs({props:{$$slots:{default:[xf]},$$scope:{ctx:a}}}),E=new P({props:{$$slots:{default:[bf]},$$scope:{ctx:a}}}),b=new P({props:{$$slots:{default:[Lf]},$$scope:{ctx:a}}}),S=new P({props:{$$slots:{default:[Tf]},$$scope:{ctx:a}}}),d=new P({props:{$$slots:{default:[Ef]},$$scope:{ctx:a}}}),W=new P({props:{$$slots:{default:[zf]},$$scope:{ctx:a}}}),O=new P({props:{$$slots:{default:[yf]},$$scope:{ctx:a}}}),N=new P({props:{$$slots:{default:[Af]},$$scope:{ctx:a}}}),he=new P({props:{$$slots:{default:[Pf]},$$scope:{ctx:a}}}),ce=new P({props:{$$slots:{default:[Sf]},$$scope:{ctx:a}}}),we=new P({props:{$$slots:{default:[kf]},$$scope:{ctx:a}}}),C=new Te({props:{width:500,height:500,maxWidth:500,domain:[0,5],range:[0,5],$$slots:{default:[Wf]},$$scope:{ctx:a}}}),qe=new P({props:{$$slots:{default:[Vf]},$$scope:{ctx:a}}}),De=new P({props:{$$slots:{default:[qf]},$$scope:{ctx:a}}}),Ie=new P({props:{$$slots:{default:[Df]},$$scope:{ctx:a}}}),Ce=new P({props:{$$slots:{default:[If]},$$scope:{ctx:a}}}),Oe=new P({props:{$$slots:{default:[Cf]},$$scope:{ctx:a}}}),Me=new P({props:{$$slots:{default:[Of]},$$scope:{ctx:a}}}),Ne=new P({props:{$$slots:{default:[Mf]},$$scope:{ctx:a}}}),Be=new P({props:{$$slots:{default:[Nf]},$$scope:{ctx:a}}}),Re=new nf({props:{$$slots:{default:[Bf]},$$scope:{ctx:a}}}),je=new Te({props:{width:500,height:500,maxWidth:500,domain:[-2,2],range:[-2,2],$$slots:{default:[Rf]},$$scope:{ctx:a}}}),Ge=new P({props:{$$slots:{default:[jf]},$$scope:{ctx:a}}}),Ue=new P({props:{$$slots:{default:[Gf]},$$scope:{ctx:a}}}),He=new Te({props:{width:500,height:500,maxWidth:500,domain:[-4,4],range:[-4,4],$$slots:{default:[Uf]},$$scope:{ctx:a}}}),Ye=new P({props:{$$slots:{default:[Hf]},$$scope:{ctx:a}}}),Xe=new P({props:{$$slots:{default:[Yf]},$$scope:{ctx:a}}}),Fe=new P({props:{$$slots:{default:[Xf]},$$scope:{ctx:a}}}),Ke=new Te({props:{width:500,height:500,maxWidth:500,domain:[-4,4],range:[-4,4],$$slots:{default:[Ff]},$$scope:{ctx:a}}}),Je=new P({props:{$$slots:{default:[Kf]},$$scope:{ctx:a}}}),Qe=new P({props:{$$slots:{default:[Jf]},$$scope:{ctx:a}}}),Ze=new P({props:{$$slots:{default:[Qf]},$$scope:{ctx:a}}}),et=new P({props:{$$slots:{default:[Zf]},$$scope:{ctx:a}}}),tt=new P({props:{$$slots:{default:[ea]},$$scope:{ctx:a}}}),nt=new Te({props:{width:500,height:500,maxWidth:500,domain:[-4,4],range:[-4,4],$$slots:{default:[ta]},$$scope:{ctx:a}}});function af(e){a[30](e)}let sr={min:"0.1",max:"3",step:"0.1"};a[0]!==void 0&&(sr.value=a[0]),ye=new tr({props:sr}),Qs.push(()=>Zs(ye,"value",af)),$t=new P({props:{$$slots:{default:[na]},$$scope:{ctx:a}}}),st=new Fs({props:{$$slots:{default:[$a]},$$scope:{ctx:a}}}),rt=new P({props:{$$slots:{default:[sa]},$$scope:{ctx:a}}}),ft=new P({props:{$$slots:{default:[ra]},$$scope:{ctx:a}}}),at=new P({props:{$$slots:{default:[fa]},$$scope:{ctx:a}}}),lt=new P({props:{$$slots:{default:[aa]},$$scope:{ctx:a}}}),ot=new P({props:{$$slots:{default:[la]},$$scope:{ctx:a}}}),it=new P({props:{$$slots:{default:[oa]},$$scope:{ctx:a}}}),ut=new P({props:{$$slots:{default:[ia]},$$scope:{ctx:a}}}),Ht=new wf({}),_t=new P({props:{$$slots:{default:[ma]},$$scope:{ctx:a}}}),Yt=new Le({props:{code:a[20]}}),Xt=new Le({props:{code:a[21]}}),Ft=new Le({props:{code:a[22]}}),Kt=new Le({props:{code:a[23],isOutput:!0}}),gt=new P({props:{$$slots:{default:[ua]},$$scope:{ctx:a}}}),ht=new P({props:{$$slots:{default:[pa]},$$scope:{ctx:a}}}),Qt=new Le({props:{code:a[24]}}),ct=new P({props:{$$slots:{default:[_a]},$$scope:{ctx:a}}}),wt=new P({props:{$$slots:{default:[ga]},$$scope:{ctx:a}}}),dt=new Te({props:{width:500,height:500,maxWidth:450,domain:[0,5],range:[0,5],$$slots:{default:[ha]},$$scope:{ctx:a}}}),vt=new P({props:{$$slots:{default:[ca]},$$scope:{ctx:a}}}),xt=new P({props:{$$slots:{default:[wa]},$$scope:{ctx:a}}}),bt=new P({props:{$$slots:{default:[da]},$$scope:{ctx:a}}}),Lt=new P({props:{$$slots:{default:[va]},$$scope:{ctx:a}}}),Tt=new P({props:{$$slots:{default:[xa]},$$scope:{ctx:a}}}),Et=new nf({props:{$$slots:{default:[ba]},$$scope:{ctx:a}}}),zt=new Te({props:{width:500,height:500,maxWidth:500,domain:[-2,2],range:[-2,2],$$slots:{default:[La]},$$scope:{ctx:a}}}),At=new P({props:{$$slots:{default:[Ta]},$$scope:{ctx:a}}}),Pt=new Te({props:{width:500,height:500,maxWidth:500,domain:[-4,4],range:[-4,4],$$slots:{default:[Ea]},$$scope:{ctx:a}}}),St=new P({props:{$$slots:{default:[za]},$$scope:{ctx:a}}}),kt=new P({props:{$$slots:{default:[ya]},$$scope:{ctx:a}}}),Wt=new Te({props:{width:500,height:500,maxWidth:500,domain:[-4,4],range:[-4,4],$$slots:{default:[Aa]},$$scope:{ctx:a}}});function lf(e){a[31](e)}let rr={min:"0.1",max:"4",step:"0.1"};return a[1]!==void 0&&(rr.value=a[1]),Ae=new tr({props:rr}),Qs.push(()=>Zs(Ae,"value",lf)),Vt=new P({props:{$$slots:{default:[Pa]},$$scope:{ctx:a}}}),qt=new P({props:{$$slots:{default:[Sa]},$$scope:{ctx:a}}}),Dt=new Fs({props:{$$slots:{default:[ka]},$$scope:{ctx:a}}}),It=new P({props:{$$slots:{default:[Wa]},$$scope:{ctx:a}}}),Ct=new P({props:{$$slots:{default:[Va]},$$scope:{ctx:a}}}),Ot=new P({props:{$$slots:{default:[qa]},$$scope:{ctx:a}}}),Mt=new P({props:{$$slots:{default:[Da]},$$scope:{ctx:a}}}),Nt=new P({props:{$$slots:{default:[Ia]},$$scope:{ctx:a}}}),Bt=new P({props:{$$slots:{default:[Ca]},$$scope:{ctx:a}}}),jt=new P({props:{$$slots:{default:[Oa]},$$scope:{ctx:a}}}),Zt=new Le({props:{code:a[25]}}),en=new Le({props:{code:a[26]}}),tn=new Le({props:{code:a[27]}}),nn=new Le({props:{code:a[28],isOutput:!0}}),$n=new Le({props:{code:a[29]}}),{c(){n=V("p"),t=i(`The goal of regularization is to encourage simpler models. Simpler models
    can not fit the data exactly and are therefore less prone to overfitting.
    While there are several techniques to achieve that goal, in this section we
    focus on techniques that modify the loss function.`),s=v(),w=V("p"),T=i(`We will start this section by reminding ourselves of a term usually learned
    in an introductory linear algebra course, the `),u(A.$$.fragment),L=i(`.
    The norm measures the distance of a vector
    `),u(E.$$.fragment),o=i(` from the origin. The p-norm (written
    `),u(b.$$.fragment),y=i(") for the vector "),u(S.$$.fragment),$=i(` is
    defined as `),u(d.$$.fragment),k=i(". By changing the parameter "),u(W.$$.fragment),D=i(` from 1 to infinity we get different
    types of norms. In machine learning and deep learning we are especially interested
    in the `),u(O.$$.fragment),G=i(" and the"),u(N.$$.fragment),R=i(" norm."),_e=v(),$e=V("div"),se=v(),ge=V("h2"),Ut=i("L2 Norm"),Ve=v(),ne=V("p"),dn=i("The "),u(he.$$.fragment),vn=i(` norm also called Euclidean norm is the distance measure
    we are most familiar with. When we are given the vector `),u(ce.$$.fragment),xn=i(` for example we can regard the number 5 as the x coordinate and the numver 4
    as the y coordinate. As shown in the graph below this vector is essentially a
    hypotenuse of a right triangle, therefore we need to apply the Pythagorean theorem
    to calculate the length of the vector, `),u(we.$$.fragment),bn=i("."),un=v(),u(C.$$.fragment),re=v(),U=V("p"),S$=i(`While the the Pythagorean theorem is used to calculate the length of a
    vector on a 2 dimensional plane, the `),u(qe.$$.fragment),k$=i(` norm generalizes the
    idea of length to
    `),u(De.$$.fragment),W$=i(` dimensions,
    `),u(Ie.$$.fragment),V$=i("."),Vn=v(),Ln=V("p"),qn=v(),H=V("p"),q$=i(`Now let's assume we want to find all vectors on a two dimensional plane that
    have a specific `),u(Ce.$$.fragment),D$=i(" norm of size "),u(Oe.$$.fragment),I$=i(`. When we
    are given a specific vector length `),u(Me.$$.fragment),C$=i(" such that "),u(Ne.$$.fragment),O$=i(`, we will find that there is whole set of vectors that satisfy that
    condition and that this set has a circular shape. In the interactive example
    below we assume that the norm is 1, `),u(Be.$$.fragment),M$=i(". If we draw all the vectors with the norm of 1 we get a unit circle."),Dn=v(),u(Re.$$.fragment),In=v(),u(je.$$.fragment),Cn=v(),de=V("p"),N$=i(`There is an infinite number of such circles, each corresponding to a
    different set of vectors with a particular `),u(Ge.$$.fragment),B$=i(` norm. The larger
    the radius, the larger the norm. Below we draw the circles that correspond to
    the `),u(Ue.$$.fragment),R$=i(" norm of 1, 2 and 3 respectively."),On=v(),u(He.$$.fragment),Mn=v(),fe=V("p"),j$=i(`Now let's try and anderstand how this visualization of a norm can be useful.
    Imagine we are given a single equation `),u(Ye.$$.fragment),G$=i(`. This is an underdetermined system of equations, because we have just 1
    equation and 2 unknowns. That means that there is literally an infinite
    number of possible solutions. We can depict the whole set of solutions as a
    single line. Points on that line show combinations of `),u(Xe.$$.fragment),U$=i(` and
    `),u(Fe.$$.fragment),H$=i(" that sum up to 3."),Nn=v(),u(Ke.$$.fragment),Bn=v(),Y=V("p"),Y$=i("Below we add the norm for the "),u(Je.$$.fragment),X$=i(", "),u(Qe.$$.fragment),F$=i(` vector.
    The slider controls the size of the `),u(Ze.$$.fragment),K$=i(` norm. When you keep increasing
    the norm you will realize that at the red point the circle is going to just barely
    touch the line. At this point we see the solution for `),u(et.$$.fragment),J$=i(" that has the smallest "),u(tt.$$.fragment),Q$=i(" norm out of all possible solutions."),Rn=v(),u(nt.$$.fragment),jn=v(),u(ye.$$.fragment),Gn=v(),X=V("p"),es=i("If we are able to find solutions that have a comparatively low "),u($t.$$.fragment),ts=i(` how does this apply to machine learning and why is this useful to avoid overfitting?
    We can add the `),u(st.$$.fragment),ns=v(),u(rt.$$.fragment),$s=i(` norm to the loss function as a regularizer. We do not use
    the `),u(ft.$$.fragment),ss=i(` norm directly, but calculate the square of the norm,
    `),u(at.$$.fragment),rs=i(`, because the root makes the calculation of the
    derivative more complicarted than it needs to be.`),Un=v(),pn=V("p"),fs=i(`If we are dealing with the mean squared error for example, our new loss
    function looks as below.`),Hn=v(),u(lt.$$.fragment),Yn=v(),ve=V("p"),as=i(`The overall intention is to find the solution that reduces the mean squared
    error without creating large weights. When the size of one of the weights
    increses disproportionatly, the regularization term will increase and the
    loss function will rise sharply. In order to avoid a large loss, gradient
    descent will push the weights closer to 0. Therefore by using the
    regularization term we reduce the size of the weights and the overemphasis
    on any particular feature, thereby reducing the complexity of the model. The `),u(ot.$$.fragment),ls=i(` (lambda) is the hyperparameter that we can tune to determine how much emphasis
    we would like to put on the `),u(it.$$.fragment),os=i(` norm. It is the lever that lets
    you control the size of the weights.`),Xn=v(),mt=V("p"),is=i("Below we have the same model trained with and without the "),u(ut.$$.fragment),ms=i(`
    regurlarization. You can move the slider to adjust the lambda. The higher the
    lambda, the simpler the model becomes and the more the curve looks like a straight
    line.`),Fn=v(),u(Ht.$$.fragment),Kn=v(),pt=V("p"),us=i("We can implement "),u(_t.$$.fragment),ps=i(` regularization in PyTorch, by adding a couple
    more lines to our calculation of the loss function. Esentially we loop over all
    weights and biases, square those and calculate a sum. Autograd does the rest.`),Jn=v(),u(Yt.$$.fragment),Qn=v(),u(Xt.$$.fragment),Zn=v(),_n=V("p"),_s=i("Our regularization procedure does a fine job reducing overfitting."),e$=v(),u(Ft.$$.fragment),t$=v(),u(Kt.$$.fragment),n$=v(),Jt=V("img"),$$=v(),ae=V("p"),gs=i("PyTorch actually provides a much easier way to implement "),u(gt.$$.fragment),hs=i(` regularization.
    When you define your optimizer, you can pass the `),Tn=V("code"),cs=i("weight_decay"),ws=i(`
    parameter. This is essentially the `),u(ht.$$.fragment),ds=i(" from our equation above."),s$=v(),u(Qt.$$.fragment),r$=v(),gn=V("div"),f$=v(),hn=V("h2"),vs=i("L1 Norm"),a$=v(),xe=V("p"),xs=i("The "),u(ct.$$.fragment),bs=i(` norm, also called the Manhattan distance, simply adds
    absolute values of each element of the vector,
    `),u(wt.$$.fragment),Ls=i("."),l$=v(),cn=V("p"),Ts=i(`This definition means essentially that when you want to move from the blue
    point to the red point, you do not take the direct route, but move along the
    axes.`),o$=v(),u(dt.$$.fragment),i$=v(),F=V("p"),Es=i("We can make the same exercise we did with the "),u(vt.$$.fragment),zs=i(` norm and imagine
    how the set of vectors looks like if we restrict the `),u(xt.$$.fragment),ys=i(` norm
    to length `),u(bt.$$.fragment),As=i(": "),u(Lt.$$.fragment),Ps=i(`.
    The result is a diamond shaped figure. All vectors on the ridge of the
    diamond have a `),u(Tt.$$.fragment),Ss=i(" norm of exactly 1."),m$=v(),u(Et.$$.fragment),u$=v(),u(zt.$$.fragment),p$=v(),yt=V("p"),ks=i("Different "),u(At.$$.fragment),Ws=i(" norms in 2D produce diamonds of different sizes."),_$=v(),u(Pt.$$.fragment),g$=v(),be=V("p"),Vs=i("Below we are given an underdetermined system of equations "),u(St.$$.fragment),qs=i(" and we want to find a solution with the smallest "),u(kt.$$.fragment),Ds=i(" norm."),h$=v(),u(Wt.$$.fragment),c$=v(),u(Ae.$$.fragment),w$=v(),le=V("p"),Cs=i(`When you move the slider you will find the solution, where the diamond
    touches the line. This solution produces the vector with the lowest `),u(Vt.$$.fragment),Os=i(" norm. An important characteristic of the "),u(qt.$$.fragment),Ms=i(` norm is the so
    called `),u(Dt.$$.fragment),Ns=i(` solution. The diamond has four sharp points.
    Each of those points corresponds to a vector where only one of the vector elements
    is not zero (this is also valid for more than two dimensions). That means that
    when the diomond touches the function, we are faced with a solution where the
    vector is mostly zero, a sparse vector.`),d$=v(),K=V("p"),Bs=i("When we add the "),u(It.$$.fragment),Rs=i(` regularization to the mean squared error,
    we are simultaneously reducing the mean squared error and reduce the `),u(Ct.$$.fragment),js=i(" norm. Similar to "),u(Ot.$$.fragment),Gs=i(", the "),u(Mt.$$.fragment),Us=i(` regularization
    reduces overfitting by not letting the weights grow disproportionatly. Additionally
    the `),u(Nt.$$.fragment),Hs=i(` norm tends to generate sparse weights. Most of the weights
    will correspond to 0.`),v$=v(),u(Bt.$$.fragment),x$=v(),Rt=V("p"),Ys=i("We can implement "),u(jt.$$.fragment),Xs=i(` regularization, but adjusting our loss function
    slightly. The rest of the implementation is the same.`),b$=v(),u(Zt.$$.fragment),L$=v(),u(en.$$.fragment),T$=v(),u(tn.$$.fragment),E$=v(),u(nn.$$.fragment),z$=v(),u($n.$$.fragment),y$=v(),sn=V("img"),A$=v(),wn=V("div"),this.h()},l(e){n=q(e,"P",{});var r=I(n);t=m(r,`The goal of regularization is to encourage simpler models. Simpler models
    can not fit the data exactly and are therefore less prone to overfitting.
    While there are several techniques to achieve that goal, in this section we
    focus on techniques that modify the loss function.`),r.forEach(f),s=x(e),w=q(e,"P",{});var B=I(w);T=m(B,`We will start this section by reminding ourselves of a term usually learned
    in an introductory linear algebra course, the `),p(A.$$.fragment,B),L=m(B,`.
    The norm measures the distance of a vector
    `),p(E.$$.fragment,B),o=m(B,` from the origin. The p-norm (written
    `),p(b.$$.fragment,B),y=m(B,") for the vector "),p(S.$$.fragment,B),$=m(B,` is
    defined as `),p(d.$$.fragment,B),k=m(B,". By changing the parameter "),p(W.$$.fragment,B),D=m(B,` from 1 to infinity we get different
    types of norms. In machine learning and deep learning we are especially interested
    in the `),p(O.$$.fragment,B),G=m(B," and the"),p(N.$$.fragment,B),R=m(B," norm."),B.forEach(f),_e=x(e),$e=q(e,"DIV",{class:!0}),I($e).forEach(f),se=x(e),ge=q(e,"H2",{});var En=I(ge);Ut=m(En,"L2 Norm"),En.forEach(f),Ve=x(e),ne=q(e,"P",{});var oe=I(ne);dn=m(oe,"The "),p(he.$$.fragment,oe),vn=m(oe,` norm also called Euclidean norm is the distance measure
    we are most familiar with. When we are given the vector `),p(ce.$$.fragment,oe),xn=m(oe,` for example we can regard the number 5 as the x coordinate and the numver 4
    as the y coordinate. As shown in the graph below this vector is essentially a
    hypotenuse of a right triangle, therefore we need to apply the Pythagorean theorem
    to calculate the length of the vector, `),p(we.$$.fragment,oe),bn=m(oe,"."),oe.forEach(f),un=x(e),p(C.$$.fragment,e),re=x(e),U=q(e,"P",{});var ie=I(U);S$=m(ie,`While the the Pythagorean theorem is used to calculate the length of a
    vector on a 2 dimensional plane, the `),p(qe.$$.fragment,ie),k$=m(ie,` norm generalizes the
    idea of length to
    `),p(De.$$.fragment,ie),W$=m(ie,` dimensions,
    `),p(Ie.$$.fragment,ie),V$=m(ie,"."),ie.forEach(f),Vn=x(e),Ln=q(e,"P",{}),I(Ln).forEach(f),qn=x(e),H=q(e,"P",{});var J=I(H);q$=m(J,`Now let's assume we want to find all vectors on a two dimensional plane that
    have a specific `),p(Ce.$$.fragment,J),D$=m(J," norm of size "),p(Oe.$$.fragment,J),I$=m(J,`. When we
    are given a specific vector length `),p(Me.$$.fragment,J),C$=m(J," such that "),p(Ne.$$.fragment,J),O$=m(J,`, we will find that there is whole set of vectors that satisfy that
    condition and that this set has a circular shape. In the interactive example
    below we assume that the norm is 1, `),p(Be.$$.fragment,J),M$=m(J,". If we draw all the vectors with the norm of 1 we get a unit circle."),J.forEach(f),Dn=x(e),p(Re.$$.fragment,e),In=x(e),p(je.$$.fragment,e),Cn=x(e),de=q(e,"P",{});var Pe=I(de);N$=m(Pe,`There is an infinite number of such circles, each corresponding to a
    different set of vectors with a particular `),p(Ge.$$.fragment,Pe),B$=m(Pe,` norm. The larger
    the radius, the larger the norm. Below we draw the circles that correspond to
    the `),p(Ue.$$.fragment,Pe),R$=m(Pe," norm of 1, 2 and 3 respectively."),Pe.forEach(f),On=x(e),p(He.$$.fragment,e),Mn=x(e),fe=q(e,"P",{});var me=I(fe);j$=m(me,`Now let's try and anderstand how this visualization of a norm can be useful.
    Imagine we are given a single equation `),p(Ye.$$.fragment,me),G$=m(me,`. This is an underdetermined system of equations, because we have just 1
    equation and 2 unknowns. That means that there is literally an infinite
    number of possible solutions. We can depict the whole set of solutions as a
    single line. Points on that line show combinations of `),p(Xe.$$.fragment,me),U$=m(me,` and
    `),p(Fe.$$.fragment,me),H$=m(me," that sum up to 3."),me.forEach(f),Nn=x(e),p(Ke.$$.fragment,e),Bn=x(e),Y=q(e,"P",{});var Q=I(Y);Y$=m(Q,"Below we add the norm for the "),p(Je.$$.fragment,Q),X$=m(Q,", "),p(Qe.$$.fragment,Q),F$=m(Q,` vector.
    The slider controls the size of the `),p(Ze.$$.fragment,Q),K$=m(Q,` norm. When you keep increasing
    the norm you will realize that at the red point the circle is going to just barely
    touch the line. At this point we see the solution for `),p(et.$$.fragment,Q),J$=m(Q," that has the smallest "),p(tt.$$.fragment,Q),Q$=m(Q," norm out of all possible solutions."),Q.forEach(f),Rn=x(e),p(nt.$$.fragment,e),jn=x(e),p(ye.$$.fragment,e),Gn=x(e),X=q(e,"P",{});var Z=I(X);es=m(Z,"If we are able to find solutions that have a comparatively low "),p($t.$$.fragment,Z),ts=m(Z,` how does this apply to machine learning and why is this useful to avoid overfitting?
    We can add the `),p(st.$$.fragment,Z),ns=x(Z),p(rt.$$.fragment,Z),$s=m(Z,` norm to the loss function as a regularizer. We do not use
    the `),p(ft.$$.fragment,Z),ss=m(Z,` norm directly, but calculate the square of the norm,
    `),p(at.$$.fragment,Z),rs=m(Z,`, because the root makes the calculation of the
    derivative more complicarted than it needs to be.`),Z.forEach(f),Un=x(e),pn=q(e,"P",{});var zn=I(pn);fs=m(zn,`If we are dealing with the mean squared error for example, our new loss
    function looks as below.`),zn.forEach(f),Hn=x(e),p(lt.$$.fragment,e),Yn=x(e),ve=q(e,"P",{});var Se=I(ve);as=m(Se,`The overall intention is to find the solution that reduces the mean squared
    error without creating large weights. When the size of one of the weights
    increses disproportionatly, the regularization term will increase and the
    loss function will rise sharply. In order to avoid a large loss, gradient
    descent will push the weights closer to 0. Therefore by using the
    regularization term we reduce the size of the weights and the overemphasis
    on any particular feature, thereby reducing the complexity of the model. The `),p(ot.$$.fragment,Se),ls=m(Se,` (lambda) is the hyperparameter that we can tune to determine how much emphasis
    we would like to put on the `),p(it.$$.fragment,Se),os=m(Se,` norm. It is the lever that lets
    you control the size of the weights.`),Se.forEach(f),Xn=x(e),mt=q(e,"P",{});var rn=I(mt);is=m(rn,"Below we have the same model trained with and without the "),p(ut.$$.fragment,rn),ms=m(rn,`
    regurlarization. You can move the slider to adjust the lambda. The higher the
    lambda, the simpler the model becomes and the more the curve looks like a straight
    line.`),rn.forEach(f),Fn=x(e),p(Ht.$$.fragment,e),Kn=x(e),pt=q(e,"P",{});var fn=I(pt);us=m(fn,"We can implement "),p(_t.$$.fragment,fn),ps=m(fn,` regularization in PyTorch, by adding a couple
    more lines to our calculation of the loss function. Esentially we loop over all
    weights and biases, square those and calculate a sum. Autograd does the rest.`),fn.forEach(f),Jn=x(e),p(Yt.$$.fragment,e),Qn=x(e),p(Xt.$$.fragment,e),Zn=x(e),_n=q(e,"P",{});var yn=I(_n);_s=m(yn,"Our regularization procedure does a fine job reducing overfitting."),yn.forEach(f),e$=x(e),p(Ft.$$.fragment,e),t$=x(e),p(Kt.$$.fragment,e),n$=x(e),Jt=q(e,"IMG",{src:!0,alt:!0}),$$=x(e),ae=q(e,"P",{});var ue=I(ae);gs=m(ue,"PyTorch actually provides a much easier way to implement "),p(gt.$$.fragment,ue),hs=m(ue,` regularization.
    When you define your optimizer, you can pass the `),Tn=q(ue,"CODE",{});var An=I(Tn);cs=m(An,"weight_decay"),An.forEach(f),ws=m(ue,`
    parameter. This is essentially the `),p(ht.$$.fragment,ue),ds=m(ue," from our equation above."),ue.forEach(f),s$=x(e),p(Qt.$$.fragment,e),r$=x(e),gn=q(e,"DIV",{class:!0}),I(gn).forEach(f),f$=x(e),hn=q(e,"H2",{});var Pn=I(hn);vs=m(Pn,"L1 Norm"),Pn.forEach(f),a$=x(e),xe=q(e,"P",{});var ke=I(xe);xs=m(ke,"The "),p(ct.$$.fragment,ke),bs=m(ke,` norm, also called the Manhattan distance, simply adds
    absolute values of each element of the vector,
    `),p(wt.$$.fragment,ke),Ls=m(ke,"."),ke.forEach(f),l$=x(e),cn=q(e,"P",{});var Sn=I(cn);Ts=m(Sn,`This definition means essentially that when you want to move from the blue
    point to the red point, you do not take the direct route, but move along the
    axes.`),Sn.forEach(f),o$=x(e),p(dt.$$.fragment,e),i$=x(e),F=q(e,"P",{});var ee=I(F);Es=m(ee,"We can make the same exercise we did with the "),p(vt.$$.fragment,ee),zs=m(ee,` norm and imagine
    how the set of vectors looks like if we restrict the `),p(xt.$$.fragment,ee),ys=m(ee,` norm
    to length `),p(bt.$$.fragment,ee),As=m(ee,": "),p(Lt.$$.fragment,ee),Ps=m(ee,`.
    The result is a diamond shaped figure. All vectors on the ridge of the
    diamond have a `),p(Tt.$$.fragment,ee),Ss=m(ee," norm of exactly 1."),ee.forEach(f),m$=x(e),p(Et.$$.fragment,e),u$=x(e),p(zt.$$.fragment,e),p$=x(e),yt=q(e,"P",{});var an=I(yt);ks=m(an,"Different "),p(At.$$.fragment,an),Ws=m(an," norms in 2D produce diamonds of different sizes."),an.forEach(f),_$=x(e),p(Pt.$$.fragment,e),g$=x(e),be=q(e,"P",{});var We=I(be);Vs=m(We,"Below we are given an underdetermined system of equations "),p(St.$$.fragment,We),qs=m(We," and we want to find a solution with the smallest "),p(kt.$$.fragment,We),Ds=m(We," norm."),We.forEach(f),h$=x(e),p(Wt.$$.fragment,e),c$=x(e),p(Ae.$$.fragment,e),w$=x(e),le=q(e,"P",{});var pe=I(le);Cs=m(pe,`When you move the slider you will find the solution, where the diamond
    touches the line. This solution produces the vector with the lowest `),p(Vt.$$.fragment,pe),Os=m(pe," norm. An important characteristic of the "),p(qt.$$.fragment,pe),Ms=m(pe,` norm is the so
    called `),p(Dt.$$.fragment,pe),Ns=m(pe,` solution. The diamond has four sharp points.
    Each of those points corresponds to a vector where only one of the vector elements
    is not zero (this is also valid for more than two dimensions). That means that
    when the diomond touches the function, we are faced with a solution where the
    vector is mostly zero, a sparse vector.`),pe.forEach(f),d$=x(e),K=q(e,"P",{});var te=I(K);Bs=m(te,"When we add the "),p(It.$$.fragment,te),Rs=m(te,` regularization to the mean squared error,
    we are simultaneously reducing the mean squared error and reduce the `),p(Ct.$$.fragment,te),js=m(te," norm. Similar to "),p(Ot.$$.fragment,te),Gs=m(te,", the "),p(Mt.$$.fragment,te),Us=m(te,` regularization
    reduces overfitting by not letting the weights grow disproportionatly. Additionally
    the `),p(Nt.$$.fragment,te),Hs=m(te,` norm tends to generate sparse weights. Most of the weights
    will correspond to 0.`),te.forEach(f),v$=x(e),p(Bt.$$.fragment,e),x$=x(e),Rt=q(e,"P",{});var ln=I(Rt);Ys=m(ln,"We can implement "),p(jt.$$.fragment,ln),Xs=m(ln,` regularization, but adjusting our loss function
    slightly. The rest of the implementation is the same.`),ln.forEach(f),b$=x(e),p(Zt.$$.fragment,e),L$=x(e),p(en.$$.fragment,e),T$=x(e),p(tn.$$.fragment,e),E$=x(e),p(nn.$$.fragment,e),z$=x(e),p($n.$$.fragment,e),y$=x(e),sn=q(e,"IMG",{src:!0,alt:!0}),A$=x(e),wn=q(e,"DIV",{class:!0}),I(wn).forEach(f),this.h()},h(){Ee($e,"class","separator"),tf(Jt.src,nr=vf)||Ee(Jt,"src",nr),Ee(Jt,"alt","Overfitting with L2 training"),Ee(gn,"class","separator"),tf(sn.src,$r=df)||Ee(sn,"src",$r),Ee(sn,"alt","overfitting with l1 norm"),Ee(wn,"class","separator")},m(e,r){l(e,n,r),z(n,t),l(e,s,r),l(e,w,r),z(w,T),_(A,w,null),z(w,L),_(E,w,null),z(w,o),_(b,w,null),z(w,y),_(S,w,null),z(w,$),_(d,w,null),z(w,k),_(W,w,null),z(w,D),_(O,w,null),z(w,G),_(N,w,null),z(w,R),l(e,_e,r),l(e,$e,r),l(e,se,r),l(e,ge,r),z(ge,Ut),l(e,Ve,r),l(e,ne,r),z(ne,dn),_(he,ne,null),z(ne,vn),_(ce,ne,null),z(ne,xn),_(we,ne,null),z(ne,bn),l(e,un,r),_(C,e,r),l(e,re,r),l(e,U,r),z(U,S$),_(qe,U,null),z(U,k$),_(De,U,null),z(U,W$),_(Ie,U,null),z(U,V$),l(e,Vn,r),l(e,Ln,r),l(e,qn,r),l(e,H,r),z(H,q$),_(Ce,H,null),z(H,D$),_(Oe,H,null),z(H,I$),_(Me,H,null),z(H,C$),_(Ne,H,null),z(H,O$),_(Be,H,null),z(H,M$),l(e,Dn,r),_(Re,e,r),l(e,In,r),_(je,e,r),l(e,Cn,r),l(e,de,r),z(de,N$),_(Ge,de,null),z(de,B$),_(Ue,de,null),z(de,R$),l(e,On,r),_(He,e,r),l(e,Mn,r),l(e,fe,r),z(fe,j$),_(Ye,fe,null),z(fe,G$),_(Xe,fe,null),z(fe,U$),_(Fe,fe,null),z(fe,H$),l(e,Nn,r),_(Ke,e,r),l(e,Bn,r),l(e,Y,r),z(Y,Y$),_(Je,Y,null),z(Y,X$),_(Qe,Y,null),z(Y,F$),_(Ze,Y,null),z(Y,K$),_(et,Y,null),z(Y,J$),_(tt,Y,null),z(Y,Q$),l(e,Rn,r),_(nt,e,r),l(e,jn,r),_(ye,e,r),l(e,Gn,r),l(e,X,r),z(X,es),_($t,X,null),z(X,ts),_(st,X,null),z(X,ns),_(rt,X,null),z(X,$s),_(ft,X,null),z(X,ss),_(at,X,null),z(X,rs),l(e,Un,r),l(e,pn,r),z(pn,fs),l(e,Hn,r),_(lt,e,r),l(e,Yn,r),l(e,ve,r),z(ve,as),_(ot,ve,null),z(ve,ls),_(it,ve,null),z(ve,os),l(e,Xn,r),l(e,mt,r),z(mt,is),_(ut,mt,null),z(mt,ms),l(e,Fn,r),_(Ht,e,r),l(e,Kn,r),l(e,pt,r),z(pt,us),_(_t,pt,null),z(pt,ps),l(e,Jn,r),_(Yt,e,r),l(e,Qn,r),_(Xt,e,r),l(e,Zn,r),l(e,_n,r),z(_n,_s),l(e,e$,r),_(Ft,e,r),l(e,t$,r),_(Kt,e,r),l(e,n$,r),l(e,Jt,r),l(e,$$,r),l(e,ae,r),z(ae,gs),_(gt,ae,null),z(ae,hs),z(ae,Tn),z(Tn,cs),z(ae,ws),_(ht,ae,null),z(ae,ds),l(e,s$,r),_(Qt,e,r),l(e,r$,r),l(e,gn,r),l(e,f$,r),l(e,hn,r),z(hn,vs),l(e,a$,r),l(e,xe,r),z(xe,xs),_(ct,xe,null),z(xe,bs),_(wt,xe,null),z(xe,Ls),l(e,l$,r),l(e,cn,r),z(cn,Ts),l(e,o$,r),_(dt,e,r),l(e,i$,r),l(e,F,r),z(F,Es),_(vt,F,null),z(F,zs),_(xt,F,null),z(F,ys),_(bt,F,null),z(F,As),_(Lt,F,null),z(F,Ps),_(Tt,F,null),z(F,Ss),l(e,m$,r),_(Et,e,r),l(e,u$,r),_(zt,e,r),l(e,p$,r),l(e,yt,r),z(yt,ks),_(At,yt,null),z(yt,Ws),l(e,_$,r),_(Pt,e,r),l(e,g$,r),l(e,be,r),z(be,Vs),_(St,be,null),z(be,qs),_(kt,be,null),z(be,Ds),l(e,h$,r),_(Wt,e,r),l(e,c$,r),_(Ae,e,r),l(e,w$,r),l(e,le,r),z(le,Cs),_(Vt,le,null),z(le,Os),_(qt,le,null),z(le,Ms),_(Dt,le,null),z(le,Ns),l(e,d$,r),l(e,K,r),z(K,Bs),_(It,K,null),z(K,Rs),_(Ct,K,null),z(K,js),_(Ot,K,null),z(K,Gs),_(Mt,K,null),z(K,Us),_(Nt,K,null),z(K,Hs),l(e,v$,r),_(Bt,e,r),l(e,x$,r),l(e,Rt,r),z(Rt,Ys),_(jt,Rt,null),z(Rt,Xs),l(e,b$,r),_(Zt,e,r),l(e,L$,r),_(en,e,r),l(e,T$,r),_(tn,e,r),l(e,E$,r),_(nn,e,r),l(e,z$,r),_($n,e,r),l(e,y$,r),l(e,sn,r),l(e,A$,r),l(e,wn,r),P$=!0},p(e,r){const B={};r[1]&8&&(B.$$scope={dirty:r,ctx:e}),A.$set(B);const En={};r[1]&8&&(En.$$scope={dirty:r,ctx:e}),E.$set(En);const oe={};r[1]&8&&(oe.$$scope={dirty:r,ctx:e}),b.$set(oe);const ie={};r[1]&8&&(ie.$$scope={dirty:r,ctx:e}),S.$set(ie);const J={};r[1]&8&&(J.$$scope={dirty:r,ctx:e}),d.$set(J);const Pe={};r[1]&8&&(Pe.$$scope={dirty:r,ctx:e}),W.$set(Pe);const me={};r[1]&8&&(me.$$scope={dirty:r,ctx:e}),O.$set(me);const Q={};r[1]&8&&(Q.$$scope={dirty:r,ctx:e}),N.$set(Q);const Z={};r[1]&8&&(Z.$$scope={dirty:r,ctx:e}),he.$set(Z);const zn={};r[1]&8&&(zn.$$scope={dirty:r,ctx:e}),ce.$set(zn);const Se={};r[1]&8&&(Se.$$scope={dirty:r,ctx:e}),we.$set(Se);const rn={};r[1]&8&&(rn.$$scope={dirty:r,ctx:e}),C.$set(rn);const fn={};r[1]&8&&(fn.$$scope={dirty:r,ctx:e}),qe.$set(fn);const yn={};r[1]&8&&(yn.$$scope={dirty:r,ctx:e}),De.$set(yn);const ue={};r[1]&8&&(ue.$$scope={dirty:r,ctx:e}),Ie.$set(ue);const An={};r[1]&8&&(An.$$scope={dirty:r,ctx:e}),Ce.$set(An);const Pn={};r[1]&8&&(Pn.$$scope={dirty:r,ctx:e}),Oe.$set(Pn);const ke={};r[1]&8&&(ke.$$scope={dirty:r,ctx:e}),Me.$set(ke);const Sn={};r[1]&8&&(Sn.$$scope={dirty:r,ctx:e}),Ne.$set(Sn);const ee={};r[1]&8&&(ee.$$scope={dirty:r,ctx:e}),Be.$set(ee);const an={};r[1]&8&&(an.$$scope={dirty:r,ctx:e}),Re.$set(an);const We={};r[0]&12|r[1]&8&&(We.$$scope={dirty:r,ctx:e}),je.$set(We);const pe={};r[1]&8&&(pe.$$scope={dirty:r,ctx:e}),Ge.$set(pe);const te={};r[1]&8&&(te.$$scope={dirty:r,ctx:e}),Ue.$set(te);const ln={};r[1]&8&&(ln.$$scope={dirty:r,ctx:e}),He.$set(ln);const fr={};r[1]&8&&(fr.$$scope={dirty:r,ctx:e}),Ye.$set(fr);const ar={};r[1]&8&&(ar.$$scope={dirty:r,ctx:e}),Xe.$set(ar);const lr={};r[1]&8&&(lr.$$scope={dirty:r,ctx:e}),Fe.$set(lr);const or={};r[1]&8&&(or.$$scope={dirty:r,ctx:e}),Ke.$set(or);const ir={};r[1]&8&&(ir.$$scope={dirty:r,ctx:e}),Je.$set(ir);const mr={};r[1]&8&&(mr.$$scope={dirty:r,ctx:e}),Qe.$set(mr);const ur={};r[1]&8&&(ur.$$scope={dirty:r,ctx:e}),Ze.$set(ur);const pr={};r[1]&8&&(pr.$$scope={dirty:r,ctx:e}),et.$set(pr);const _r={};r[1]&8&&(_r.$$scope={dirty:r,ctx:e}),tt.$set(_r);const gr={};r[0]&128|r[1]&8&&(gr.$$scope={dirty:r,ctx:e}),nt.$set(gr);const hr={};!Z$&&r[0]&1&&(Z$=!0,hr.value=e[0],er(()=>Z$=!1)),ye.$set(hr);const cr={};r[1]&8&&(cr.$$scope={dirty:r,ctx:e}),$t.$set(cr);const wr={};r[1]&8&&(wr.$$scope={dirty:r,ctx:e}),st.$set(wr);const dr={};r[1]&8&&(dr.$$scope={dirty:r,ctx:e}),rt.$set(dr);const vr={};r[1]&8&&(vr.$$scope={dirty:r,ctx:e}),ft.$set(vr);const xr={};r[1]&8&&(xr.$$scope={dirty:r,ctx:e}),at.$set(xr);const br={};r[1]&8&&(br.$$scope={dirty:r,ctx:e}),lt.$set(br);const Lr={};r[1]&8&&(Lr.$$scope={dirty:r,ctx:e}),ot.$set(Lr);const Tr={};r[1]&8&&(Tr.$$scope={dirty:r,ctx:e}),it.$set(Tr);const Er={};r[1]&8&&(Er.$$scope={dirty:r,ctx:e}),ut.$set(Er);const zr={};r[1]&8&&(zr.$$scope={dirty:r,ctx:e}),_t.$set(zr);const yr={};r[1]&8&&(yr.$$scope={dirty:r,ctx:e}),gt.$set(yr);const Ar={};r[1]&8&&(Ar.$$scope={dirty:r,ctx:e}),ht.$set(Ar);const Pr={};r[1]&8&&(Pr.$$scope={dirty:r,ctx:e}),ct.$set(Pr);const Sr={};r[1]&8&&(Sr.$$scope={dirty:r,ctx:e}),wt.$set(Sr);const kr={};r[1]&8&&(kr.$$scope={dirty:r,ctx:e}),dt.$set(kr);const Wr={};r[1]&8&&(Wr.$$scope={dirty:r,ctx:e}),vt.$set(Wr);const Vr={};r[1]&8&&(Vr.$$scope={dirty:r,ctx:e}),xt.$set(Vr);const qr={};r[1]&8&&(qr.$$scope={dirty:r,ctx:e}),bt.$set(qr);const Dr={};r[1]&8&&(Dr.$$scope={dirty:r,ctx:e}),Lt.$set(Dr);const Ir={};r[1]&8&&(Ir.$$scope={dirty:r,ctx:e}),Tt.$set(Ir);const Cr={};r[1]&8&&(Cr.$$scope={dirty:r,ctx:e}),Et.$set(Cr);const Or={};r[0]&48|r[1]&8&&(Or.$$scope={dirty:r,ctx:e}),zt.$set(Or);const Mr={};r[1]&8&&(Mr.$$scope={dirty:r,ctx:e}),At.$set(Mr);const Nr={};r[1]&8&&(Nr.$$scope={dirty:r,ctx:e}),Pt.$set(Nr);const Br={};r[1]&8&&(Br.$$scope={dirty:r,ctx:e}),St.$set(Br);const Rr={};r[1]&8&&(Rr.$$scope={dirty:r,ctx:e}),kt.$set(Rr);const jr={};r[0]&64|r[1]&8&&(jr.$$scope={dirty:r,ctx:e}),Wt.$set(jr);const Gr={};!Is&&r[0]&2&&(Is=!0,Gr.value=e[1],er(()=>Is=!1)),Ae.$set(Gr);const Ur={};r[1]&8&&(Ur.$$scope={dirty:r,ctx:e}),Vt.$set(Ur);const Hr={};r[1]&8&&(Hr.$$scope={dirty:r,ctx:e}),qt.$set(Hr);const Yr={};r[1]&8&&(Yr.$$scope={dirty:r,ctx:e}),Dt.$set(Yr);const Xr={};r[1]&8&&(Xr.$$scope={dirty:r,ctx:e}),It.$set(Xr);const Fr={};r[1]&8&&(Fr.$$scope={dirty:r,ctx:e}),Ct.$set(Fr);const Kr={};r[1]&8&&(Kr.$$scope={dirty:r,ctx:e}),Ot.$set(Kr);const Jr={};r[1]&8&&(Jr.$$scope={dirty:r,ctx:e}),Mt.$set(Jr);const Qr={};r[1]&8&&(Qr.$$scope={dirty:r,ctx:e}),Nt.$set(Qr);const Zr={};r[1]&8&&(Zr.$$scope={dirty:r,ctx:e}),Bt.$set(Zr);const ef={};r[1]&8&&(ef.$$scope={dirty:r,ctx:e}),jt.$set(ef)},i(e){P$||(g(A.$$.fragment,e),g(E.$$.fragment,e),g(b.$$.fragment,e),g(S.$$.fragment,e),g(d.$$.fragment,e),g(W.$$.fragment,e),g(O.$$.fragment,e),g(N.$$.fragment,e),g(he.$$.fragment,e),g(ce.$$.fragment,e),g(we.$$.fragment,e),g(C.$$.fragment,e),g(qe.$$.fragment,e),g(De.$$.fragment,e),g(Ie.$$.fragment,e),g(Ce.$$.fragment,e),g(Oe.$$.fragment,e),g(Me.$$.fragment,e),g(Ne.$$.fragment,e),g(Be.$$.fragment,e),g(Re.$$.fragment,e),g(je.$$.fragment,e),g(Ge.$$.fragment,e),g(Ue.$$.fragment,e),g(He.$$.fragment,e),g(Ye.$$.fragment,e),g(Xe.$$.fragment,e),g(Fe.$$.fragment,e),g(Ke.$$.fragment,e),g(Je.$$.fragment,e),g(Qe.$$.fragment,e),g(Ze.$$.fragment,e),g(et.$$.fragment,e),g(tt.$$.fragment,e),g(nt.$$.fragment,e),g(ye.$$.fragment,e),g($t.$$.fragment,e),g(st.$$.fragment,e),g(rt.$$.fragment,e),g(ft.$$.fragment,e),g(at.$$.fragment,e),g(lt.$$.fragment,e),g(ot.$$.fragment,e),g(it.$$.fragment,e),g(ut.$$.fragment,e),g(Ht.$$.fragment,e),g(_t.$$.fragment,e),g(Yt.$$.fragment,e),g(Xt.$$.fragment,e),g(Ft.$$.fragment,e),g(Kt.$$.fragment,e),g(gt.$$.fragment,e),g(ht.$$.fragment,e),g(Qt.$$.fragment,e),g(ct.$$.fragment,e),g(wt.$$.fragment,e),g(dt.$$.fragment,e),g(vt.$$.fragment,e),g(xt.$$.fragment,e),g(bt.$$.fragment,e),g(Lt.$$.fragment,e),g(Tt.$$.fragment,e),g(Et.$$.fragment,e),g(zt.$$.fragment,e),g(At.$$.fragment,e),g(Pt.$$.fragment,e),g(St.$$.fragment,e),g(kt.$$.fragment,e),g(Wt.$$.fragment,e),g(Ae.$$.fragment,e),g(Vt.$$.fragment,e),g(qt.$$.fragment,e),g(Dt.$$.fragment,e),g(It.$$.fragment,e),g(Ct.$$.fragment,e),g(Ot.$$.fragment,e),g(Mt.$$.fragment,e),g(Nt.$$.fragment,e),g(Bt.$$.fragment,e),g(jt.$$.fragment,e),g(Zt.$$.fragment,e),g(en.$$.fragment,e),g(tn.$$.fragment,e),g(nn.$$.fragment,e),g($n.$$.fragment,e),P$=!0)},o(e){h(A.$$.fragment,e),h(E.$$.fragment,e),h(b.$$.fragment,e),h(S.$$.fragment,e),h(d.$$.fragment,e),h(W.$$.fragment,e),h(O.$$.fragment,e),h(N.$$.fragment,e),h(he.$$.fragment,e),h(ce.$$.fragment,e),h(we.$$.fragment,e),h(C.$$.fragment,e),h(qe.$$.fragment,e),h(De.$$.fragment,e),h(Ie.$$.fragment,e),h(Ce.$$.fragment,e),h(Oe.$$.fragment,e),h(Me.$$.fragment,e),h(Ne.$$.fragment,e),h(Be.$$.fragment,e),h(Re.$$.fragment,e),h(je.$$.fragment,e),h(Ge.$$.fragment,e),h(Ue.$$.fragment,e),h(He.$$.fragment,e),h(Ye.$$.fragment,e),h(Xe.$$.fragment,e),h(Fe.$$.fragment,e),h(Ke.$$.fragment,e),h(Je.$$.fragment,e),h(Qe.$$.fragment,e),h(Ze.$$.fragment,e),h(et.$$.fragment,e),h(tt.$$.fragment,e),h(nt.$$.fragment,e),h(ye.$$.fragment,e),h($t.$$.fragment,e),h(st.$$.fragment,e),h(rt.$$.fragment,e),h(ft.$$.fragment,e),h(at.$$.fragment,e),h(lt.$$.fragment,e),h(ot.$$.fragment,e),h(it.$$.fragment,e),h(ut.$$.fragment,e),h(Ht.$$.fragment,e),h(_t.$$.fragment,e),h(Yt.$$.fragment,e),h(Xt.$$.fragment,e),h(Ft.$$.fragment,e),h(Kt.$$.fragment,e),h(gt.$$.fragment,e),h(ht.$$.fragment,e),h(Qt.$$.fragment,e),h(ct.$$.fragment,e),h(wt.$$.fragment,e),h(dt.$$.fragment,e),h(vt.$$.fragment,e),h(xt.$$.fragment,e),h(bt.$$.fragment,e),h(Lt.$$.fragment,e),h(Tt.$$.fragment,e),h(Et.$$.fragment,e),h(zt.$$.fragment,e),h(At.$$.fragment,e),h(Pt.$$.fragment,e),h(St.$$.fragment,e),h(kt.$$.fragment,e),h(Wt.$$.fragment,e),h(Ae.$$.fragment,e),h(Vt.$$.fragment,e),h(qt.$$.fragment,e),h(Dt.$$.fragment,e),h(It.$$.fragment,e),h(Ct.$$.fragment,e),h(Ot.$$.fragment,e),h(Mt.$$.fragment,e),h(Nt.$$.fragment,e),h(Bt.$$.fragment,e),h(jt.$$.fragment,e),h(Zt.$$.fragment,e),h(en.$$.fragment,e),h(tn.$$.fragment,e),h(nn.$$.fragment,e),h($n.$$.fragment,e),P$=!1},d(e){e&&f(n),e&&f(s),e&&f(w),c(A),c(E),c(b),c(S),c(d),c(W),c(O),c(N),e&&f(_e),e&&f($e),e&&f(se),e&&f(ge),e&&f(Ve),e&&f(ne),c(he),c(ce),c(we),e&&f(un),c(C,e),e&&f(re),e&&f(U),c(qe),c(De),c(Ie),e&&f(Vn),e&&f(Ln),e&&f(qn),e&&f(H),c(Ce),c(Oe),c(Me),c(Ne),c(Be),e&&f(Dn),c(Re,e),e&&f(In),c(je,e),e&&f(Cn),e&&f(de),c(Ge),c(Ue),e&&f(On),c(He,e),e&&f(Mn),e&&f(fe),c(Ye),c(Xe),c(Fe),e&&f(Nn),c(Ke,e),e&&f(Bn),e&&f(Y),c(Je),c(Qe),c(Ze),c(et),c(tt),e&&f(Rn),c(nt,e),e&&f(jn),c(ye,e),e&&f(Gn),e&&f(X),c($t),c(st),c(rt),c(ft),c(at),e&&f(Un),e&&f(pn),e&&f(Hn),c(lt,e),e&&f(Yn),e&&f(ve),c(ot),c(it),e&&f(Xn),e&&f(mt),c(ut),e&&f(Fn),c(Ht,e),e&&f(Kn),e&&f(pt),c(_t),e&&f(Jn),c(Yt,e),e&&f(Qn),c(Xt,e),e&&f(Zn),e&&f(_n),e&&f(e$),c(Ft,e),e&&f(t$),c(Kt,e),e&&f(n$),e&&f(Jt),e&&f($$),e&&f(ae),c(gt),c(ht),e&&f(s$),c(Qt,e),e&&f(r$),e&&f(gn),e&&f(f$),e&&f(hn),e&&f(a$),e&&f(xe),c(ct),c(wt),e&&f(l$),e&&f(cn),e&&f(o$),c(dt,e),e&&f(i$),e&&f(F),c(vt),c(xt),c(bt),c(Lt),c(Tt),e&&f(m$),c(Et,e),e&&f(u$),c(zt,e),e&&f(p$),e&&f(yt),c(At),e&&f(_$),c(Pt,e),e&&f(g$),e&&f(be),c(St),c(kt),e&&f(h$),c(Wt,e),e&&f(c$),c(Ae,e),e&&f(w$),e&&f(le),c(Vt),c(qt),c(Dt),e&&f(d$),e&&f(K),c(It),c(Ct),c(Ot),c(Mt),c(Nt),e&&f(v$),c(Bt,e),e&&f(x$),e&&f(Rt),c(jt),e&&f(b$),c(Zt,e),e&&f(L$),c(en,e),e&&f(T$),c(tn,e),e&&f(E$),c(nn,e),e&&f(z$),c($n,e),e&&f(y$),e&&f(sn),e&&f(A$),e&&f(wn)}}}function Na(a){let n,t,s,w,T,A,L,E,o;return E=new mf({props:{$$slots:{default:[Ma]},$$scope:{ctx:a}}}),{c(){n=V("meta"),t=v(),s=V("h1"),w=i("Regularization"),T=v(),A=V("div"),L=v(),u(E.$$.fragment),this.h()},l(b){const y=of("svelte-1gakgio",document.head);n=q(y,"META",{name:!0,content:!0}),y.forEach(f),t=x(b),s=q(b,"H1",{});var S=I(s);w=m(S,"Regularization"),S.forEach(f),T=x(b),A=q(b,"DIV",{class:!0}),I(A).forEach(f),L=x(b),p(E.$$.fragment,b),this.h()},h(){document.title="L1 and L2 Regularization - World4AI",Ee(n,"name","description"),Ee(n,"content","The L1 and L2 regularization techniques reduce overfitting by modifying the loss function. Both regularizers keep the size of the weights small, but the L1 loss also enforces sparsity."),Ee(A,"class","separator")},m(b,y){z(document.head,n),l(b,t,y),l(b,s,y),z(s,w),l(b,T,y),l(b,A,y),l(b,L,y),_(E,b,y),o=!0},p(b,y){const S={};y[0]&255|y[1]&8&&(S.$$scope={dirty:y,ctx:b}),E.$set(S)},i(b){o||(g(E.$$.fragment,b),o=!0)},o(b){h(E.$$.fragment,b),o=!1},d(b){f(n),b&&f(t),b&&f(s),b&&f(T),b&&f(A),b&&f(L),c(E,b)}}}function kn(a){let n=[];for(let t=0;t<=Math.PI*2;t+=.01){let s=Math.cos(t)*a,w=Math.sin(t)*a;n.push({x:s,y:w})}return n}function Wn(a=1){let n=[];for(let t=0;t<=1;t+=.1){let s=t*a,w=a-s;n.push({x:s,y:w})}for(let t=1;t>=0;t-=.1){let s=t*a,w=-(a-s);n.push({x:s,y:w})}for(let t=0;t<=1;t+=.1){let s=-t*a,w=-(a+s);n.push({x:s,y:w})}for(let t=1;t>=0;t-=.1){let s=-t*a,w=a+s;n.push({x:s,y:w})}return n}function Ba(a,n,t){let s,w,T=kn(1),A,L,E=.5;function o(){E+=.1;let C=Math.cos(E),re=Math.sin(E);t(2,A=[{x:0,y:0},{x:C,y:re}]),t(3,L=[{x:C,y:re}])}o();let b=kn(1),y=kn(2),S=kn(3),$=[];for(let C=-4;C<=4;C++){let re=C,U=3-C;$.push({x:re,y:U})}let d=.1,k=Wn(),W,D,O=0;function G(){O=O%(k.length-1);let C=k[O].x,re=k[O].y;t(5,D=[{x:C,y:re}]),t(4,W=[{x:0,y:0},...D]),O+=1}G();let N=Wn(1),R=Wn(2),_e=Wn(3),$e=[];for(let C=-4;C<=4;C++){let re=2*C,U=3-C;$e.push({x:re,y:U})}let se=.1;const ge=`LAMBDA = 0.01
def train_epoch(dataloader, model, criterion, optimizer):
    for batch_idx, (features, labels) in enumerate(train_dataloader):
        # move features and labels to GPU
        features = features.to(DEVICE)
        labels = labels.to(DEVICE)

        # ------ FORWARD PASS --------
        output = model(features)

        # ------CALCULATE LOSS --------
        loss = criterion(output, labels)
        l2 = None
        for param in model.parameters():
            if l2 is None:
                l2 = param.pow(2).sum()
            else:
                l2 += param.pow(2).sum()
        
        loss += LAMBDA * l2

        # ------BACKPROPAGATION --------
        loss.backward()

        # ------GRADIENT DESCENT --------
        optimizer.step()

        # ------CLEAR GRADIENTS --------
        optimizer.zero_grad()`,Ut=`model = Model().to(DEVICE)
criterion = nn.CrossEntropyLoss(reduction="sum")
optimizer = optim.SGD(model.parameters(), lr=0.005)`,Ve="history = train(NUM_EPOCHS, train_dataloader, val_dataloader, model, criterion, optimizer)",ne=`Epoch: 1/50|Train Loss: 0.4967 |Val Loss: 0.4781 |Train Acc: 0.8601 |Val Acc: 0.8630
Epoch: 10/50|Train Loss: 0.1641 |Val Loss: 0.1671 |Train Acc: 0.9574 |Val Acc: 0.9538
Epoch: 20/50|Train Loss: 0.1508 |Val Loss: 0.1548 |Train Acc: 0.9617 |Val Acc: 0.9595
Epoch: 30/50|Train Loss: 0.1363 |Val Loss: 0.1430 |Train Acc: 0.9660 |Val Acc: 0.9632
Epoch: 40/50|Train Loss: 0.1284 |Val Loss: 0.1369 |Train Acc: 0.9686 |Val Acc: 0.9655
Epoch: 50/50|Train Loss: 0.1300 |Val Loss: 0.1399 |Train Acc: 0.9681 |Val Acc: 0.9647
`,dn="optimizer = optim.SGD(model.parameters(), lr=0.005, weight_decay=0.001)",he=`LAMBDA = 0.01
def train_epoch(dataloader, model, criterion, optimizer):
    for batch_idx, (features, labels) in enumerate(train_dataloader):
        # move features and labels to GPU
        features = features.to(DEVICE)
        labels = labels.to(DEVICE)

        # ------ FORWARD PASS --------
        output = model(features)

        # ------CALCULATE LOSS --------
        loss = criterion(output, labels)
        l1 = None
        for param in model.parameters():
            if l1 is None:
                l1 = param.abs().sum()
            else:
                l1 += param.abs().sum()
        
        loss += LAMBDA * l1

        # ------BACKPROPAGATION --------
        loss.backward()

        # ------GRADIENT DESCENT --------
        optimizer.step()

        # ------CLEAR GRADIENTS --------
        optimizer.zero_grad()`,vn=`model = Model().to(DEVICE)
criterion = nn.CrossEntropyLoss(reduction="sum")
optimizer = optim.SGD(model.parameters(), lr=0.005)`,ce="history = train(NUM_EPOCHS, train_dataloader, val_dataloader, model, criterion, optimizer)",xn=`Epoch: 1/50|Train Loss: 1.1206 |Val Loss: 1.1060 |Train Acc: 0.6172 |Val Acc: 0.6270
Epoch: 10/50|Train Loss: 0.2200 |Val Loss: 0.2162 |Train Acc: 0.9383 |Val Acc: 0.9377
Epoch: 20/50|Train Loss: 0.2077 |Val Loss: 0.2087 |Train Acc: 0.9416 |Val Acc: 0.9405
Epoch: 30/50|Train Loss: 0.1744 |Val Loss: 0.1745 |Train Acc: 0.9507 |Val Acc: 0.9495
Epoch: 40/50|Train Loss: 0.1966 |Val Loss: 0.1966 |Train Acc: 0.9416 |Val Acc: 0.9417
Epoch: 50/50|Train Loss: 0.1604 |Val Loss: 0.1656 |Train Acc: 0.9541 |Val Acc: 0.9513
`,we="plot_history(history, 'l1_overfitting')";function bn(C){d=C,t(0,d)}function un(C){se=C,t(1,se)}return a.$$.update=()=>{a.$$.dirty[0]&1&&t(7,s=kn(d)),a.$$.dirty[0]&2&&t(6,w=Wn(se))},[d,se,A,L,W,D,w,s,T,o,b,y,S,$,k,G,N,R,_e,$e,ge,Ut,Ve,ne,dn,he,vn,ce,xn,we,bn,un]}class tl extends $f{constructor(n){super(),sf(this,n,Ba,Na,rf,{},null,[-1,-1])}}export{tl as default};
