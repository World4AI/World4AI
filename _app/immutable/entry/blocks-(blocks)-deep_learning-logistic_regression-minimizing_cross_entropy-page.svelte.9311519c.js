import{S as R$,i as G$,s as j$,k as C,a as E,q as v,y as _,W as K$,l as P,h as l,c as z,m as S,r as x,z as c,n as Ve,N as k,b as o,A as g,g as w,d,B as h,C as I,u as r$}from"../chunks/index.4d92b023.js";import{C as Q$}from"../chunks/Container.b0705c7b.js";import{L as W}from"../chunks/Latex.e0b308c0.js";import{P as U$}from"../chunks/PlayButton.85103c5a.js";import{B as Z$}from"../chunks/ButtonContainer.e9aac418.js";import{A as L$}from"../chunks/Alert.25a852b3.js";import{P as Le}from"../chunks/PythonCode.212ba7a6.js";import{B as s$}from"../chunks/BackpropGraph.6a7a3666.js";import{N as es,V as Ee}from"../chunks/Network.03de8e4c.js";import{T as V$,a as H$,b as J$,R,H as ht,D as F}from"../chunks/HeaderEntry.2b6e8f51.js";import{P as D$,T as q$}from"../chunks/Ticks.45eca5c5.js";import{X as M$,Y as Y$}from"../chunks/YLabel.182e66a3.js";import{P as ts}from"../chunks/Path.7e6df014.js";import{C as n$}from"../chunks/Circle.f281e92b.js";function $s(f){let t=String.raw`\mathbf{w}`+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function ss(f){let t;return{c(){t=v("b")},l($){t=x($,"b")},m($,e){o($,t,e)},d($){$&&l(t)}}}function ns(f){let t=String.raw`
      \text{Cross-Enropy} = L =  - \dfrac{1}{n} \sum_i \Big[y^{(i)} \log \sigma(z^{(i)}) + (1 - y^{(i)}) \log(1 - \sigma(z^{(i)})) \Big] \\
  `+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function rs(f){let t,$;return t=new W({props:{$$slots:{default:[ns]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment)},l(e){c(t.$$.fragment,e)},m(e,a){g(t,e,a),$=!0},p(e,a){const n={};a&4194304&&(n.$$scope={dirty:a,ctx:e}),t.$set(n)},i(e){$||(w(t.$$.fragment,e),$=!0)},o(e){d(t.$$.fragment,e),$=!1},d(e){h(t,e)}}}function as(f){let t,$,e,a,n,u,r,m,y,b;return t=new q$({props:{xTicks:[0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1],yTicks:[0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1],xOffset:-15,yOffset:15}}),e=new M$({props:{text:"Feature 1",fontSize:15}}),n=new Y$({props:{text:"Feature 2",fontSize:15}}),r=new n$({props:{data:f[9][0]}}),y=new n$({props:{data:f[9][1],color:"var(--main-color-2)"}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment),a=E(),_(n.$$.fragment),u=E(),_(r.$$.fragment),m=E(),_(y.$$.fragment)},l(i){c(t.$$.fragment,i),$=z(i),c(e.$$.fragment,i),a=z(i),c(n.$$.fragment,i),u=z(i),c(r.$$.fragment,i),m=z(i),c(y.$$.fragment,i)},m(i,X){g(t,i,X),o(i,$,X),g(e,i,X),o(i,a,X),g(n,i,X),o(i,u,X),g(r,i,X),o(i,m,X),g(y,i,X),b=!0},p:I,i(i){b||(w(t.$$.fragment,i),w(e.$$.fragment,i),w(n.$$.fragment,i),w(r.$$.fragment,i),w(y.$$.fragment,i),b=!0)},o(i){d(t.$$.fragment,i),d(e.$$.fragment,i),d(n.$$.fragment,i),d(r.$$.fragment,i),d(y.$$.fragment,i),b=!1},d(i){h(t,i),i&&l($),h(e,i),i&&l(a),h(n,i),i&&l(u),h(r,i),i&&l(m),h(y,i)}}}function fs(f){let t;return{c(){t=v("x_1")},l($){t=x($,"x_1")},m($,e){o($,t,e)},d($){$&&l(t)}}}function ls(f){let t,$;return t=new W({props:{$$slots:{default:[fs]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment)},l(e){c(t.$$.fragment,e)},m(e,a){g(t,e,a),$=!0},p(e,a){const n={};a&4194304&&(n.$$scope={dirty:a,ctx:e}),t.$set(n)},i(e){$||(w(t.$$.fragment,e),$=!0)},o(e){d(t.$$.fragment,e),$=!1},d(e){h(t,e)}}}function os(f){let t;return{c(){t=v("x_2")},l($){t=x($,"x_2")},m($,e){o($,t,e)},d($){$&&l(t)}}}function ps(f){let t,$;return t=new W({props:{$$slots:{default:[os]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment)},l(e){c(t.$$.fragment,e)},m(e,a){g(t,e,a),$=!0},p(e,a){const n={};a&4194304&&(n.$$scope={dirty:a,ctx:e}),t.$set(n)},i(e){$||(w(t.$$.fragment,e),$=!0)},o(e){d(t.$$.fragment,e),$=!1},d(e){h(t,e)}}}function ms(f){let t;return{c(){t=v("y")},l($){t=x($,"y")},m($,e){o($,t,e)},d($){$&&l(t)}}}function is(f){let t,$;return t=new W({props:{$$slots:{default:[ms]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment)},l(e){c(t.$$.fragment,e)},m(e,a){g(t,e,a),$=!0},p(e,a){const n={};a&4194304&&(n.$$scope={dirty:a,ctx:e}),t.$set(n)},i(e){$||(w(t.$$.fragment,e),$=!0)},o(e){d(t.$$.fragment,e),$=!1},d(e){h(t,e)}}}function us(f){let t,$,e,a,n,u;return t=new ht({props:{$$slots:{default:[ls]},$$scope:{ctx:f}}}),e=new ht({props:{$$slots:{default:[ps]},$$scope:{ctx:f}}}),n=new ht({props:{$$slots:{default:[is]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment),a=E(),_(n.$$.fragment)},l(r){c(t.$$.fragment,r),$=z(r),c(e.$$.fragment,r),a=z(r),c(n.$$.fragment,r)},m(r,m){g(t,r,m),o(r,$,m),g(e,r,m),o(r,a,m),g(n,r,m),u=!0},p(r,m){const y={};m&4194304&&(y.$$scope={dirty:m,ctx:r}),t.$set(y);const b={};m&4194304&&(b.$$scope={dirty:m,ctx:r}),e.$set(b);const i={};m&4194304&&(i.$$scope={dirty:m,ctx:r}),n.$set(i)},i(r){u||(w(t.$$.fragment,r),w(e.$$.fragment,r),w(n.$$.fragment,r),u=!0)},o(r){d(t.$$.fragment,r),d(e.$$.fragment,r),d(n.$$.fragment,r),u=!1},d(r){h(t,r),r&&l($),h(e,r),r&&l(a),h(n,r)}}}function _s(f){let t,$;return t=new R({props:{$$slots:{default:[us]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment)},l(e){c(t.$$.fragment,e)},m(e,a){g(t,e,a),$=!0},p(e,a){const n={};a&4194304&&(n.$$scope={dirty:a,ctx:e}),t.$set(n)},i(e){$||(w(t.$$.fragment,e),$=!0)},o(e){d(t.$$.fragment,e),$=!1},d(e){h(t,e)}}}function cs(f){let t=f[9][0][0].x+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function gs(f){let t=f[9][0][0].y+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function ws(f){let t="0",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function ds(f){let t,$,e,a,n,u;return t=new F({props:{$$slots:{default:[cs]},$$scope:{ctx:f}}}),e=new F({props:{$$slots:{default:[gs]},$$scope:{ctx:f}}}),n=new F({props:{$$slots:{default:[ws]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment),a=E(),_(n.$$.fragment)},l(r){c(t.$$.fragment,r),$=z(r),c(e.$$.fragment,r),a=z(r),c(n.$$.fragment,r)},m(r,m){g(t,r,m),o(r,$,m),g(e,r,m),o(r,a,m),g(n,r,m),u=!0},p(r,m){const y={};m&4194304&&(y.$$scope={dirty:m,ctx:r}),t.$set(y);const b={};m&4194304&&(b.$$scope={dirty:m,ctx:r}),e.$set(b);const i={};m&4194304&&(i.$$scope={dirty:m,ctx:r}),n.$set(i)},i(r){u||(w(t.$$.fragment,r),w(e.$$.fragment,r),w(n.$$.fragment,r),u=!0)},o(r){d(t.$$.fragment,r),d(e.$$.fragment,r),d(n.$$.fragment,r),u=!1},d(r){h(t,r),r&&l($),h(e,r),r&&l(a),h(n,r)}}}function hs(f){let t=f[9][0][1].x+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function ys(f){let t=f[9][0][1].y+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function bs(f){let t="0",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function vs(f){let t,$,e,a,n,u;return t=new F({props:{$$slots:{default:[hs]},$$scope:{ctx:f}}}),e=new F({props:{$$slots:{default:[ys]},$$scope:{ctx:f}}}),n=new F({props:{$$slots:{default:[bs]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment),a=E(),_(n.$$.fragment)},l(r){c(t.$$.fragment,r),$=z(r),c(e.$$.fragment,r),a=z(r),c(n.$$.fragment,r)},m(r,m){g(t,r,m),o(r,$,m),g(e,r,m),o(r,a,m),g(n,r,m),u=!0},p(r,m){const y={};m&4194304&&(y.$$scope={dirty:m,ctx:r}),t.$set(y);const b={};m&4194304&&(b.$$scope={dirty:m,ctx:r}),e.$set(b);const i={};m&4194304&&(i.$$scope={dirty:m,ctx:r}),n.$set(i)},i(r){u||(w(t.$$.fragment,r),w(e.$$.fragment,r),w(n.$$.fragment,r),u=!0)},o(r){d(t.$$.fragment,r),d(e.$$.fragment,r),d(n.$$.fragment,r),u=!1},d(r){h(t,r),r&&l($),h(e,r),r&&l(a),h(n,r)}}}function xs(f){let t;return{c(){t=v("...")},l($){t=x($,"...")},m($,e){o($,t,e)},d($){$&&l(t)}}}function Es(f){let t;return{c(){t=v("...")},l($){t=x($,"...")},m($,e){o($,t,e)},d($){$&&l(t)}}}function zs(f){let t;return{c(){t=v("...")},l($){t=x($,"...")},m($,e){o($,t,e)},d($){$&&l(t)}}}function Ts(f){let t,$,e,a,n,u;return t=new F({props:{$$slots:{default:[xs]},$$scope:{ctx:f}}}),e=new F({props:{$$slots:{default:[Es]},$$scope:{ctx:f}}}),n=new F({props:{$$slots:{default:[zs]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment),a=E(),_(n.$$.fragment)},l(r){c(t.$$.fragment,r),$=z(r),c(e.$$.fragment,r),a=z(r),c(n.$$.fragment,r)},m(r,m){g(t,r,m),o(r,$,m),g(e,r,m),o(r,a,m),g(n,r,m),u=!0},p(r,m){const y={};m&4194304&&(y.$$scope={dirty:m,ctx:r}),t.$set(y);const b={};m&4194304&&(b.$$scope={dirty:m,ctx:r}),e.$set(b);const i={};m&4194304&&(i.$$scope={dirty:m,ctx:r}),n.$set(i)},i(r){u||(w(t.$$.fragment,r),w(e.$$.fragment,r),w(n.$$.fragment,r),u=!0)},o(r){d(t.$$.fragment,r),d(e.$$.fragment,r),d(n.$$.fragment,r),u=!1},d(r){h(t,r),r&&l($),h(e,r),r&&l(a),h(n,r)}}}function Xs(f){let t=f[9][1][1].x+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function ks(f){let t=f[9][1][1].y+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function Cs(f){let t="1",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function Ps(f){let t,$,e,a,n,u;return t=new F({props:{$$slots:{default:[Xs]},$$scope:{ctx:f}}}),e=new F({props:{$$slots:{default:[ks]},$$scope:{ctx:f}}}),n=new F({props:{$$slots:{default:[Cs]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment),a=E(),_(n.$$.fragment)},l(r){c(t.$$.fragment,r),$=z(r),c(e.$$.fragment,r),a=z(r),c(n.$$.fragment,r)},m(r,m){g(t,r,m),o(r,$,m),g(e,r,m),o(r,a,m),g(n,r,m),u=!0},p(r,m){const y={};m&4194304&&(y.$$scope={dirty:m,ctx:r}),t.$set(y);const b={};m&4194304&&(b.$$scope={dirty:m,ctx:r}),e.$set(b);const i={};m&4194304&&(i.$$scope={dirty:m,ctx:r}),n.$set(i)},i(r){u||(w(t.$$.fragment,r),w(e.$$.fragment,r),w(n.$$.fragment,r),u=!0)},o(r){d(t.$$.fragment,r),d(e.$$.fragment,r),d(n.$$.fragment,r),u=!1},d(r){h(t,r),r&&l($),h(e,r),r&&l(a),h(n,r)}}}function Ss(f){let t=f[9][1][0].x+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function Ws(f){let t=f[9][1][0].y+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function Bs(f){let t="1",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function Is(f){let t,$,e,a,n,u;return t=new F({props:{$$slots:{default:[Ss]},$$scope:{ctx:f}}}),e=new F({props:{$$slots:{default:[Ws]},$$scope:{ctx:f}}}),n=new F({props:{$$slots:{default:[Bs]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment),a=E(),_(n.$$.fragment)},l(r){c(t.$$.fragment,r),$=z(r),c(e.$$.fragment,r),a=z(r),c(n.$$.fragment,r)},m(r,m){g(t,r,m),o(r,$,m),g(e,r,m),o(r,a,m),g(n,r,m),u=!0},p(r,m){const y={};m&4194304&&(y.$$scope={dirty:m,ctx:r}),t.$set(y);const b={};m&4194304&&(b.$$scope={dirty:m,ctx:r}),e.$set(b);const i={};m&4194304&&(i.$$scope={dirty:m,ctx:r}),n.$set(i)},i(r){u||(w(t.$$.fragment,r),w(e.$$.fragment,r),w(n.$$.fragment,r),u=!0)},o(r){d(t.$$.fragment,r),d(e.$$.fragment,r),d(n.$$.fragment,r),u=!1},d(r){h(t,r),r&&l($),h(e,r),r&&l(a),h(n,r)}}}function Fs(f){let t,$,e,a,n,u,r,m,y,b;return t=new R({props:{$$slots:{default:[ds]},$$scope:{ctx:f}}}),e=new R({props:{$$slots:{default:[vs]},$$scope:{ctx:f}}}),n=new R({props:{$$slots:{default:[Ts]},$$scope:{ctx:f}}}),r=new R({props:{$$slots:{default:[Ps]},$$scope:{ctx:f}}}),y=new R({props:{$$slots:{default:[Is]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment),a=E(),_(n.$$.fragment),u=E(),_(r.$$.fragment),m=E(),_(y.$$.fragment)},l(i){c(t.$$.fragment,i),$=z(i),c(e.$$.fragment,i),a=z(i),c(n.$$.fragment,i),u=z(i),c(r.$$.fragment,i),m=z(i),c(y.$$.fragment,i)},m(i,X){g(t,i,X),o(i,$,X),g(e,i,X),o(i,a,X),g(n,i,X),o(i,u,X),g(r,i,X),o(i,m,X),g(y,i,X),b=!0},p(i,X){const T={};X&4194304&&(T.$$scope={dirty:X,ctx:i}),t.$set(T);const B={};X&4194304&&(B.$$scope={dirty:X,ctx:i}),e.$set(B);const V={};X&4194304&&(V.$$scope={dirty:X,ctx:i}),n.$set(V);const A={};X&4194304&&(A.$$scope={dirty:X,ctx:i}),r.$set(A);const Q={};X&4194304&&(Q.$$scope={dirty:X,ctx:i}),y.$set(Q)},i(i){b||(w(t.$$.fragment,i),w(e.$$.fragment,i),w(n.$$.fragment,i),w(r.$$.fragment,i),w(y.$$.fragment,i),b=!0)},o(i){d(t.$$.fragment,i),d(e.$$.fragment,i),d(n.$$.fragment,i),d(r.$$.fragment,i),d(y.$$.fragment,i),b=!1},d(i){h(t,i),i&&l($),h(e,i),i&&l(a),h(n,i),i&&l(u),h(r,i),i&&l(m),h(y,i)}}}function Ns(f){let t,$,e,a;return t=new H$({props:{$$slots:{default:[_s]},$$scope:{ctx:f}}}),e=new J$({props:{$$slots:{default:[Fs]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment)},l(n){c(t.$$.fragment,n),$=z(n),c(e.$$.fragment,n)},m(n,u){g(t,n,u),o(n,$,u),g(e,n,u),a=!0},p(n,u){const r={};u&4194304&&(r.$$scope={dirty:u,ctx:n}),t.$set(r);const m={};u&4194304&&(m.$$scope={dirty:u,ctx:n}),e.$set(m)},i(n){a||(w(t.$$.fragment,n),w(e.$$.fragment,n),a=!0)},o(n){d(t.$$.fragment,n),d(e.$$.fragment,n),a=!1},d(n){h(t,n),n&&l($),h(e,n)}}}function Os(f){let t;return{c(){t=v("s_1")},l($){t=x($,"s_1")},m($,e){o($,t,e)},d($){$&&l(t)}}}function As(f){let t;return{c(){t=v("s_2")},l($){t=x($,"s_2")},m($,e){o($,t,e)},d($){$&&l(t)}}}function Ls(f){let t;return{c(){t=v("s_1 = w_1 x_1 \\\\ s_2 = w_1 x_1")},l($){t=x($,"s_1 = w_1 x_1 \\\\ s_2 = w_1 x_1")},m($,e){o($,t,e)},d($){$&&l(t)}}}function Vs(f){let t;return{c(){t=v("z")},l($){t=x($,"z")},m($,e){o($,t,e)},d($){$&&l(t)}}}function Ds(f){let t=String.raw`z = s_1 + s_2 + b`+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function Hs(f){let t=String.raw`\dfrac{1}{1 + e^{-z}}`+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function Js(f){let t;return{c(){t=v("a")},l($){t=x($,"a")},m($,e){o($,t,e)},d($){$&&l(t)}}}function qs(f){let t=String.raw`
      L =  -\Big[y \log a + (1 - y) \log(1 - a) \Big]
  `+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function Ms(f){let t;return{c(){t=v("y")},l($){t=x($,"y")},m($,e){o($,t,e)},d($){$&&l(t)}}}function Ys(f){let t;return{c(){t=v("-\\log (a)")},l($){t=x($,"-\\log (a)")},m($,e){o($,t,e)},d($){$&&l(t)}}}function Rs(f){let t;return{c(){t=v("-\\log(1 - a)")},l($){t=x($,"-\\log(1 - a)")},m($,e){o($,t,e)},d($){$&&l(t)}}}function Gs(f){let t=String.raw`\sigma(z) = \dfrac{1}{1 + e^{-z}}`+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function js(f){let t;return{c(){t=v("z")},l($){t=x($,"z")},m($,e){o($,t,e)},d($){$&&l(t)}}}function Ks(f){let t=String.raw`\dfrac{\partial}{\partial z}\sigma = \sigma(z) (1 - \sigma(z)) `+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function Qs(f){let t=String.raw`
    \begin{aligned}
    \dfrac{\partial}{\partial z}\sigma &= \dfrac{\partial}{\partial z} \dfrac{1}{1 + e^{-z}} \\
    &= \dfrac{\partial}{\partial z} ({1 + e^{-z}})^{-1} \\
    &= -({1 + e^{-z}})^{-2} * -e^{-z} \\
    &= \dfrac{ e^{-z}}{({1 + e^{-z}})^{-2}} \\
    &= \dfrac{1}{{1 + e^{-z}}} \dfrac{ e^{-z}}{{1 + e^{-z}}} \\
    &= \dfrac{1}{{1 + e^{-z}}} \dfrac{ 1 + e^{-z} - 1}{{1 + e^{-z}}} \\
    &= \dfrac{1}{{1 + e^{-z}}} \Big(\dfrac{ 1 + e^{-z}}{1 + e^{-z}} - \dfrac{1}{{1 + e^{-z}}}\Big) \\
    &= \dfrac{1}{{1 + e^{-z}}} \Big(1 - \dfrac{1}{{1 + e^{-z}}}\Big) \\
    &= \sigma(z) (1 - \sigma(z)) 
    \end{aligned}
    `+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function Us(f){let t,$;return t=new W({props:{$$slots:{default:[Qs]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment)},l(e){c(t.$$.fragment,e)},m(e,a){g(t,e,a),$=!0},p(e,a){const n={};a&4194304&&(n.$$scope={dirty:a,ctx:e}),t.$set(n)},i(e){$||(w(t.$$.fragment,e),$=!0)},o(e){d(t.$$.fragment,e),$=!1},d(e){h(t,e)}}}function Zs(f){let t=String.raw`
      L =  - \dfrac{1}{n} \sum_i \Big[y^{(i)} \log \sigma(z^{(i)}) + (1 - y^{(i)}) \log(1 - \sigma(z^{(i)})) \Big] \\
  `+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function en(f){let t=String.raw`\dfrac{1}{n}`+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p:I,d(e){e&&l($)}}}function tn(f){let t,$;return t=new U$({props:{f:f[10],delta:100}}),{c(){_(t.$$.fragment)},l(e){c(t.$$.fragment,e)},m(e,a){g(t,e,a),$=!0},p:I,i(e){$||(w(t.$$.fragment,e),$=!0)},o(e){d(t.$$.fragment,e),$=!1},d(e){h(t,e)}}}function $n(f){let t;return{c(){t=v("Variable")},l($){t=x($,"Variable")},m($,e){o($,t,e)},d($){$&&l(t)}}}function sn(f){let t;return{c(){t=v("Value")},l($){t=x($,"Value")},m($,e){o($,t,e)},d($){$&&l(t)}}}function nn(f){let t,$,e,a;return t=new ht({props:{$$slots:{default:[$n]},$$scope:{ctx:f}}}),e=new ht({props:{$$slots:{default:[sn]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment)},l(n){c(t.$$.fragment,n),$=z(n),c(e.$$.fragment,n)},m(n,u){g(t,n,u),o(n,$,u),g(e,n,u),a=!0},p(n,u){const r={};u&4194304&&(r.$$scope={dirty:u,ctx:n}),t.$set(r);const m={};u&4194304&&(m.$$scope={dirty:u,ctx:n}),e.$set(m)},i(n){a||(w(t.$$.fragment,n),w(e.$$.fragment,n),a=!0)},o(n){d(t.$$.fragment,n),d(e.$$.fragment,n),a=!1},d(n){h(t,n),n&&l($),h(e,n)}}}function rn(f){let t,$;return t=new R({props:{$$slots:{default:[nn]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment)},l(e){c(t.$$.fragment,e)},m(e,a){g(t,e,a),$=!0},p(e,a){const n={};a&4194304&&(n.$$scope={dirty:a,ctx:e}),t.$set(n)},i(e){$||(w(t.$$.fragment,e),$=!0)},o(e){d(t.$$.fragment,e),$=!1},d(e){h(t,e)}}}function an(f){let t;return{c(){t=v("L")},l($){t=x($,"L")},m($,e){o($,t,e)},d($){$&&l(t)}}}function fn(f){let t,$;return t=new W({props:{$$slots:{default:[an]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment)},l(e){c(t.$$.fragment,e)},m(e,a){g(t,e,a),$=!0},p(e,a){const n={};a&4194304&&(n.$$scope={dirty:a,ctx:e}),t.$set(n)},i(e){$||(w(t.$$.fragment,e),$=!0)},o(e){d(t.$$.fragment,e),$=!1},d(e){h(t,e)}}}function ln(f){let t=f[3].toFixed(2)+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p(e,a){a&8&&t!==(t=e[3].toFixed(2)+"")&&r$($,t)},d(e){e&&l($)}}}function on(f){let t,$,e,a;return t=new F({props:{$$slots:{default:[fn]},$$scope:{ctx:f}}}),e=new F({props:{$$slots:{default:[ln]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment)},l(n){c(t.$$.fragment,n),$=z(n),c(e.$$.fragment,n)},m(n,u){g(t,n,u),o(n,$,u),g(e,n,u),a=!0},p(n,u){const r={};u&4194304&&(r.$$scope={dirty:u,ctx:n}),t.$set(r);const m={};u&4194312&&(m.$$scope={dirty:u,ctx:n}),e.$set(m)},i(n){a||(w(t.$$.fragment,n),w(e.$$.fragment,n),a=!0)},o(n){d(t.$$.fragment,n),d(e.$$.fragment,n),a=!1},d(n){h(t,n),n&&l($),h(e,n)}}}function pn(f){let t;return{c(){t=v("w_1")},l($){t=x($,"w_1")},m($,e){o($,t,e)},d($){$&&l(t)}}}function mn(f){let t,$;return t=new W({props:{$$slots:{default:[pn]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment)},l(e){c(t.$$.fragment,e)},m(e,a){g(t,e,a),$=!0},p(e,a){const n={};a&4194304&&(n.$$scope={dirty:a,ctx:e}),t.$set(n)},i(e){$||(w(t.$$.fragment,e),$=!0)},o(e){d(t.$$.fragment,e),$=!1},d(e){h(t,e)}}}function un(f){let t=f[1].toFixed(2)+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p(e,a){a&2&&t!==(t=e[1].toFixed(2)+"")&&r$($,t)},d(e){e&&l($)}}}function _n(f){let t,$,e,a;return t=new F({props:{$$slots:{default:[mn]},$$scope:{ctx:f}}}),e=new F({props:{$$slots:{default:[un]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment)},l(n){c(t.$$.fragment,n),$=z(n),c(e.$$.fragment,n)},m(n,u){g(t,n,u),o(n,$,u),g(e,n,u),a=!0},p(n,u){const r={};u&4194304&&(r.$$scope={dirty:u,ctx:n}),t.$set(r);const m={};u&4194306&&(m.$$scope={dirty:u,ctx:n}),e.$set(m)},i(n){a||(w(t.$$.fragment,n),w(e.$$.fragment,n),a=!0)},o(n){d(t.$$.fragment,n),d(e.$$.fragment,n),a=!1},d(n){h(t,n),n&&l($),h(e,n)}}}function cn(f){let t;return{c(){t=v("w_2")},l($){t=x($,"w_2")},m($,e){o($,t,e)},d($){$&&l(t)}}}function gn(f){let t,$;return t=new W({props:{$$slots:{default:[cn]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment)},l(e){c(t.$$.fragment,e)},m(e,a){g(t,e,a),$=!0},p(e,a){const n={};a&4194304&&(n.$$scope={dirty:a,ctx:e}),t.$set(n)},i(e){$||(w(t.$$.fragment,e),$=!0)},o(e){d(t.$$.fragment,e),$=!1},d(e){h(t,e)}}}function wn(f){let t=f[0].toFixed(2)+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p(e,a){a&1&&t!==(t=e[0].toFixed(2)+"")&&r$($,t)},d(e){e&&l($)}}}function dn(f){let t,$,e,a;return t=new F({props:{$$slots:{default:[gn]},$$scope:{ctx:f}}}),e=new F({props:{$$slots:{default:[wn]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment)},l(n){c(t.$$.fragment,n),$=z(n),c(e.$$.fragment,n)},m(n,u){g(t,n,u),o(n,$,u),g(e,n,u),a=!0},p(n,u){const r={};u&4194304&&(r.$$scope={dirty:u,ctx:n}),t.$set(r);const m={};u&4194305&&(m.$$scope={dirty:u,ctx:n}),e.$set(m)},i(n){a||(w(t.$$.fragment,n),w(e.$$.fragment,n),a=!0)},o(n){d(t.$$.fragment,n),d(e.$$.fragment,n),a=!1},d(n){h(t,n),n&&l($),h(e,n)}}}function hn(f){let t;return{c(){t=v("b")},l($){t=x($,"b")},m($,e){o($,t,e)},d($){$&&l(t)}}}function yn(f){let t,$;return t=new W({props:{$$slots:{default:[hn]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment)},l(e){c(t.$$.fragment,e)},m(e,a){g(t,e,a),$=!0},p(e,a){const n={};a&4194304&&(n.$$scope={dirty:a,ctx:e}),t.$set(n)},i(e){$||(w(t.$$.fragment,e),$=!0)},o(e){d(t.$$.fragment,e),$=!1},d(e){h(t,e)}}}function bn(f){let t=f[2].toFixed(2)+"",$;return{c(){$=v(t)},l(e){$=x(e,t)},m(e,a){o(e,$,a)},p(e,a){a&4&&t!==(t=e[2].toFixed(2)+"")&&r$($,t)},d(e){e&&l($)}}}function vn(f){let t,$,e,a;return t=new F({props:{$$slots:{default:[yn]},$$scope:{ctx:f}}}),e=new F({props:{$$slots:{default:[bn]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment)},l(n){c(t.$$.fragment,n),$=z(n),c(e.$$.fragment,n)},m(n,u){g(t,n,u),o(n,$,u),g(e,n,u),a=!0},p(n,u){const r={};u&4194304&&(r.$$scope={dirty:u,ctx:n}),t.$set(r);const m={};u&4194308&&(m.$$scope={dirty:u,ctx:n}),e.$set(m)},i(n){a||(w(t.$$.fragment,n),w(e.$$.fragment,n),a=!0)},o(n){d(t.$$.fragment,n),d(e.$$.fragment,n),a=!1},d(n){h(t,n),n&&l($),h(e,n)}}}function xn(f){let t,$,e,a,n,u,r,m;return t=new R({props:{$$slots:{default:[on]},$$scope:{ctx:f}}}),e=new R({props:{$$slots:{default:[_n]},$$scope:{ctx:f}}}),n=new R({props:{$$slots:{default:[dn]},$$scope:{ctx:f}}}),r=new R({props:{$$slots:{default:[vn]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment),a=E(),_(n.$$.fragment),u=E(),_(r.$$.fragment)},l(y){c(t.$$.fragment,y),$=z(y),c(e.$$.fragment,y),a=z(y),c(n.$$.fragment,y),u=z(y),c(r.$$.fragment,y)},m(y,b){g(t,y,b),o(y,$,b),g(e,y,b),o(y,a,b),g(n,y,b),o(y,u,b),g(r,y,b),m=!0},p(y,b){const i={};b&4194312&&(i.$$scope={dirty:b,ctx:y}),t.$set(i);const X={};b&4194306&&(X.$$scope={dirty:b,ctx:y}),e.$set(X);const T={};b&4194305&&(T.$$scope={dirty:b,ctx:y}),n.$set(T);const B={};b&4194308&&(B.$$scope={dirty:b,ctx:y}),r.$set(B)},i(y){m||(w(t.$$.fragment,y),w(e.$$.fragment,y),w(n.$$.fragment,y),w(r.$$.fragment,y),m=!0)},o(y){d(t.$$.fragment,y),d(e.$$.fragment,y),d(n.$$.fragment,y),d(r.$$.fragment,y),m=!1},d(y){h(t,y),y&&l($),h(e,y),y&&l(a),h(n,y),y&&l(u),h(r,y)}}}function En(f){let t,$,e,a;return t=new H$({props:{$$slots:{default:[rn]},$$scope:{ctx:f}}}),e=new J$({props:{$$slots:{default:[xn]},$$scope:{ctx:f}}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment)},l(n){c(t.$$.fragment,n),$=z(n),c(e.$$.fragment,n)},m(n,u){g(t,n,u),o(n,$,u),g(e,n,u),a=!0},p(n,u){const r={};u&4194304&&(r.$$scope={dirty:u,ctx:n}),t.$set(r);const m={};u&4194319&&(m.$$scope={dirty:u,ctx:n}),e.$set(m)},i(n){a||(w(t.$$.fragment,n),w(e.$$.fragment,n),a=!0)},o(n){d(t.$$.fragment,n),d(e.$$.fragment,n),a=!1},d(n){h(t,n),n&&l($),h(e,n)}}}function zn(f){let t,$,e,a,n,u,r,m,y,b,i,X;return t=new q$({props:{xTicks:[0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1],yTicks:[0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1],xOffset:-15,yOffset:15}}),e=new M$({props:{text:"Feature 1",fontSize:15}}),n=new Y$({props:{text:"Feature 2",fontSize:15}}),r=new ts({props:{data:f[4]}}),y=new n$({props:{data:f[9][0]}}),i=new n$({props:{data:f[9][1],color:"var(--main-color-2)"}}),{c(){_(t.$$.fragment),$=E(),_(e.$$.fragment),a=E(),_(n.$$.fragment),u=E(),_(r.$$.fragment),m=E(),_(y.$$.fragment),b=E(),_(i.$$.fragment)},l(T){c(t.$$.fragment,T),$=z(T),c(e.$$.fragment,T),a=z(T),c(n.$$.fragment,T),u=z(T),c(r.$$.fragment,T),m=z(T),c(y.$$.fragment,T),b=z(T),c(i.$$.fragment,T)},m(T,B){g(t,T,B),o(T,$,B),g(e,T,B),o(T,a,B),g(n,T,B),o(T,u,B),g(r,T,B),o(T,m,B),g(y,T,B),o(T,b,B),g(i,T,B),X=!0},p(T,B){const V={};B&16&&(V.data=T[4]),r.$set(V)},i(T){X||(w(t.$$.fragment,T),w(e.$$.fragment,T),w(n.$$.fragment,T),w(r.$$.fragment,T),w(y.$$.fragment,T),w(i.$$.fragment,T),X=!0)},o(T){d(t.$$.fragment,T),d(e.$$.fragment,T),d(n.$$.fragment,T),d(r.$$.fragment,T),d(y.$$.fragment,T),d(i.$$.fragment,T),X=!1},d(T){h(t,T),T&&l($),h(e,T),T&&l(a),h(n,T),T&&l(u),h(r,T),T&&l(m),h(y,T),T&&l(b),h(i,T)}}}function Tn(f){let t,$,e,a,n,u,r,m,y,b,i,X,T,B,V,A,Q,te,tt,De,G,He,J,$t,N,q,O,$e,ze,Y,Te,M,Xe,D,a$,yt,se,bt,Je,f$,vt,ne,xt,j,l$,re,o$,ae,p$,Et,fe,zt,L,m$,le,i$,oe,u$,pe,_$,me,c$,Tt,ie,Xt,qe,g$,kt,st,Ct,K,w$,ue,d$,_e,h$,Pt,ke,ce,St,Me,y$,Wt,ge,Bt,Ye,b$,It,we,Ft,Re,v$,Nt,de,Ot,he,x$,ye,E$,At,Ge,z$,Lt,be,Vt,ve,Dt,xe,Ht,je,T$,Jt,Ke,qt,Qe,X$,Mt,Ce,Yt,Pe,Rt,Se,Gt,We,jt,Ue,k$,Kt,Be,Qt,Ie,Ut,Ze,C$,Zt,Fe,e$,Ne,P$,t$,et,$$;return e=new W({props:{$$slots:{default:[$s]},$$scope:{ctx:f}}}),n=new W({props:{$$slots:{default:[ss]},$$scope:{ctx:f}}}),m=new L$({props:{type:"info",$$slots:{default:[rs]},$$scope:{ctx:f}}}),A=new D$({props:{width:500,height:250,maxWidth:800,domain:[0,1],range:[0,1],padding:{top:10,right:10,bottom:40,left:40},$$slots:{default:[as]},$$scope:{ctx:f}}}),G=new V$({props:{$$slots:{default:[Ns]},$$scope:{ctx:f}}}),N=new W({props:{$$slots:{default:[Os]},$$scope:{ctx:f}}}),O=new W({props:{$$slots:{default:[As]},$$scope:{ctx:f}}}),Y=new W({props:{$$slots:{default:[Ls]},$$scope:{ctx:f}}}),D=new W({props:{$$slots:{default:[Vs]},$$scope:{ctx:f}}}),se=new W({props:{$$slots:{default:[Ds]},$$scope:{ctx:f}}}),ne=new s$({props:{graph:f[5],maxWidth:450,height:710,width:600}}),re=new W({props:{$$slots:{default:[Hs]},$$scope:{ctx:f}}}),ae=new W({props:{$$slots:{default:[Js]},$$scope:{ctx:f}}}),fe=new s$({props:{graph:f[6],maxWidth:450,height:910,width:600}}),le=new W({props:{$$slots:{default:[qs]},$$scope:{ctx:f}}}),oe=new W({props:{$$slots:{default:[Ms]},$$scope:{ctx:f}}}),pe=new W({props:{$$slots:{default:[Ys]},$$scope:{ctx:f}}}),me=new W({props:{$$slots:{default:[Rs]},$$scope:{ctx:f}}}),ie=new s$({props:{graph:f[7],maxWidth:450,height:1300,width:600}}),ue=new W({props:{$$slots:{default:[Gs]},$$scope:{ctx:f}}}),_e=new W({props:{$$slots:{default:[js]},$$scope:{ctx:f}}}),ce=new W({props:{$$slots:{default:[Ks]},$$scope:{ctx:f}}}),ge=new L$({props:{type:"info",$$slots:{default:[Us]},$$scope:{ctx:f}}}),we=new s$({props:{graph:f[8],maxWidth:450,height:1300,width:600}}),de=new W({props:{$$slots:{default:[Zs]},$$scope:{ctx:f}}}),ye=new W({props:{$$slots:{default:[en]},$$scope:{ctx:f}}}),be=new Z$({props:{$$slots:{default:[tn]},$$scope:{ctx:f}}}),ve=new V$({props:{$$slots:{default:[En]},$$scope:{ctx:f}}}),xe=new D$({props:{padding:{top:10,right:10,bottom:40,left:40},width:500,height:250,maxWidth:800,domain:[0,1],range:[0,1],$$slots:{default:[zn]},$$scope:{ctx:f}}}),Ce=new Le({props:{code:f[11]}}),Pe=new Le({props:{code:f[12]}}),Se=new Le({props:{code:f[13]}}),We=new Le({props:{code:f[14]}}),Be=new Le({props:{code:f[15]}}),Ie=new Le({props:{code:f[16]}}),Fe=new Le({props:{code:f[17]}}),{c(){t=C("p"),$=v("We finally have the means to find the weight vector "),_(e.$$.fragment),a=v(` and the bias
    `),_(n.$$.fragment),u=v(` that minimize the binary cross-entropy loss, so let's see how
    we can accomplish this goal.`),r=E(),_(m.$$.fragment),y=E(),b=C("p"),i=v(`The cross-entropy loss is a relatively complex composite function with many
    moving parts, but if we focus on the atomic componets of the function and
    construct a computational graph, as we did for linear regression, we can
    utilize the chain rule and the calculation of gradients becomes relatively
    straightforward.`),X=E(),T=C("p"),B=v(`In this sec1ion we will try to find the optimal weights and bias that define
    the decision boundary between the two categories in the plot below.`),V=E(),_(A.$$.fragment),Q=E(),te=C("p"),tt=v(`The dataset consists of two features, so we start to build our computational
    graph by multiplying each of the features by a corresponding vector.`),De=E(),_(G.$$.fragment),He=E(),J=C("p"),$t=v("We call the two scaled values "),_(N.$$.fragment),q=v(" and "),_(O.$$.fragment),$e=v(` respectively
    and add them together.`),ze=E(),_(Y.$$.fragment),Te=E(),M=C("p"),Xe=v("We sum the two scaled values and add the bias to get the net input "),_(D.$$.fragment),a$=v("."),yt=E(),_(se.$$.fragment),bt=E(),Je=C("p"),f$=v(`Assuming that the features of the sample are 0.75 and 0.89 respectively, the
    weights are 0.5 and -0.5 respectively and the bias is 1, we get the
    following computational graph so far.`),vt=E(),_(ne.$$.fragment),xt=E(),j=C("p"),l$=v(`In the next step the net input is used as an input into the sigmoid function
    `),_(re.$$.fragment),o$=v(" to get the output "),_(ae.$$.fragment),p$=v("."),Et=E(),_(fe.$$.fragment),zt=E(),L=C("p"),m$=v(`Next we use the output of the sigmoid as an input to the cross-entropy loss.
    When you look at the (single sample) loss function
    `),_(le.$$.fragment),i$=v(`
    , you will notice that the loss is dependent on the label `),_(oe.$$.fragment),u$=v(`.
    If the label is 1, the loss collapses to `),_(pe.$$.fragment),_$=v(` and if the
    label is 0 the loss collapses to `),_(me.$$.fragment),c$=v(`. The sample
    that we have been looking so far corresponds to a label of 1, so our
    computational graph looks as follows.`),Tt=E(),_(ie.$$.fragment),Xt=E(),qe=C("p"),g$=v(`When we deal with batch or mini-batch gradient descent, we would do the same
    exercise for many other samples and our computational graph would get
    additional nodes. But let's keep the computation simple and assume that we
    are dealing with stochastic gradient descent and would like to calculate the
    gradients using a single sample. The procedure is obviously the same that we
    used with linear regression. We start at the top node and keep calculating
    the intermediary gradients until we reach the weiths and the bias. Along the
    way we multiply the local gradients by the gradients from the above nodes.`),kt=E(),st=C("p"),Ct=E(),K=C("p"),w$=v(`You should be already familiar with basic differentiation rules. The only
    difficulty you might face is the derivative of the sigmoid function
    `),_(ue.$$.fragment),d$=v(` with respect to
    the net input `),_(_e.$$.fragment),h$=v("."),Pt=E(),ke=C("div"),_(ce.$$.fragment),St=E(),Me=C("p"),y$=v(`The derivative of the sigmoid function is relatively straightforward, but
    the derivation process is somewhat mathematically involved. It is not
    necessary to know the exact steps how we arrive at the derivative, but if
    you are interested, below we provide the necessary steps.`),Wt=E(),_(ge.$$.fragment),Bt=E(),Ye=C("p"),b$=v(`Calculating the gradients from top to bottom results in the following
    gradients.`),It=E(),_(we.$$.fragment),Ft=E(),Re=C("p"),v$=v(`When we deal with several samples the computation does not get much more
    complicated.`),Nt=E(),_(de.$$.fragment),Ot=E(),he=C("p"),x$=v(`As always the gradient of a sum is the sum of the gradients, so the weights
    and the bias would accumulate the gradients through several samples and
    eventually scaled by `),_(ye.$$.fragment),E$=v("."),At=E(),Ge=C("p"),z$=v(`In the interactive example below we demonstrate the gradient descent
    algorithm for logistic regression. This is the same example that you tried
    to solve manually in a previous chapter. Start the algorithm and observe how
    the loss decreases over time.`),Lt=E(),_(be.$$.fragment),Vt=E(),_(ve.$$.fragment),Dt=E(),_(xe.$$.fragment),Ht=E(),je=C("p"),T$=v(`The gradient descent algorithm learns to separate the data in a matter of
    seconds.`),Jt=E(),Ke=C("div"),qt=E(),Qe=C("p"),X$=v(`We can implement logistic regression in PyTorch, using the same techniques
    that we used with linear regression. Hardly any parts of the code need to
    change.`),Mt=E(),_(Ce.$$.fragment),Yt=E(),_(Pe.$$.fragment),Rt=E(),_(Se.$$.fragment),Gt=E(),_(We.$$.fragment),jt=E(),Ue=C("p"),k$=v(`The only code snippet, that is truly different is the forward pass. Here we
    calculate the cross-entropy loss, using some of the built-in PyTorch
    functionalities.`),Kt=E(),_(Be.$$.fragment),Qt=E(),_(Ie.$$.fragment),Ut=E(),Ze=C("p"),C$=v("The training loop remains basically the same."),Zt=E(),_(Fe.$$.fragment),e$=E(),Ne=C("pre"),P$=v(`Cross Entropy: 1.1454823017120361
Cross Entropy: 1.0852206945419312
Cross Entropy: 1.0285975933074951
Cross Entropy: 0.9757254123687744
Cross Entropy: 0.9266657829284668
Cross Entropy: 0.8814209699630737
Cross Entropy: 0.8399296402931213
Cross Entropy: 0.8020696640014648
Cross Entropy: 0.7676653861999512
Cross Entropy: 0.7365001440048218

  `),t$=E(),et=C("div"),this.h()},l(s){t=P(s,"P",{});var p=S(t);$=x(p,"We finally have the means to find the weight vector "),c(e.$$.fragment,p),a=x(p,` and the bias
    `),c(n.$$.fragment,p),u=x(p,` that minimize the binary cross-entropy loss, so let's see how
    we can accomplish this goal.`),p.forEach(l),r=z(s),c(m.$$.fragment,s),y=z(s),b=P(s,"P",{});var nt=S(b);i=x(nt,`The cross-entropy loss is a relatively complex composite function with many
    moving parts, but if we focus on the atomic componets of the function and
    construct a computational graph, as we did for linear regression, we can
    utilize the chain rule and the calculation of gradients becomes relatively
    straightforward.`),nt.forEach(l),X=z(s),T=P(s,"P",{});var rt=S(T);B=x(rt,`In this sec1ion we will try to find the optimal weights and bias that define
    the decision boundary between the two categories in the plot below.`),rt.forEach(l),V=z(s),c(A.$$.fragment,s),Q=z(s),te=P(s,"P",{});var at=S(te);tt=x(at,`The dataset consists of two features, so we start to build our computational
    graph by multiplying each of the features by a corresponding vector.`),at.forEach(l),De=z(s),c(G.$$.fragment,s),He=z(s),J=P(s,"P",{});var U=S(J);$t=x(U,"We call the two scaled values "),c(N.$$.fragment,U),q=x(U," and "),c(O.$$.fragment,U),$e=x(U,` respectively
    and add them together.`),U.forEach(l),ze=z(s),c(Y.$$.fragment,s),Te=z(s),M=P(s,"P",{});var Oe=S(M);Xe=x(Oe,"We sum the two scaled values and add the bias to get the net input "),c(D.$$.fragment,Oe),a$=x(Oe,"."),Oe.forEach(l),yt=z(s),c(se.$$.fragment,s),bt=z(s),Je=P(s,"P",{});var ft=S(Je);f$=x(ft,`Assuming that the features of the sample are 0.75 and 0.89 respectively, the
    weights are 0.5 and -0.5 respectively and the bias is 1, we get the
    following computational graph so far.`),ft.forEach(l),vt=z(s),c(ne.$$.fragment,s),xt=z(s),j=P(s,"P",{});var Z=S(j);l$=x(Z,`In the next step the net input is used as an input into the sigmoid function
    `),c(re.$$.fragment,Z),o$=x(Z," to get the output "),c(ae.$$.fragment,Z),p$=x(Z,"."),Z.forEach(l),Et=z(s),c(fe.$$.fragment,s),zt=z(s),L=P(s,"P",{});var H=S(L);m$=x(H,`Next we use the output of the sigmoid as an input to the cross-entropy loss.
    When you look at the (single sample) loss function
    `),c(le.$$.fragment,H),i$=x(H,`
    , you will notice that the loss is dependent on the label `),c(oe.$$.fragment,H),u$=x(H,`.
    If the label is 1, the loss collapses to `),c(pe.$$.fragment,H),_$=x(H,` and if the
    label is 0 the loss collapses to `),c(me.$$.fragment,H),c$=x(H,`. The sample
    that we have been looking so far corresponds to a label of 1, so our
    computational graph looks as follows.`),H.forEach(l),Tt=z(s),c(ie.$$.fragment,s),Xt=z(s),qe=P(s,"P",{});var lt=S(qe);g$=x(lt,`When we deal with batch or mini-batch gradient descent, we would do the same
    exercise for many other samples and our computational graph would get
    additional nodes. But let's keep the computation simple and assume that we
    are dealing with stochastic gradient descent and would like to calculate the
    gradients using a single sample. The procedure is obviously the same that we
    used with linear regression. We start at the top node and keep calculating
    the intermediary gradients until we reach the weiths and the bias. Along the
    way we multiply the local gradients by the gradients from the above nodes.`),lt.forEach(l),kt=z(s),st=P(s,"P",{}),S(st).forEach(l),Ct=z(s),K=P(s,"P",{});var ee=S(K);w$=x(ee,`You should be already familiar with basic differentiation rules. The only
    difficulty you might face is the derivative of the sigmoid function
    `),c(ue.$$.fragment,ee),d$=x(ee,` with respect to
    the net input `),c(_e.$$.fragment,ee),h$=x(ee,"."),ee.forEach(l),Pt=z(s),ke=P(s,"DIV",{class:!0});var ot=S(ke);c(ce.$$.fragment,ot),ot.forEach(l),St=z(s),Me=P(s,"P",{});var pt=S(Me);y$=x(pt,`The derivative of the sigmoid function is relatively straightforward, but
    the derivation process is somewhat mathematically involved. It is not
    necessary to know the exact steps how we arrive at the derivative, but if
    you are interested, below we provide the necessary steps.`),pt.forEach(l),Wt=z(s),c(ge.$$.fragment,s),Bt=z(s),Ye=P(s,"P",{});var mt=S(Ye);b$=x(mt,`Calculating the gradients from top to bottom results in the following
    gradients.`),mt.forEach(l),It=z(s),c(we.$$.fragment,s),Ft=z(s),Re=P(s,"P",{});var it=S(Re);v$=x(it,`When we deal with several samples the computation does not get much more
    complicated.`),it.forEach(l),Nt=z(s),c(de.$$.fragment,s),Ot=z(s),he=P(s,"P",{});var Ae=S(he);x$=x(Ae,`As always the gradient of a sum is the sum of the gradients, so the weights
    and the bias would accumulate the gradients through several samples and
    eventually scaled by `),c(ye.$$.fragment,Ae),E$=x(Ae,"."),Ae.forEach(l),At=z(s),Ge=P(s,"P",{});var ut=S(Ge);z$=x(ut,`In the interactive example below we demonstrate the gradient descent
    algorithm for logistic regression. This is the same example that you tried
    to solve manually in a previous chapter. Start the algorithm and observe how
    the loss decreases over time.`),ut.forEach(l),Lt=z(s),c(be.$$.fragment,s),Vt=z(s),c(ve.$$.fragment,s),Dt=z(s),c(xe.$$.fragment,s),Ht=z(s),je=P(s,"P",{});var _t=S(je);T$=x(_t,`The gradient descent algorithm learns to separate the data in a matter of
    seconds.`),_t.forEach(l),Jt=z(s),Ke=P(s,"DIV",{class:!0}),S(Ke).forEach(l),qt=z(s),Qe=P(s,"P",{});var ct=S(Qe);X$=x(ct,`We can implement logistic regression in PyTorch, using the same techniques
    that we used with linear regression. Hardly any parts of the code need to
    change.`),ct.forEach(l),Mt=z(s),c(Ce.$$.fragment,s),Yt=z(s),c(Pe.$$.fragment,s),Rt=z(s),c(Se.$$.fragment,s),Gt=z(s),c(We.$$.fragment,s),jt=z(s),Ue=P(s,"P",{});var gt=S(Ue);k$=x(gt,`The only code snippet, that is truly different is the forward pass. Here we
    calculate the cross-entropy loss, using some of the built-in PyTorch
    functionalities.`),gt.forEach(l),Kt=z(s),c(Be.$$.fragment,s),Qt=z(s),c(Ie.$$.fragment,s),Ut=z(s),Ze=P(s,"P",{});var wt=S(Ze);C$=x(wt,"The training loop remains basically the same."),wt.forEach(l),Zt=z(s),c(Fe.$$.fragment,s),e$=z(s),Ne=P(s,"PRE",{class:!0});var dt=S(Ne);P$=x(dt,`Cross Entropy: 1.1454823017120361
Cross Entropy: 1.0852206945419312
Cross Entropy: 1.0285975933074951
Cross Entropy: 0.9757254123687744
Cross Entropy: 0.9266657829284668
Cross Entropy: 0.8814209699630737
Cross Entropy: 0.8399296402931213
Cross Entropy: 0.8020696640014648
Cross Entropy: 0.7676653861999512
Cross Entropy: 0.7365001440048218

  `),dt.forEach(l),t$=z(s),et=P(s,"DIV",{class:!0}),S(et).forEach(l),this.h()},h(){Ve(ke,"class","flex justify-center"),Ve(Ke,"class","separator"),Ve(Ne,"class","text-sm"),Ve(et,"class","separator")},m(s,p){o(s,t,p),k(t,$),g(e,t,null),k(t,a),g(n,t,null),k(t,u),o(s,r,p),g(m,s,p),o(s,y,p),o(s,b,p),k(b,i),o(s,X,p),o(s,T,p),k(T,B),o(s,V,p),g(A,s,p),o(s,Q,p),o(s,te,p),k(te,tt),o(s,De,p),g(G,s,p),o(s,He,p),o(s,J,p),k(J,$t),g(N,J,null),k(J,q),g(O,J,null),k(J,$e),o(s,ze,p),g(Y,s,p),o(s,Te,p),o(s,M,p),k(M,Xe),g(D,M,null),k(M,a$),o(s,yt,p),g(se,s,p),o(s,bt,p),o(s,Je,p),k(Je,f$),o(s,vt,p),g(ne,s,p),o(s,xt,p),o(s,j,p),k(j,l$),g(re,j,null),k(j,o$),g(ae,j,null),k(j,p$),o(s,Et,p),g(fe,s,p),o(s,zt,p),o(s,L,p),k(L,m$),g(le,L,null),k(L,i$),g(oe,L,null),k(L,u$),g(pe,L,null),k(L,_$),g(me,L,null),k(L,c$),o(s,Tt,p),g(ie,s,p),o(s,Xt,p),o(s,qe,p),k(qe,g$),o(s,kt,p),o(s,st,p),o(s,Ct,p),o(s,K,p),k(K,w$),g(ue,K,null),k(K,d$),g(_e,K,null),k(K,h$),o(s,Pt,p),o(s,ke,p),g(ce,ke,null),o(s,St,p),o(s,Me,p),k(Me,y$),o(s,Wt,p),g(ge,s,p),o(s,Bt,p),o(s,Ye,p),k(Ye,b$),o(s,It,p),g(we,s,p),o(s,Ft,p),o(s,Re,p),k(Re,v$),o(s,Nt,p),g(de,s,p),o(s,Ot,p),o(s,he,p),k(he,x$),g(ye,he,null),k(he,E$),o(s,At,p),o(s,Ge,p),k(Ge,z$),o(s,Lt,p),g(be,s,p),o(s,Vt,p),g(ve,s,p),o(s,Dt,p),g(xe,s,p),o(s,Ht,p),o(s,je,p),k(je,T$),o(s,Jt,p),o(s,Ke,p),o(s,qt,p),o(s,Qe,p),k(Qe,X$),o(s,Mt,p),g(Ce,s,p),o(s,Yt,p),g(Pe,s,p),o(s,Rt,p),g(Se,s,p),o(s,Gt,p),g(We,s,p),o(s,jt,p),o(s,Ue,p),k(Ue,k$),o(s,Kt,p),g(Be,s,p),o(s,Qt,p),g(Ie,s,p),o(s,Ut,p),o(s,Ze,p),k(Ze,C$),o(s,Zt,p),g(Fe,s,p),o(s,e$,p),o(s,Ne,p),k(Ne,P$),o(s,t$,p),o(s,et,p),$$=!0},p(s,p){const nt={};p&4194304&&(nt.$$scope={dirty:p,ctx:s}),e.$set(nt);const rt={};p&4194304&&(rt.$$scope={dirty:p,ctx:s}),n.$set(rt);const at={};p&4194304&&(at.$$scope={dirty:p,ctx:s}),m.$set(at);const U={};p&4194304&&(U.$$scope={dirty:p,ctx:s}),A.$set(U);const Oe={};p&4194304&&(Oe.$$scope={dirty:p,ctx:s}),G.$set(Oe);const ft={};p&4194304&&(ft.$$scope={dirty:p,ctx:s}),N.$set(ft);const Z={};p&4194304&&(Z.$$scope={dirty:p,ctx:s}),O.$set(Z);const H={};p&4194304&&(H.$$scope={dirty:p,ctx:s}),Y.$set(H);const lt={};p&4194304&&(lt.$$scope={dirty:p,ctx:s}),D.$set(lt);const ee={};p&4194304&&(ee.$$scope={dirty:p,ctx:s}),se.$set(ee);const ot={};p&32&&(ot.graph=s[5]),ne.$set(ot);const pt={};p&4194304&&(pt.$$scope={dirty:p,ctx:s}),re.$set(pt);const mt={};p&4194304&&(mt.$$scope={dirty:p,ctx:s}),ae.$set(mt);const it={};p&64&&(it.graph=s[6]),fe.$set(it);const Ae={};p&4194304&&(Ae.$$scope={dirty:p,ctx:s}),le.$set(Ae);const ut={};p&4194304&&(ut.$$scope={dirty:p,ctx:s}),oe.$set(ut);const _t={};p&4194304&&(_t.$$scope={dirty:p,ctx:s}),pe.$set(_t);const ct={};p&4194304&&(ct.$$scope={dirty:p,ctx:s}),me.$set(ct);const gt={};p&128&&(gt.graph=s[7]),ie.$set(gt);const wt={};p&4194304&&(wt.$$scope={dirty:p,ctx:s}),ue.$set(wt);const dt={};p&4194304&&(dt.$$scope={dirty:p,ctx:s}),_e.$set(dt);const S$={};p&4194304&&(S$.$$scope={dirty:p,ctx:s}),ce.$set(S$);const W$={};p&4194304&&(W$.$$scope={dirty:p,ctx:s}),ge.$set(W$);const B$={};p&256&&(B$.graph=s[8]),we.$set(B$);const I$={};p&4194304&&(I$.$$scope={dirty:p,ctx:s}),de.$set(I$);const F$={};p&4194304&&(F$.$$scope={dirty:p,ctx:s}),ye.$set(F$);const N$={};p&4194304&&(N$.$$scope={dirty:p,ctx:s}),be.$set(N$);const O$={};p&4194319&&(O$.$$scope={dirty:p,ctx:s}),ve.$set(O$);const A$={};p&4194320&&(A$.$$scope={dirty:p,ctx:s}),xe.$set(A$)},i(s){$$||(w(e.$$.fragment,s),w(n.$$.fragment,s),w(m.$$.fragment,s),w(A.$$.fragment,s),w(G.$$.fragment,s),w(N.$$.fragment,s),w(O.$$.fragment,s),w(Y.$$.fragment,s),w(D.$$.fragment,s),w(se.$$.fragment,s),w(ne.$$.fragment,s),w(re.$$.fragment,s),w(ae.$$.fragment,s),w(fe.$$.fragment,s),w(le.$$.fragment,s),w(oe.$$.fragment,s),w(pe.$$.fragment,s),w(me.$$.fragment,s),w(ie.$$.fragment,s),w(ue.$$.fragment,s),w(_e.$$.fragment,s),w(ce.$$.fragment,s),w(ge.$$.fragment,s),w(we.$$.fragment,s),w(de.$$.fragment,s),w(ye.$$.fragment,s),w(be.$$.fragment,s),w(ve.$$.fragment,s),w(xe.$$.fragment,s),w(Ce.$$.fragment,s),w(Pe.$$.fragment,s),w(Se.$$.fragment,s),w(We.$$.fragment,s),w(Be.$$.fragment,s),w(Ie.$$.fragment,s),w(Fe.$$.fragment,s),$$=!0)},o(s){d(e.$$.fragment,s),d(n.$$.fragment,s),d(m.$$.fragment,s),d(A.$$.fragment,s),d(G.$$.fragment,s),d(N.$$.fragment,s),d(O.$$.fragment,s),d(Y.$$.fragment,s),d(D.$$.fragment,s),d(se.$$.fragment,s),d(ne.$$.fragment,s),d(re.$$.fragment,s),d(ae.$$.fragment,s),d(fe.$$.fragment,s),d(le.$$.fragment,s),d(oe.$$.fragment,s),d(pe.$$.fragment,s),d(me.$$.fragment,s),d(ie.$$.fragment,s),d(ue.$$.fragment,s),d(_e.$$.fragment,s),d(ce.$$.fragment,s),d(ge.$$.fragment,s),d(we.$$.fragment,s),d(de.$$.fragment,s),d(ye.$$.fragment,s),d(be.$$.fragment,s),d(ve.$$.fragment,s),d(xe.$$.fragment,s),d(Ce.$$.fragment,s),d(Pe.$$.fragment,s),d(Se.$$.fragment,s),d(We.$$.fragment,s),d(Be.$$.fragment,s),d(Ie.$$.fragment,s),d(Fe.$$.fragment,s),$$=!1},d(s){s&&l(t),h(e),h(n),s&&l(r),h(m,s),s&&l(y),s&&l(b),s&&l(X),s&&l(T),s&&l(V),h(A,s),s&&l(Q),s&&l(te),s&&l(De),h(G,s),s&&l(He),s&&l(J),h(N),h(O),s&&l(ze),h(Y,s),s&&l(Te),s&&l(M),h(D),s&&l(yt),h(se,s),s&&l(bt),s&&l(Je),s&&l(vt),h(ne,s),s&&l(xt),s&&l(j),h(re),h(ae),s&&l(Et),h(fe,s),s&&l(zt),s&&l(L),h(le),h(oe),h(pe),h(me),s&&l(Tt),h(ie,s),s&&l(Xt),s&&l(qe),s&&l(kt),s&&l(st),s&&l(Ct),s&&l(K),h(ue),h(_e),s&&l(Pt),s&&l(ke),h(ce),s&&l(St),s&&l(Me),s&&l(Wt),h(ge,s),s&&l(Bt),s&&l(Ye),s&&l(It),h(we,s),s&&l(Ft),s&&l(Re),s&&l(Nt),h(de,s),s&&l(Ot),s&&l(he),h(ye),s&&l(At),s&&l(Ge),s&&l(Lt),h(be,s),s&&l(Vt),h(ve,s),s&&l(Dt),h(xe,s),s&&l(Ht),s&&l(je),s&&l(Jt),s&&l(Ke),s&&l(qt),s&&l(Qe),s&&l(Mt),h(Ce,s),s&&l(Yt),h(Pe,s),s&&l(Rt),h(Se,s),s&&l(Gt),h(We,s),s&&l(jt),s&&l(Ue),s&&l(Kt),h(Be,s),s&&l(Qt),h(Ie,s),s&&l(Ut),s&&l(Ze),s&&l(Zt),h(Fe,s),s&&l(e$),s&&l(Ne),s&&l(t$),s&&l(et)}}}function Xn(f){let t,$,e,a,n,u,r,m,y;return m=new Q$({props:{$$slots:{default:[Tn]},$$scope:{ctx:f}}}),{c(){t=C("meta"),$=E(),e=C("h1"),a=v("Minimizing Cross-Entropy"),n=E(),u=C("div"),r=E(),_(m.$$.fragment),this.h()},l(b){const i=K$("svelte-9i9d0s",document.head);t=P(i,"META",{name:!0,content:!0}),i.forEach(l),$=z(b),e=P(b,"H1",{});var X=S(e);a=x(X,"Minimizing Cross-Entropy"),X.forEach(l),n=z(b),u=P(b,"DIV",{class:!0}),S(u).forEach(l),r=z(b),c(m.$$.fragment,b),this.h()},h(){document.title="Minimizing Cross-Entropy - World4AI",Ve(t,"name","description"),Ve(t,"content","The optimal weights and bias for logistic regression can be obtained by minimizing the cross-entropy loss using the gradient descent algorithm."),Ve(u,"class","separator")},m(b,i){k(document.head,t),o(b,$,i),o(b,e,i),k(e,a),o(b,n,i),o(b,u,i),o(b,r,i),g(m,b,i),y=!0},p(b,[i]){const X={};i&4194815&&(X.$$scope={dirty:i,ctx:b}),m.$set(X)},i(b){y||(w(m.$$.fragment,b),y=!0)},o(b){d(m.$$.fragment,b),y=!1},d(b){l(t),b&&l($),b&&l(e),b&&l(n),b&&l(u),b&&l(r),h(m,b)}}}function kn(f,t,$){let e,a,n,u=[[{x:0,y:0},{x:.1,y:.23},{x:.25,y:.93},{x:.15,y:.63},{x:.25,y:.13},{x:.1,y:.93},{x:.12,y:.53},{x:.32,y:.23},{x:.22,y:.5},{x:.49,y:.1},{x:.45,y:.3},{x:.4,y:.7},{x:.35,y:.5},{x:.25,y:.7},{x:.2,y:.2}],[{x:1,y:1},{x:.75,y:.89},{x:.75,y:.75},{x:.95,y:.7},{x:.85,y:.7},{x:.65,y:.8},{x:.85,y:.4},{x:.75,y:.25},{x:.75,y:.55},{x:.95,y:.35},{x:.85,y:.15},{x:.85,y:.95},{x:.9,y:.55},{x:.9,y:.28},{x:.98,y:.95}]],r=[{X:[0,0],y:0},{X:[.1,.23],y:0},{X:[.25,.93],y:0},{X:[.15,.63],y:0},{X:[.25,.13],y:0},{X:[.1,.93],y:0},{X:[.12,.53],y:0},{X:[.32,.23],y:0},{X:[.22,.5],y:0},{X:[.49,.1],y:0},{X:[.45,.3],y:0},{X:[.4,.7],y:0},{X:[.35,.5],y:0},{X:[.25,.7],y:0},{X:[.2,.2],y:0},{X:[1,1],y:1},{X:[.75,.89],y:1},{X:[.75,.75],y:1},{X:[.95,.7],y:1},{X:[.85,.7],y:1},{X:[.65,.8],y:1},{X:[.85,.4],y:1},{X:[.75,.25],y:1},{X:[.75,.55],y:1},{X:[.95,.35],y:1},{X:[.85,.15],y:1},{X:[.85,.95],y:1},{X:[.9,.55],y:1},{X:[.9,.28],y:1},{X:[.98,.95],y:1}],m=new Ee(0),y=0,b=new es(2,"sigmoid"),i=[];function X(){m=new Ee(0),r.forEach(N=>{let q=b.forward(N.X);if(N.y===0){let O=new Ee(1);m=m.add(O.sub(q).log().neg())}else N.y===1&&(m=m.add(q.log().neg()))}),$(3,y=m.data),m.backward(),b.parameters().forEach(N=>{N.data-=.01*N.grad}),b.zeroGrad(),$(18,b)}let T,B,V,A;function Q(){let N=new Ee(.5),q=new Ee(-.5);N._name="Weight: w_1",q._name="Weight: w_2";let O=new Ee(1);O._name="Bias b";let $e=new Ee(r[16].X[0]),ze=new Ee(r[16].X[1]);$e._name="Feature 1: x_1",ze._name="Feature 2: x_2";let Y=N.mul($e),Te=q.mul(ze);Y._name="s_1",Te._name="s_2";let M=Y.add(Te).add(O);M._name="z",$(5,T=JSON.parse(JSON.stringify(M)));let Xe=M.sigmoid();Xe._name="a",$(6,B=JSON.parse(JSON.stringify(Xe)));let D=Xe.log().neg();D._name="L",$(7,V=JSON.parse(JSON.stringify(D))),D.backward(),$(8,A=JSON.parse(JSON.stringify(D)))}Q();const te=`import torch
import sklearn.datasets as datasets`,tt="X, y = datasets.make_classification(n_samples=4, n_features=4)",De=`X = torch.from_numpy(X).to(torch.float32)
y = torch.from_numpy(y).to(torch.float32).unsqueeze(1)`,G=`def init_weights():
    w = torch.randn(1, 4, requires_grad=True)
    b = torch.randn(1, 1, requires_grad=True)
    return w, b`,He=`def forward(w, b):
    z = X @ w.T + b
    sigma = torch.sigmoid(z)
    loss = y * torch.log(sigma) + (1 - y) * torch.log(1 - sigma)
    loss = -loss.mean()
    return loss`,J=`lr = 0.1
w, b = init_weights()`,$t=`for _ in range(10):
    # forward pass
    cross_entropy = forward(w, b)
    
    print(f'Cross Entropy: {cross_entropy.data}')
    
    # backward pass
    cross_entropy.backward()
    
    # gradient descent
    with torch.inference_mode():
        w.data.sub_(w.grad * lr)
        b.data.sub_(b.grad * lr)
        w.grad.zero_()
        b.grad.zero_()`;return f.$$.update=()=>{if(f.$$.dirty&262144&&$(1,e=b.w[0].data),f.$$.dirty&262144&&$(0,a=b.w[1].data),f.$$.dirty&262144&&$(2,n=b.b.data),f.$$.dirty&7){let N=0,q=1,O=(-n-e*N)/a,$e=(-n-e*q)/a;$(4,i=[{x:N,y:O},{x:q,y:$e}])}},[a,e,n,y,i,T,B,V,A,u,X,te,tt,De,G,He,J,$t,b]}class Jn extends R${constructor(t){super(),G$(this,t,kn,Xn,j$,{})}}export{Jn as default};
